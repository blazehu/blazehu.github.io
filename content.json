{"meta":{"title":"小千世界","subtitle":"","description":"","author":"BlazeHu","url":"https://blazehu.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-11-29T12:47:13.667Z","updated":"2021-11-29T12:47:13.667Z","comments":false,"path":"about/index.html","permalink":"https://blazehu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-11-29T12:47:13.668Z","updated":"2021-11-29T12:47:13.668Z","comments":false,"path":"books/index.html","permalink":"https://blazehu.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-29T12:47:13.668Z","updated":"2021-11-29T12:47:13.668Z","comments":true,"path":"links/index.html","permalink":"https://blazehu.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-29T12:47:13.668Z","updated":"2021-11-29T12:47:13.668Z","comments":false,"path":"categories/index.html","permalink":"https://blazehu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-11-29T12:47:13.669Z","updated":"2021-11-29T12:47:13.669Z","comments":false,"path":"repository/index.html","permalink":"https://blazehu.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-29T12:47:13.669Z","updated":"2021-11-29T12:47:13.669Z","comments":false,"path":"tags/index.html","permalink":"https://blazehu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PostgreSQL 主从同步","slug":"pgsql/PostgreSQL 主从同步","date":"2020-03-22T16:00:00.000Z","updated":"2021-11-29T12:47:13.661Z","comments":true,"path":"2020/03/23/pgsql/PostgreSQL 主从同步/","link":"","permalink":"https://blazehu.github.io/2020/03/23/pgsql/PostgreSQL%20%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/","excerpt":"简介PostgreSQL 9.0 引入了主备流复制机制，流复制每次传输单位是 WAL 日志的 record。通过流复制备库不断的从主库同步相应的数据，并在备库 apply 每个 WAL record 。","text":"简介PostgreSQL 9.0 引入了主备流复制机制，流复制每次传输单位是 WAL 日志的 record。通过流复制备库不断的从主库同步相应的数据，并在备库 apply 每个 WAL record 。PostgreSQL 9.0 之前提供的方法是主库写完一个 WAL 日志文件后，才把 WAL 日志文件传送到备库，这样的方式会导致主备延迟特别大。同时 PostgreSQL 9.0 之后提供了 Hot Standby ，备库在应用 WAL record 的同时也能够提供只读服务，大大提升了用户体验。配置主库pgsql 通过容器部署，这里使用 docker-compose主库： 192.168.0.1从库： 192.168.0.2启动主库12345678910pgsql: image: postgres:9.6 restart: always container_name: pgsql ports: - 5432:5432 environment: - POSTGRES_PASSWORD=postgres volumes: - /var/lib/postgresql/data:/var/lib/postgresql/data新建归档日志目录123docker exec -ti pgsql bashmkdir -p /var/lib/postgresql/data/pg_archive新建用户1234create role replica login replication encrypted password 'replica';# 查看是否创建成功\\du修改 pg_hba.conf 文件 (从库ip)1host replication replica 192.168.0.2/32 trust修改 postgresql.conf123456789listen_addresses = '*' # 监听所有 IPwal_level = hot_standby # 开启热备max_wal_senders = 32 # 这个设置了可以最多有几个流复制连接，差不多有几个从，就设置几个wal_keep_segments = 64 # 设置流复制保留的最多的 xlog 数目，一份是 16M，注意机器磁盘 16M * 64 = 1Gwal_sender_timeout = 60 # 设置流复制主机发送数据的超时时间max_connections = 500 # 这个设置要注意下，从库的 max_connections 必须要大于主库的archive_mode = on # 允许归档 # 用该命令来归档logfile segmentarchive_command = 'cp %p /var/lib/postgresql/data/pg_archive/%f'重启容器1docker restart pgsql配置从库启动从库拷贝 docker-compose 文件, 并拉起容器拷贝主服务器数据123456# 清除从库数据rm -rf /var/lib/postgresql/data/* pg_basebackup -h 192.168.0.1 -U replica -D /var/lib/postgresql/data -X stream -Pmkdir -p /var/lib/postgresql/data/pg_archive添加 recovery.conf 文件recovery.conf123standby_mode = on primary_conninfo = 'host=192.168.0.1 port=5432 user=replica password=replica' recovery_target_timeline = 'latest'修改 postgresql.conf123456wal_level = hot_standbyhot_standby_feedback = on # 如果有错误的数据复制，是否向主进行反馈max_connections = 1000 # 一般查多于写的应用从库的最大连接数要比较大hot_standby = on # 说明这台机器不仅仅是用于数据归档，也用于数据查询max_standby_streaming_delay = 30s # 数据流备份的最大延迟时间wal_receiver_status_interval = 10s # 多久向主报告一次从的状态，当然从每次数据复制都会向主报告状态，这里只是设置最长的间隔时间重启从库1docker restart pgsql-slave验证主从123select client_addr, sync_state from pg_stat_replication;ps -ef 查看进程是否存在查看状态123/usr/lib/postgresql/9.6/bin/pg_ctl -D /var/lib/postgresql/data statuspg_controldata /var/lib/postgresql/data参考资料https://www.runoob.com/postgresql/postgresql-tutorial.htmlhttp://mysql.taobao.org/monthly/2015/10/04/","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://blazehu.github.io/tags/PostgreSQL/"}]},{"title":"PostgreSQL 之 pg_stat_statements","slug":"pgsql/PostgreSQL 之 pg_stat_statements","date":"2020-03-21T16:00:00.000Z","updated":"2021-11-29T12:47:13.661Z","comments":true,"path":"2020/03/22/pgsql/PostgreSQL 之 pg_stat_statements/","link":"","permalink":"https://blazehu.github.io/2020/03/22/pgsql/PostgreSQL%20%E4%B9%8B%20pg_stat_statements/","excerpt":"简介pg_stat_statements 模块提供了一种跟踪执行的所有 SQL 语句的统计信息的方法。","text":"简介pg_stat_statements 模块提供了一种跟踪执行的所有 SQL 语句的统计信息的方法。安装插件ubuntu 16.04 安装：1apt-get -y update &amp;&amp; apt-get install -y postgresql-contrib-9.6 postgresql-plpython-9.6如果 pgsql 是通过容器部署可以更新基础镜像：123FROM postgres:9.6RUN apt-get -y update &amp;&amp; apt-get install -y --force-yes postgresql-contrib-9.6 postgresql-plpython-9.6加载模块1shared_preload_libraries = 'pg_stat_statements' # 加载 pg_stat_statements 模块以下可选参数：1234567track_io_timing = on # 跟踪 IO 消耗的时间track_activity_query_size = 2048 # 单条 sql 的最长长度，超过截断显示pg_stat_statements.save = on # 重启后是否保留统计信息 pg_stat_statements.max = 10000 # 最多保留统计信息条数，通过 LRU 算法来覆盖老的记录。 pg_stat_statements.track = all # all：所有 sql 包括函数内嵌套的 sql 、 top：直接执行的 sql 不包括函数内嵌套的、 none：不跟踪 pg_stat_statements.track_utility = off # 是否跟踪非 DML 语句 (例如 DDL、DCL)， on 表示跟踪, off 表示不跟踪重启数据库1docker restart pgsql加载扩展加载扩展模块1create extension pg_stat_statements;卸载扩展模块1drop extension pg_stat_statements;常用分析语句单次调用最耗时1select query from pg_stat_statements order by mean_time desc limit 1;总最耗时1select query from pg_stat_statements order by total_time desc limit 1;响应时间抖动最严重1select query from pg_stat_statements order by stddev_time desc limit 1;单次调用最耗 IO1select query from pg_stat_statements order by (blk_read_time + blk_write_time) /calls desc limit 1;总最耗IO1select query from pg_stat_statements order by (blk_read_time + blk_write_time) desc limit 1;最耗共享内存1select query from pg_stat_statements order by (shared_blks_hit + shared_blks_dirtied) desc limit 1;最耗临时空间1select query from pg_stat_statements order by temp_blks_written desc limit 1;重置统计信息1select pg_stat_statements_reset();参考资料https://www.postgresql.org/docs/9.6/pgstatstatements.htmlhttps://yq.aliyun.com/articles/74421","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://blazehu.github.io/tags/PostgreSQL/"}]},{"title":"PostgreSQL 学习笔记","slug":"pgsql/PostgreSQL 学习笔记","date":"2020-03-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.661Z","comments":true,"path":"2020/03/21/pgsql/PostgreSQL 学习笔记/","link":"","permalink":"https://blazehu.github.io/2020/03/21/pgsql/PostgreSQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"简介PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的 BSD 许可证下发行。","text":"简介PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的 BSD 许可证下发行。命令12345678910\\d 当前数据库的所有表\\dt 只显示匹配的表 \\di 只显示索引\\ds 只显示序列\\dv 只显示视图\\df 只显示函数\\du 列出所有的数据库用户和角色\\dg 列出所有的数据库用户和角色\\encoding 指定客户端的字符编码，如 \\encoding UTF8\\x 把表中的每一行的每列数据都拆分为单行展示, 与 MySQL 中的 \"\\G\" 的功能类似Login123psql -U postgrespsql -h 192.168.0.1 -p 5432 -U repuser -d postgres -Wpsql -U postgres -d test12345678set envexport PGDATABASE=postgresexport PGHOST=192.168.0.1export PGPORT=5432export PGUSER=postgres------------------------------------------------------------------------------psqlLogout1\\qCreate Database1create database test;Use Database123\\c postgres\\c testShow Tables123\\d\\d \"Table1\"Create User1create user repuser REPLICATION LOGIN CONNECTION LIMIT 2 ENCRYPTED PASSWORD 'postgres';Drop User1drop user repuser;备份123pg_dump -U postgres test &gt; test.sql pg_dump -U postgres -d test -s &gt; test.sql # -s, --schema-only dump only the schema, no data查询12345678select \"Name\", \"Age\" from \"Person\" where \"Sex\" = 1 order by \"Age\" desc limit 3; Name| Age ----+------- 张三 | 20 李四 | 18 王五 | 16(3 rows)查看数据库、表、索引大小123select pg_size_pretty(pg_database_size('test'));select pg_size_pretty(pg_table_size('test_table')); select pg_size_pretty(pg_indexes_size('test_index'));查询计划1explain analyze select \"Name\", \"Age\" from \"Person\" where \"Sex\" = 1 order by \"Age\";创建索引12345678CREATE INDEX person_age ON public.\"Person\" USING btree (\"Age\" COLLATE pg_catalog.\"default\") TABLESPACE pg_default;CREATE INDEX person_name ON public.\"Person\" USING btree (\"Name\") TABLESPACE pg_default;查看索引1select * from pg_indexes where tablename='Person';vacuumvacuum 操作可以手动和自动。设置自动 vacuum 注意必须设置 track_counts = true 。具体的设置可以参照官方的文档。（8.3 版本以后）1vacuumdb --analyze --verbose -f --dbname=test好处释放，再利用更新或者删除的行所占据的磁盘空间。更新 PostgreSQL 查询计划中使用的统计数据。防止因事务 ID 的重置而使非常老的数据丢失。原因PostgreSQL 数据的插入，更新，删除操作并不是真正放到数据库空间。如果不定期释放空间的话，由于数据太多，查询速度会巨降。PostgreSQL 在做查询处理的时候，为了是查询速度提高，会根据统计数据来确定执行计划。如果不及时更新的话，查询的效果可能不如预期。PostgreSQL 中每一个事务都会产生一个事务 ID，但这个数字是有上限的。当事务 ID 达到最大值后，会重新从最小值开始循环。这样如果不及时把以前的数据释放掉的话，原来的老数据会因为事务 ID 的丢失而丢失掉。参考资料https://www.runoob.com/postgresql/postgresql-tutorial.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://blazehu.github.io/tags/PostgreSQL/"}]},{"title":"Golang 单例模式","slug":"golang/Golang 单例模式","date":"2019-10-22T16:00:00.000Z","updated":"2021-11-29T12:47:13.646Z","comments":true,"path":"2019/10/23/golang/Golang 单例模式/","link":"","permalink":"https://blazehu.github.io/2019/10/23/golang/Golang%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"简介单例模式是最简单的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。意图： 保证一个类型仅有一个实例，并提供一个访问它的全局访问点。主要解决： 一个全局使用的类型频繁地创建与销毁。何时使用： 当您想控制实例数目，节省系统资源的时候。如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。实现Golang 目前常见的有以下四种方式（懒汉式、 饿汉式、 双重检查、 sync.Once）","text":"简介单例模式是最简单的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。意图： 保证一个类型仅有一个实例，并提供一个访问它的全局访问点。主要解决： 一个全局使用的类型频繁地创建与销毁。何时使用： 当您想控制实例数目，节省系统资源的时候。如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。实现Golang 目前常见的有以下四种方式（懒汉式、 饿汉式、 双重检查、 sync.Once）懒汉式非线程安全12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"unsafe\")type SingletonInstance struct &#123; value int&#125;var singletonInstance *SingletonInstancefunc GetSingletonInstance() *SingletonInstance &#123; if singletonInstance == nil &#123; singletonInstance = new(SingletonInstance) &#125; return singletonInstance&#125;func main() &#123; s := GetSingletonInstance() b := GetSingletonInstance() c := new(SingletonInstance) fmt.Println(unsafe.Pointer(s)) fmt.Println(unsafe.Pointer(b)) fmt.Println(unsafe.Pointer(c))&#125;线程安全利用 sync.Mutex 进行加锁，保证线程安全。缺点： 加锁有了额外开销。123456789101112131415161718type SingletonInstance struct &#123; value int&#125;var ( lock sync.Mutex singletonInstance *SingletonInstance)func GetSingletonInstance() *SingletonInstance &#123; lock.Lock() defer lock.Unlock() if singletonInstance == nil &#123; singletonInstance = new(SingletonInstance) &#125; return singletonInstance&#125;饿汉式导入包的时候直接创建实例，这样无需判空且线程安全。优点： 简单方便缺点： 不管程序中是否使用都会生成该实例，该实例持续占有在内存中适用场景： 该实例使用频繁，功能简单占用内存少123456789type SingletonInstance struct &#123; value int&#125;var singletonInstance SingletonInstancefunc GetSingletonInstance() *SingletonInstance &#123; return &amp;singletonInstance&#125;双重检查第一次判断不加锁，第二次加锁保证线程安全，实例创建完成后，获取实例就不用加锁了。123456789101112131415161718192021type SingletonInstance struct &#123; value int&#125;var ( lock sync.Mutex singletonInstance *SingletonInstance)func GetSingletonInstance() *SingletonInstance &#123; if singletonInstance == nil &#123; lock.Lock() if singletonInstance == nil &#123; singletonInstance = new(SingletonInstance) &#125; lock.Unlock() &#125; return singletonInstance&#125;sync.Oncesync.Once 确保创建实例子的函数只执行一次123456789101112131415type SingletonInstance struct &#123; value int&#125;var ( one sync.Once singletonInstance *SingletonInstance)func GetSingletonInstance() *SingletonInstance &#123; one.Do(func() &#123; singletonInstance = new(SingletonInstance) &#125;) return singletonInstance&#125;sync.Once 源码分析123456789101112131415161718192021222324252627282930package syncimport ( \"sync/atomic\")// Once is an object that will perform exactly one action.type Once struct &#123; done uint32 m Mutex&#125;func (o *Once) Do(f func()) &#123; // o.done 初始化为0，双重检查 if atomic.LoadUint32(&amp;o.done) == 0 &#123; o.doSlow(f) &#125;&#125;func (o *Once) doSlow(f func()) &#123; // 加锁 o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; // o.done 赋值为1，atomic 原子操作 defer atomic.StoreUint32(&amp;o.done, 1) // 执行函数 f() &#125;&#125;参考资料https://www.runoob.com/design-pattern/singleton-pattern.htmlhttps://www.cnblogs.com/wpnine/p/10426105.html","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blazehu.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://blazehu.github.io/tags/Golang/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blazehu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Golang 消息队列之 RabbitMQ","slug":"golang/Golang 消息队列之 RabbitMQ","date":"2019-10-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.646Z","comments":true,"path":"2019/10/21/golang/Golang 消息队列之 RabbitMQ/","link":"","permalink":"https://blazehu.github.io/2019/10/21/golang/Golang%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%20RabbitMQ/","excerpt":"消息队列消息队列（Message Queue）是一种应用间的通信方式，一种应用间的异步协作机制。消息的生产者只需将消息发布到 MQ 中，消息消费者只需要从 MQ 中获取消息消费，消息的可靠性由消息系统来保证。RabbitMQ 简介RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。","text":"消息队列消息队列（Message Queue）是一种应用间的通信方式，一种应用间的异步协作机制。消息的生产者只需将消息发布到 MQ 中，消息消费者只需要从 MQ 中获取消息消费，消息的可靠性由消息系统来保证。RabbitMQ 简介RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 特点可靠性（Reliability）灵活的路由（Flexible Routing）消息集群（Clustering）高可用（Highly Available Queues）多种协议（Multi-protocol）多语言客户端（Many Clients）管理界面（Management UI）跟踪机制（Tracing）插件机制（Plugin System）Exchange 类型类型描述direct路由键完全匹配，单播topic路由键模式匹配，路由键可以包含通配符：”#”、”*”fanout不处理路由键，广播，转发消息最快headers不处理路由键，根据发送的消息内容中的 headers 属性进行匹配，其他跟 direct 模式完全一致，性能较其他模式差很多部署容器化部署，简单方便12345678910111213141516171819202122232425docker run -d --hostname rabbit1 --name rabbitmq1 -p 9419:9419 -p 8080:15672 -p 5672:5672 -e RABBITMQ_ERLANG_COOKIE&#x3D;&#39;rabbitcookie&#39; rabbitmq:3.7.14-managementdocker run -d --hostname rabbit2 --name rabbitmq2 -p 5673:5672 --link rabbitmq1:rabbit1 -e RABBITMQ_ERLANG_COOKIE&#x3D;&#39;rabbitcookie&#39; rabbitmq:3.7.14-managementdocker run -d --hostname rabbit3 --name rabbitmq3 -p 5674:5672 --link rabbitmq1:rabbit1 --link rabbitmq2:rabbit2 -e RABBITMQ_ERLANG_COOKIE&#x3D;&#39;rabbitcookie&#39; rabbitmq:3.7.14-managementdocker exec -it rabbitmq1 bashrabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_appexitdocker exec -it rabbitmq2 bashrabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_appexitdocker exec -it rabbitmq3 bashrabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbit@rabbit1rabbitmqctl start_appexitRabbitMQ Exporterrepo: https://github.com/kbudde/rabbitmq_exporterStart RabbitMQ Exporter:1RABBIT_EXPORTERS=exchange,node,queue RABBIT_CAPABILITIES=bert,no_sort RABBIT_USER=guest RABBIT_PASSWORD=guest OUTPUT_FORMAT=JSON PUBLISH_PORT=8082 RABBIT_URL=http://127.0.0.1:8080 MAX_QUEUES=5000 nohup rabbitmq_exporter &amp;Start in container:1docker run -d --net=container:my-rabbit kbudde/rabbitmq-exporterGolang 客户端 Demo配置123&#123; \"URL\": \"amqp://guest:guest@10.5.124.213:5672/\",&#125;Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package rabbitmqimport ( log \"github.com/sirupsen/logrus\" \"github.com/streadway/amqp\" \"time\")type Config struct &#123; URL string QueueList map[string][]string&#125;type Client struct &#123; Config Connection *amqp.Connection Channel *amqp.Channel&#125;const ( reconnectDelay = 3 * time.Second // reconnectDelay retryNum = 5 // retryNum DefaultExchangeName = \"default\" DefaultQueueName = \"default\")func (c *Client) connect() &#123; var ( err error ) log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", &#125;).Info(\"Attempting to connect.\") c.Connection, err = amqp.Dial(c.URL) if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"err\": err, &#125;).Error(\"Failed to connect to RabbitMQ.\") return &#125; c.Channel, err = c.Connection.Channel() if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"err\": err, &#125;).Error(\"Failed to open a channel.\") return &#125;&#125;func (c *Client) isConnected() bool &#123; if c.Connection.IsClosed() || c.Channel == nil &#123; return false &#125; return true&#125;func (c *Client) handleConnect() &#123; // retry connect for index := 0; index &lt; retryNum; index++ &#123; c.connect() if c.isConnected() &#123; break &#125; else &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", &#125;).Warn(\"Failed to connect. Retrying...\") time.Sleep(reconnectDelay) &#125; &#125; if c.isConnected() &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", &#125;).Info(\"Connect succeed.\") &#125; else &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", &#125;).Fatal(\"Connect failed.\") &#125;&#125;Producer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576type Producer struct &#123; Client&#125;func NewProducer() *Producer &#123; rabbitConfig := new(Config) err := util.ReadConfig(\"RabbitMQ\", rabbitConfig) if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"err\": err, &#125;).Fatal(\"Read config error.\") &#125; producer := &amp;Producer&#123;&#125; producer.URL = rabbitConfig.URL producer.handleConnect() return producer&#125;func (p *Producer) UnsafePushExchange(data map[string]string, exchangeName string) error &#123; // check connect if !p.isConnected() &#123; p.handleConnect() p.initExchange() &#125; // parse data var ( bytesData []byte err error ) if data == nil &#123; return nil &#125; publishData := Msg&#123; Data: data, Time: util.DecodeTime(time.Now().UTC()), &#125; bytesData, err = json.Marshal(publishData) if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"data\": data, \"err\": err, &#125;).Error(\"Failed to marshal a message.\") return err &#125; err = p.Channel.Publish( exchangeName, // exchange \"\", // routing key false, // mandatory false, // immediate amqp.Publishing&#123; DeliveryMode: amqp.Persistent, ContentType: \"application/json\", Body: bytesData, &#125;) if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"err\": err, &#125;).Error(\"Failed to publish a message.\") &#125; else &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"data\": publishData, &#125;).Info(\"Publish a message.\") &#125; return err&#125;Consumer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566type Consumer struct &#123; Client&#125;func NewConsumer(queueName string) *Consumer &#123; rabbitConfig := new(Config) err := util.ReadConfig(\"RabbitMQ\", rabbitConfig) if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"err\": err, &#125;).Fatal(\"Read config error.\") &#125; if queueName == \"\" &#123; queueName = DefaultQueueName &#125; consumer := &amp;Consumer&#123; queueName: queueName, &#125; consumer.URL = rabbitConfig.URL consumer.QueueList = rabbitConfig.QueueList consumer.handleConnect() consumer.initQueue() return consumer&#125;func (c *Consumer) Receive(forever chan struct&#123;&#125;) &#123; // check connect if !c.isConnected() &#123; c.handleConnect() &#125; msgs, err := c.Channel.Consume( c.queueName, // queue \"\", // consumer false, // auto-ack false, // exclusive false, // no-local false, // no-wait nil, // args ) if err != nil &#123; log.WithFields(log.Fields&#123; \"module\": \"RabbitMQ\", \"err\": err, &#125;).Info(\"Failed to register a consumer.\") &#125; go func() &#123; for msg := range msgs &#123; if !c.isConnected() &#123; c.handleConnect() &#125; c.handle(msg.Body) msg.Ack(false) &#125; &#125;() &lt;-forever log.Info(\"Consumer is Done.\")&#125;参考资料https://www.jianshu.com/p/79ca08116d57https://github.com/kbudde/rabbitmq_exporterhttps://www.rabbitmq.com/tutorials/tutorial-four-go.html","categories":[{"name":"Golang","slug":"Golang","permalink":"https://blazehu.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://blazehu.github.io/tags/Golang/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blazehu.github.io/tags/RabbitMQ/"},{"name":"消息队列","slug":"消息队列","permalink":"https://blazehu.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}]},{"title":"API 网关 - Kong 简介","slug":"common/Kong 简介","date":"2019-06-11T16:00:00.000Z","updated":"2021-11-29T12:47:13.645Z","comments":true,"path":"2019/06/12/common/Kong 简介/","link":"","permalink":"https://blazehu.github.io/2019/06/12/common/Kong%20%E7%AE%80%E4%BB%8B/","excerpt":"简介Kong 是由 Mashape 公司开源的，基于 Nginx 的 API Gateway （ Nginx 中运行的 Lua 应用程序 ）。特点功能：授权、日志、IP 限制、限流、API 统计分析、请求转化、跨域（CORS）等等。可扩展： 支持分布式","text":"简介Kong 是由 Mashape 公司开源的，基于 Nginx 的 API Gateway （ Nginx 中运行的 Lua 应用程序 ）。特点功能：授权、日志、IP 限制、限流、API 统计分析、请求转化、跨域（CORS）等等。可扩展： 支持分布式术语术语描述Upstream负载均衡策略Target处理请求的 Backend 服务Service多个 Upstream 的集合Route转发规则，将请求转发给 ServiceConsumer用户，里面记录用户的一些信息CertificateHttps 证书Sni域名与 Certificate 的绑定Plugin插件环境搭建测试服务器： 192.168.0.1Create a Docker network1docker network create kong-netStart Database123456docker run -d --name kong-database \\ --network=kong-net \\ -p 5432:5432 \\ -e \"POSTGRES_USER=kong\" \\ -e \"POSTGRES_DB=kong\" \\ postgres:9.6Prepare Database123456docker run --rm \\ --network=kong-net \\ -e \"KONG_DATABASE=postgres\" \\ -e \"KONG_PG_HOST=kong-database\" \\ -e \"KONG_CASSANDRA_CONTACT_POINTS=kong-database\" \\ kong:latest kong migrations upStart Kong123456789101112131415docker run -d --name kong \\ --network=kong-net \\ -e \"KONG_DATABASE=postgres\" \\ -e \"KONG_PG_HOST=kong-database\" \\ -e \"KONG_CASSANDRA_CONTACT_POINTS=kong-database\" \\ -e \"KONG_PROXY_ACCESS_LOG=/dev/stdout\" \\ -e \"KONG_ADMIN_ACCESS_LOG=/dev/stdout\" \\ -e \"KONG_PROXY_ERROR_LOG=/dev/stderr\" \\ -e \"KONG_ADMIN_ERROR_LOG=/dev/stderr\" \\ -e \"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl\" \\ -p 8000:8000 \\ -p 8443:8443 \\ -p 8001:8001 \\ -p 8444:8444 \\ kong:latestCheck1curl -i http://192.168.0.1:8001/API 调用官网文档https://docs.konghq.com/2.0.x/getting-started/configuring-a-service/背景1234567Kong 部署在 192.168.0.1 机器上另有2台机器部署了 web 服务： 192.168.0.2 192.168.0.3web 服务地址测试接口： http://192.168.0.2:9100/api/v1/test/http://192.168.0.3:9100/api/v1/test/创建 Upstream123curl -i -X POST \\--url http://192.168.0.1:8001/upstreams/ \\--data \"name=backend1\"给 Upstream 添加 Targets1234567curl -i -X POST \\--url http://192.168.0.1:8001/upstreams/backend1/targets \\--data \"target=192.168.0.2:9100\"curl -i -X POST \\--url http://192.168.0.1:8001/upstreams/backend1/targets \\--data \"target=192.168.0.3:9100\"查看 Upstream 的 Targets 是否添加成功12curl -i -X GET \\--url http://10.25.98.128:8001/upstreams/backend1/targets创建 Service1234curl -i -X POST \\--url http://192.168.0.1:8001/services/ \\--data \"name=backend1\" \\--data \"host=backend1\"查看 Service12curl -i -X GET \\--url http://192.168.0.1:8001/services/backend1给 Service 添加 Routes1234567curl -i -X POST --url http://192.168.0.1:8001/routes/ -d &#123; \"service\": &#123; \"id\": \"2bc5f78b-02f8-4109-96c0-0888cbee7ccb\" &#125;, \"methods\": [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]&#125;查看 Service 下的 Routes12curl -i -X GET \\--url http://192.168.0.1:8001/services/manageone-cmdb/routes通过 Kong API 访问 backend1 服务1curl -i -X GET http://192.168.0.1:8000/api/v1/test/参考资料https://docs.konghq.com/2.0.x/getting-started/configuring-a-service/","categories":[{"name":"API 网关","slug":"API-网关","permalink":"https://blazehu.github.io/categories/API-%E7%BD%91%E5%85%B3/"}],"tags":[{"name":"Kong","slug":"Kong","permalink":"https://blazehu.github.io/tags/Kong/"},{"name":"API 网关","slug":"API-网关","permalink":"https://blazehu.github.io/tags/API-%E7%BD%91%E5%85%B3/"}]},{"title":"Rundeck 简介","slug":"common/Rundeck 简介","date":"2019-05-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.645Z","comments":true,"path":"2019/05/21/common/Rundeck 简介/","link":"","permalink":"https://blazehu.github.io/2019/05/21/common/Rundeck%20%E7%AE%80%E4%BB%8B/","excerpt":"简介Rundeck 是一个基于 Java 和 Grails 的开源的运维自动化工具，提供了 Web 管理界面进行操作，同时提供命令行工具和 WebAPI 的访问控制方式。Rundeck 能够帮助开发和运维人员更好地管理各个节点。","text":"简介Rundeck 是一个基于 Java 和 Grails 的开源的运维自动化工具，提供了 Web 管理界面进行操作，同时提供命令行工具和 WebAPI 的访问控制方式。Rundeck 能够帮助开发和运维人员更好地管理各个节点。安装安装方式比较多，这里使用 war 包来简单介绍安装的步骤。官方下载地址： https://docs.rundeck.com/downloads.html官方文档地址： https://docs.rundeck.com/docs/manual/下载官方下载地址下载： rundeck-3.0.7-20181008.war检查依赖12# 选择版本sudo update-alternatives --config java启动时会在当前路径初始化一些 rundeck 目录。如果报错可能是 java 版本的问题，可以重新选择 java 版本。环境变量123PATH=$PATH:$HOME/bin:/root/rundeck/server/sbinexport RDECK_BASE=/root/rundeckexport PATH修改 linux 服务器的环境变量，将 rundeckd 的路径添加到 PATH 里。1rundeckd status配置修改修改登陆密码：server/config/realm.properties12345678910# The format is# &lt;username&gt;: &lt;password&gt;[,&lt;rolename&gt; ...]## Passwords may be clear text, obfuscated or checksummed. The class# org.mortbay.util.Password should be used to generate obfuscated# passwords or password checksums## This sets the temporary user accounts for the Rundeck app#admin:admin,user,admin修改默认端口和访问地址：server/config/rundeck-config.properties12server.address=192.168.1.2grails.serverURL=http://192.168.1.2etc/framework.properties12345678# ----------------------------------------------------------------# Server connection information# ----------------------------------------------------------------framework.server.name=192.168.1.2framework.server.hostname=192.168.1.2framework.server.port=80framework.server.url=http://192.168.1.2修改 dataSource 为 mysql：server/config/rundeck-config.properties12345dataSource.dbCreate=updatedataSource.url=jdbc:mysql://192.168.1.2/rundeck?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8dataSource.username=rootdataSource.password=passworddataSource.driverClassName=com.mysql.jdbc.Driver修改邮件配置：12345grails.mail.default.from=viease@foxmail.comgrails.mail.host=grails.mail.port=25grails.mail.username=grails.mail.password=修改 Project Nodes 配置：projects//etc123456789101112131415161718192021project.name=project.description=project.jobs.gui.groupExpandLevel=1project.ssh-authentication=privateKeyproject.ssh-keypath=/root/.ssh/id_rsaproject.ssh-command-timeout=0project.ssh-connect-timeout=0project.nodeCache.enabled=trueproject.nodeCache.delay=30service.NodeExecutor.default.provider=jsch-sshservice.FileCopier.default.provider=jsch-scp# node 配置文件为本地文件resources.source.1.type=fileresources.source.1.config.includeServerNode=trueresources.source.1.config.requireFileExists=falseresources.source.1.config.generateFileAutomatically=trueresources.source.1.config.format=resourcexmlresources.source.1.config.file=/root/rundeck/projects/&lt;project&gt;/etc/resources.xml# node 配置文件为 urlresources.source.2.type=urlresources.source.2.config.url=http\\://localhost\\:9998/rundeck_nodes启动服务新建一个新的目录 rundeck，将 war 包放在目录内然后运行如下命令启动服务。1java -jar rundeck-3.0.7-20181008.war也可以使用提供的 rundeckd 来管理12[root@localhost ~]# rundeckd -hUsage: /root/rundeck/server/sbin/rundeckd &#123;start|stop|restart|condrestart|status&#125;ArchiveRundeck 可以很方便的备份项目的配置信息，在 Project Settings 里提供导入（Import Archive）导出（Export Archive）项目配置的能力。使用官方文档提供详细的文档：https://docs.rundeck.com/docs/manual/03-getting-started.html参考资料https://docs.rundeck.com/docs/manual/","categories":[{"name":"工具","slug":"工具","permalink":"https://blazehu.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Rundeck","slug":"Rundeck","permalink":"https://blazehu.github.io/tags/Rundeck/"},{"name":"定时任务","slug":"定时任务","permalink":"https://blazehu.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"29. 两数相除","slug":"leetcode-cn/29. 两数相除","date":"2018-03-28T16:00:00.000Z","updated":"2021-11-29T12:47:13.652Z","comments":true,"path":"2018/03/29/leetcode-cn/29. 两数相除/","link":"","permalink":"https://blazehu.github.io/2018/03/29/leetcode-cn/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/","excerpt":"题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2说明被除数和除数均为 32 位有符号整数。 除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。示例1234567输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2","text":"题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2说明被除数和除数均为 32 位有符号整数。 除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。示例1234567输入: dividend = 10, divisor = 3输出: 3解释: 10/3 = truncate(3.33333..) = truncate(3) = 3输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2解法使用递归和位运算。除数以指数形式增长，计算速度快。1234567891. 每次找到最大的n保证 x &gt;= y * pow(2, n)2. divide(x, y) = pow(2, n) + divide(x - y * pow(2, n), y) 3. if x &lt; y: divide(x, y) = 0比如 ：divide(14, 3) = divide(14 - 12, 3) + pow(2, 2) = divide(2, 3) + 4 = 0 + 4 = 412345678910111213141516171819202122232425262728293031323334func divide(dividend int, divisor int) int &#123; abs := func(x int) int &#123; if x &lt; 0 &#123; return x * -1 &#125; return x &#125; pow := func(n int) int &#123; s := 1 for i := 0; i &lt; n; i++ &#123; s *= 2 &#125; return s &#125; min := func(x, y int) int &#123; if x &gt; y &#123; return y &#125; return x &#125; i, a, b := 0, abs(dividend), abs(divisor) if a == 0 || a &lt; b &#123; return 0 &#125; for b &lt;= a &#123; b = b &lt;&lt; 1 i = i + 1 &#125; res := pow(i-1) + divide(a-(b&gt;&gt;1), abs(divisor)) if (dividend ^ divisor) &lt; 0 &#123; res = -res &#125; return min(res, (1&lt;&lt;31)-1)&#125;本地测试123456789101112131415package mainimport ( \"fmt\")func main() &#123; fmt.Println(divide(10, 3)) fmt.Println(divide(12, -3)) fmt.Println(divide(14, 3)) fmt.Println(divide(-1, -1)) fmt.Println(divide(-1, 1)) fmt.Println(divide(0, -1)) fmt.Println(divide(-2147483648, -1))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/divide-two-integers","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"28. 实现 strStr()","slug":"leetcode-cn/28. 实现 strStr()","date":"2018-03-27T16:00:00.000Z","updated":"2021-11-29T12:47:13.652Z","comments":true,"path":"2018/03/28/leetcode-cn/28. 实现 strStr()/","link":"","permalink":"https://blazehu.github.io/2018/03/28/leetcode-cn/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/","excerpt":"题目描述实现 strStr() 函数。说明给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例12345输入: haystack = \"hello\", needle = \"ll\"输出: 2输入: haystack = \"aaaaa\", needle = \"bba\"输出: -1","text":"题目描述实现 strStr() 函数。说明给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。示例12345输入: haystack = \"hello\", needle = \"ll\"输出: 2输入: haystack = \"aaaaa\", needle = \"bba\"输出: -1解法12345678910111213141516171819202122232425262728293031func strStr(haystack string, needle string) int &#123; l1, l2 := len(haystack), len(needle) if l2 &lt; 1 &#123; return 0 &#125; else if l1 &lt; 1 &#123; return -1 &#125; if l1 &lt; l2 &#123; return -1 &#125; i, j := 0, 0 x := i for &#123; if i &gt;= l1 || j &gt;= l2 &#123; break &#125; if haystack[i] == needle[j] &#123; if j == l2-1 &#123; return i - l2 + 1 &#125; else &#123; i++ j++ &#125; &#125; else &#123; i = x + 1 x++ j = 0 &#125; &#125; return -1&#125;本地测试12345678910111213141516package mainimport ( \"fmt\")func main() &#123; a, b := \"hello\", \"ll\" fmt.Println(strStr(a, b)) a, b = \"aaaaa\", \"bba\" fmt.Println(strStr(a, b)) a, b = \"helllllo\", \"ll\" fmt.Println(strStr(a, b)) a, b = \"mississippi\", \"issip\" fmt.Println(strStr(a, b))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-strstr","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"27. 移除元素","slug":"leetcode-cn/27. 移除元素","date":"2018-03-26T16:00:00.000Z","updated":"2021-11-29T12:47:13.651Z","comments":true,"path":"2018/03/27/leetcode-cn/27. 移除元素/","link":"","permalink":"https://blazehu.github.io/2018/03/27/leetcode-cn/27.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"题目描述给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。说明不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例12345678给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。","text":"题目描述给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。说明不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例12345678给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。解法123456789101112131415func removeElement(nums []int, val int) int &#123; length := len(nums) if length &lt; 1 &#123; return 0 &#125; index := 0 for i := 0; i &lt; len(nums); i++ &#123; if val != nums[i] &#123; nums[index] = nums[i] index++ &#125; &#125; nums = nums[:index] return index&#125;本地测试123456789101112package mainimport ( \"fmt\")func main() &#123; n, k := []int&#123;3, 2, 2, 3&#125;, 3 fmt.Println(removeElement(n, k)) n, k = []int&#123;0, 1, 2, 2, 3, 0, 4, 2&#125;, 2 fmt.Println(removeElement(n, k))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-element","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"26. 删除排序数组中的重复项","slug":"leetcode-cn/26. 删除排序数组中的重复项","date":"2018-03-25T16:00:00.000Z","updated":"2021-11-29T12:47:13.651Z","comments":true,"path":"2018/03/26/leetcode-cn/26. 删除排序数组中的重复项/","link":"","permalink":"https://blazehu.github.io/2018/03/26/leetcode-cn/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"题目描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。说明不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。示例1234567给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。","text":"题目描述给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。说明不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。示例1234567给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。解法123456789101112131415161718func removeDuplicates(nums []int) int &#123; length := len(nums) if length &lt; 1 &#123; return 0 &#125; else if length == 1 &#123; return 1 &#125; pre, index := nums[0], 0 for i := 1; i &lt; length; i++ &#123; if pre != nums[i] &#123; pre = nums[i] index++ nums[index] = nums[i] &#125; &#125; nums = nums[:index+1] return index + 1&#125;本地测试1234567891011121314package mainimport ( \"fmt\")func main() &#123; n := []int&#123;1, 1, 1, 1, 1, 2, 3, 4, 5&#125; fmt.Println(removeDuplicates(n)) n = []int&#123;1, 1, 1, 1, 1, 2, 2, 2, 3, 4, 5&#125; fmt.Println(removeDuplicates(n)) n = []int&#123;1, 1, 1, 1, 1, 2, 3&#125; fmt.Println(removeDuplicates(n))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"25. K 个一组翻转链表","slug":"leetcode-cn/25. K 个一组翻转链表","date":"2018-03-24T16:00:00.000Z","updated":"2021-11-29T12:47:13.651Z","comments":true,"path":"2018/03/25/leetcode-cn/25. K 个一组翻转链表/","link":"","permalink":"https://blazehu.github.io/2018/03/25/leetcode-cn/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。示例123给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。","text":"题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。示例123给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。解法空间换时间， 暴力解法123456789101112131415161718192021222324252627282930313233343536373839func reverseKGroup(head *ListNode, k int) *ListNode &#123; if k &lt;= 1 &#123; return head &#125; var ( lists []ListNode newLists []ListNode ) p := head for p != nil &#123; lists = append(lists, *p) p = p.Next &#125; length := len(lists) if length &lt;= 1 || length &lt; k &#123; return head &#125; newLists = make([]ListNode, length) reverse := func(s []ListNode, x int) &#123; for i, j := 0, len(s)-1; i &lt;= j; i, j = i+1, j-1 &#123; newLists[x+i], newLists[x+j] = s[j], s[i] &#125; &#125; for i := 0; i &lt; length/k; i ++ &#123; x := i * k reverse(lists[x:k+x], x) &#125; for i := (length / k) * k; i &lt; length; i++ &#123; newLists[i] = lists[i] &#125; head = &amp;newLists[0] point := head for i := 1; i &lt; len(newLists); i++ &#123; point.Next = &amp;newLists[i] point = point.Next &#125; point.Next = nil return head&#125;本地测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( \"fmt\")type ListNode struct &#123; Val int Next *ListNode&#125;func createListNode(a []int) *ListNode &#123; var head *ListNode if len(a) &lt; 1 &#123; return head &#125; head = &amp;ListNode&#123;Val: a[0]&#125; p := head a = a[1:] for _, item := range a &#123; n := ListNode&#123;Val: item&#125; p.Next = &amp;n p = p.Next &#125; return head&#125;func printListNode(head *ListNode) &#123; if head == nil &#123; fmt.Println(\"nil\") return &#125; for head.Next != nil &#123; fmt.Print(head.Val, \" -&gt; \") head = head.Next &#125; if head != nil &#123; fmt.Print(head.Val, \" -&gt; nil\\n\") &#125;&#125;func main() &#123; n, k := createListNode([]int&#123;1, 2, 3, 4, 5, 6&#125;), 3 printListNode(reverseKGroup(n, k)) n, k = createListNode([]int&#123;1, 2, 3, 4, 5&#125;), 3 printListNode(reverseKGroup(n, k)) n, k = createListNode([]int&#123;1, 2, 3, 4, 5, 6&#125;), 2 printListNode(reverseKGroup(n, k)) n, k = createListNode([]int&#123;&#125;), 2 printListNode(reverseKGroup(n, k))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"24. 两两交换链表中的节点","slug":"leetcode-cn/24. 两两交换链表中的节点","date":"2018-03-23T16:00:00.000Z","updated":"2021-11-29T12:47:13.651Z","comments":true,"path":"2018/03/24/leetcode-cn/24. 两两交换链表中的节点/","link":"","permalink":"https://blazehu.github.io/2018/03/24/leetcode-cn/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.","text":"题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.解法空间换时间， 暴力解法12345678910111213141516171819202122func swapPairs(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var lists []ListNode p := head for p != nil &#123; lists = append(lists, *p) p = p.Next &#125; for i := 0; i &lt; len(lists)-1; i += 2 &#123; lists[i], lists[i+1] = lists[i+1], lists[i] &#125; head = &amp;lists[0] point := head for i := 1; i &lt; len(lists); i++ &#123; point.Next = &amp;lists[i] point = point.Next &#125; point.Next = nil return head&#125;本地测试123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( \"fmt\")type ListNode struct &#123; Val int Next *ListNode&#125;func createListNode(a []int) *ListNode &#123; var head *ListNode if len(a) &lt; 1 &#123; return head &#125; head = &amp;ListNode&#123;Val: a[0]&#125; p := head a = a[1:] for _, item := range a &#123; n := ListNode&#123;Val: item&#125; p.Next = &amp;n p = p.Next &#125; return head&#125;func printListNode(head *ListNode) &#123; if head == nil &#123; fmt.Println(\"nil\") return &#125; for head.Next != nil &#123; fmt.Print(head.Val, \" -&gt; \") head = head.Next &#125; if head != nil &#123; fmt.Print(head.Val, \" -&gt; nil\\n\") &#125;&#125;func main() &#123; n := createListNode([]int&#123;1, 2, 3, 4, 5, 6&#125;) printListNode(swapPairs(n))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"23. 合并K个排序链表","slug":"leetcode-cn/23. 合并K个排序链表","date":"2018-03-22T16:00:00.000Z","updated":"2021-11-29T12:47:13.650Z","comments":true,"path":"2018/03/23/leetcode-cn/23. 合并K个排序链表/","link":"","permalink":"https://blazehu.github.io/2018/03/23/leetcode-cn/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。示例1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6","text":"题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。示例1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func mergeKLists(lists []*ListNode) *ListNode &#123; if len(lists) &lt; 1 &#123; return nil &#125; if len(lists) == 1 &#123; return lists[0] &#125; var ( mix int nilNum int length int l *ListNode p *ListNode pre *ListNode ) length = len(lists) l = &amp;ListNode&#123;&#125; p = l pre = p const MaxNum = 999999999 for nilNum &lt; length &#123; mix = MaxNum nilNum = 0 for i := 0; i &lt; length; i++ &#123; if lists[i] == nil &#123; nilNum++ &#125; else if mix &gt; lists[i].Val &#123; mix = lists[i].Val &#125; &#125; for i := 0; i &lt; length; i++ &#123; if lists[i] != nil &amp;&amp; mix == lists[i].Val &#123; p.Val = mix lists[i] = lists[i].Next break &#125; &#125; if nilNum &lt; length &amp;&amp; mix != MaxNum &#123; p.Next = &amp;ListNode&#123;&#125; pre = p p = p.Next &#125; else if mix == MaxNum &#123; pre.Next = nil &#125; else &#123; p.Next = nil &#125; if nilNum == length &amp;&amp; mix == MaxNum &amp;&amp; p == pre &#123; return nil &#125; &#125; return l&#125;本地测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"fmt\")type ListNode struct &#123; Val int Next *ListNode&#125;func createListNode(a []int) *ListNode &#123; var head *ListNode if len(a) &lt; 1 &#123; return head &#125; head = &amp;ListNode&#123;Val: a[0]&#125; p := head a = a[1:] for _, item := range a &#123; n := ListNode&#123;Val: item&#125; p.Next = &amp;n p = p.Next &#125; return head&#125;func printListNode(head *ListNode) &#123; if head == nil &#123; fmt.Println(\"nil\") return &#125; for head.Next != nil &#123; fmt.Print(head.Val, \" -&gt; \") head = head.Next &#125; if head != nil &#123; fmt.Print(head.Val, \" -&gt; nil\\n\") &#125;&#125;func main() &#123; n := []*ListNode&#123;createListNode([]int&#123;1, 4, 5&#125;), createListNode([]int&#123;1, 3, 4&#125;), createListNode([]int&#123;2, 6&#125;)&#125; printListNode(mergeKLists(n)) n = []*ListNode&#123;createListNode([]int&#123;1&#125;), createListNode([]int&#123;&#125;),&#125; printListNode(mergeKLists(n)) n = []*ListNode&#123;createListNode([]int&#123;&#125;), createListNode([]int&#123;1, 2&#125;),&#125; printListNode(mergeKLists(n)) n = []*ListNode&#123;createListNode([]int&#123;1, 2, 3&#125;), createListNode([]int&#123;4, 5, 6, 7&#125;),&#125; printListNode(mergeKLists(n)) n = []*ListNode&#123;createListNode([]int&#123;&#125;), createListNode([]int&#123;&#125;),&#125; printListNode(mergeKLists(n))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-k-sorted-lists","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"22. 括号生成","slug":"leetcode-cn/22. 括号生成","date":"2018-03-21T16:00:00.000Z","updated":"2021-11-29T12:47:13.650Z","comments":true,"path":"2018/03/22/leetcode-cn/22. 括号生成/","link":"","permalink":"https://blazehu.github.io/2018/03/22/leetcode-cn/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","excerpt":"题目描述数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。示例12345678输入：n = 3输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ]","text":"题目描述数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。示例12345678输入：n = 3输出：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ]解法： 递归1234567891011121314151617181920func backtrack(l, r, n int, str string, strList *[]string) &#123; if l &lt; r &#123; return &#125; if len(str) == 2*n &#123; *strList = append(*strList, str) &#125; if l &lt; n &#123; backtrack(l+1, r, n, str+\"(\", strList) &#125; if r &lt; n &#123; backtrack(l, r+1, n, str+\")\", strList) &#125;&#125;func generateParenthesis(n int) []string &#123; strList := &amp;[]string&#123;&#125; backtrack(0, 0, n, \"\", strList) return *strList&#125;本地测试123456789101112package mainimport ( \"fmt\")func main() &#123; fmt.Println(generateParenthesis(1)) fmt.Println(generateParenthesis(2)) fmt.Println(generateParenthesis(3)) fmt.Println(generateParenthesis(4))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/generate-parentheses","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"21. 合并两个有序链表","slug":"leetcode-cn/21. 合并两个有序链表","date":"2018-03-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.650Z","comments":true,"path":"2018/03/21/leetcode-cn/21. 合并两个有序链表/","link":"","permalink":"https://blazehu.github.io/2018/03/21/leetcode-cn/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"题目描述将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4","text":"题目描述将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4解法123456789101112131415161718192021222324252627282930313233func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; var ( l *ListNode p *ListNode ) if l1 == nil &amp;&amp; l2 == nil &#123; return nil &#125; l = &amp;ListNode&#123;&#125; p = l for l1 != nil || l2 != nil &#123; if l1 == nil &#123; p.Val = l2.Val l2 = l2.Next &#125; else if l2 == nil &#123; p.Val = l1.Val l1 = l1.Next &#125; else if l1.Val &gt; l2.Val &#123; p.Val = l2.Val l2 = l2.Next &#125; else &#123; p.Val = l1.Val l1 = l1.Next &#125; if l1 == nil &amp;&amp; l2 == nil &#123; p.Next = nil &#125; else &#123; p.Next = &amp;ListNode&#123;&#125; p = p.Next &#125; &#125; return l&#125;本地测试12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"fmt\")type ListNode struct &#123; Val int Next *ListNode&#125;func createListNode(a []int) *ListNode &#123; var head *ListNode if len(a) &lt; 1 &#123; return head &#125; head = &amp;ListNode&#123;Val: a[0]&#125; p := head a = a[1:] for _, item := range a &#123; n := ListNode&#123;Val: item&#125; p.Next = &amp;n p = p.Next &#125; return head&#125;func printListNode(head *ListNode) &#123; for head.Next != nil &#123; fmt.Print(head.Val, \" -&gt; \") head = head.Next &#125; if head != nil &#123; fmt.Print(head.Val, \"\\n\") &#125;&#125;func main() &#123; a, b := createListNode([]int&#123;1, 2, 4&#125;), createListNode([]int&#123;1, 3, 4&#125;) printListNode(a) printListNode(b) printListNode(mergeTwoLists(a, b))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"20. 有效的括号","slug":"leetcode-cn/20. 有效的括号","date":"2018-03-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.650Z","comments":true,"path":"2018/03/20/leetcode-cn/20. 有效的括号/","link":"","permalink":"https://blazehu.github.io/2018/03/20/leetcode-cn/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","excerpt":"题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。说明有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例1234567891011121314输入: \"()\"输出: true输入: \"()[]&#123;&#125;\"输出: true输入: \"(]\"输出: false输入: \"([)]\"输出: false输入: \"&#123;[]&#125;\"输出: true","text":"题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。说明有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例1234567891011121314输入: \"()\"输出: true输入: \"()[]&#123;&#125;\"输出: true输入: \"(]\"输出: false输入: \"([)]\"输出: false输入: \"&#123;[]&#125;\"输出: true解法： 栈123456789101112131415161718192021222324252627func isValid(s string) bool &#123; var ( stack *list.List ) stack = list.New() for _, item := range s &#123; if item == 40 || item == 91 || item == 123 &#123; stack.PushBack(item) continue &#125; x := stack.Back() if x == nil &#123; return false &#125; r := x.Value.(int32) if item == 41 &amp;&amp; r == 40 &#123; stack.Remove(x) &#125; else if item == 93 &amp;&amp; r == 91 &#123; stack.Remove(x) &#125; else if item == 125 &amp;&amp; r == 123 &#123; stack.Remove(x) &#125; else &#123; return false &#125; &#125; return stack.Len() == 0&#125;本地测试1234567891011121314151617181920212223package mainimport ( \"fmt\" \"container/list\")func main() &#123; s := \"()\" fmt.Println(isValid(s)) s = \"[()]\" fmt.Println(isValid(s)) s = \"(&#123;)&#125;\" fmt.Println(isValid(s)) s = \"()[]\" fmt.Println(isValid(s)) s = \"([&#123;&#125;])\" fmt.Println(isValid(s)) s = \"]\" fmt.Println(isValid(s)) s = \"(])\" fmt.Println(isValid(s))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"19. 删除链表的倒数第N个节点","slug":"leetcode-cn/19. 删除链表的倒数第N个节点","date":"2018-03-18T16:00:00.000Z","updated":"2021-11-29T12:47:13.649Z","comments":true,"path":"2018/03/19/leetcode-cn/19. 删除链表的倒数第N个节点/","link":"","permalink":"https://blazehu.github.io/2018/03/19/leetcode-cn/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。给定的 n 保证是有效的。示例123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.","text":"题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。给定的 n 保证是有效的。示例123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.解法暴力解法扫描一遍，使用数组存储所有节点12345678910111213141516171819202122232425func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; var ( p *ListNode pList []*ListNode ) p = head for p != nil &#123; pList = append(pList, p) p = p.Next &#125; l := len(pList) if l == 1 &amp;&amp; n == 1 &#123; return nil &#125; pre := l - n - 1 next := l - n + 1 if next &gt;= l &#123; pList[pre].Next = nil &#125; else if pre &lt; 0 &#123; head = head.Next &#125; else &#123; pList[pre].Next = pList[next] &#125; return head&#125;双指针i, j 双指针初始化为表头和表头后 n 个节点。i 和 j 双指针保持窗口大小为 n （间距）同时向后移动，当 j 移动到表尾， i 指向的就是我们要找的倒数第 n 个节点。本地测试123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\")type ListNode struct &#123; Val int Next *ListNode&#125;func createListNode(a []int) *ListNode &#123; var head *ListNode if len(a) &lt; 1 &#123; return head &#125; head = &amp;ListNode&#123;Val: a[0]&#125; p := head a = a[1:] for _, item := range a &#123; n := ListNode&#123;Val: item&#125; p.Next = &amp;n p = p.Next &#125; return head&#125;func printListNode(head *ListNode) &#123; for head.Next != nil &#123; fmt.Print(head.Val, \" -&gt; \") head = head.Next &#125; if head != nil &#123; fmt.Print(head.Val, \"\\n\") &#125;&#125;func main() &#123; a := createListNode([]int&#123;1, 2, 3, 4, 5&#125;) printListNode(a) printListNode(removeNthFromEnd(a, 5))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"18. 四数之和","slug":"leetcode-cn/18. 四数之和","date":"2018-03-17T16:00:00.000Z","updated":"2021-11-29T12:47:13.649Z","comments":true,"path":"2018/03/18/leetcode-cn/18. 四数之和/","link":"","permalink":"https://blazehu.github.io/2018/03/18/leetcode-cn/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。说明：答案中不可以包含重复的四元组。示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]","text":"题目描述：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。说明：答案中不可以包含重复的四元组。示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func fourSum(nums []int, target int) [][]int &#123; sort.Ints(nums) retNum := make([][]int, 0) retMiddleNums := make(map[string]string, 0) retNumStr := make([]string, 0) numLength := len(nums) for x := 0; x &lt; numLength-3; x++ &#123; for i := x + 1; i &lt; numLength-2; i++ &#123; k := i + 1 j := numLength - 1 for k &lt; j &#123; a, b, c, d := nums[i], nums[k], nums[j], nums[x] if a+b+c+d &lt; target &#123; k++ &#125; else if a+b+c+d &gt; target &#123; j-- &#125; else &#123; subRet := append([]int&#123;&#125;, a, b, c, d) sort.Ints(subRet) var numStrList []string var numStr string for i := 0; i &lt; len(subRet); i++ &#123; numStrList = append(numStrList, strconv.Itoa(subRet[i])) &#125; numStr = strings.Join(numStrList, \",\") retMiddleNums[numStr] = \"\" for (k &lt; j) &amp;&amp; (b == nums[k+1]) &#123; k++ &#125; for (k &lt; j) &amp;&amp; (c == nums[j-1]) &#123; j-- &#125; k++ j-- &#125; &#125; &#125; &#125; for numStr := range retMiddleNums &#123; retNumStr = append(retNumStr, numStr) &#125; for index := 0; index &lt; len(retNumStr); index++ &#123; strNumList := strings.Split(retNumStr[index], \",\") var retNumItem []int for i := 0; i &lt; len(strNumList); i++ &#123; numItem, _ := strconv.Atoi(strNumList[i]) retNumItem = append(retNumItem, numItem) &#125; retNum = append(retNum, retNumItem) &#125; return retNum&#125;本地测试12345678910111213141516171819package mainimport ( \"fmt\" \"sort\" \"strconv\" \"strings\")func main() &#123; nums, target := []int&#123;0, 0, 0, 0&#125;, 0 fmt.Println(fourSum(nums, target)) nums, target = []int&#123;1, 0, -1, 0, -2, 2&#125;, 0 fmt.Println(fourSum(nums, target)) nums, target = []int&#123;1, 1, 1, 1, 0, -1, 0, -2, 2, -1, -1, -1, -1&#125;, 0 fmt.Println(fourSum(nums, target)) nums, target = []int&#123;1, 1, 1, 1, 0, -1, 0, -2, 2, -1, -1, -1, -1&#125;, 4 fmt.Println(fourSum(nums, target))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/4sum","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"17. 电话号码的字母组合","slug":"leetcode-cn/17. 电话号码的字母组合","date":"2018-03-16T16:00:00.000Z","updated":"2021-11-29T12:47:13.649Z","comments":true,"path":"2018/03/17/leetcode-cn/17. 电话号码的字母组合/","link":"","permalink":"https://blazehu.github.io/2018/03/17/leetcode-cn/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","excerpt":"题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。说明1 不对应任何字母。示例12输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].","text":"题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。说明1 不对应任何字母。示例12输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].解法（递归求解）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func letterCombinations(digits string) []string &#123; var ( all []string ) if len(digits) &lt; 1 &#123; return []string&#123;&#125; &#125; numMap := map[string][]string&#123; \"2\": &#123;\"a\", \"b\", \"c\"&#125;, \"3\": &#123;\"d\", \"e\", \"f\"&#125;, \"4\": &#123;\"g\", \"h\", \"i\"&#125;, \"5\": &#123;\"j\", \"k\", \"l\"&#125;, \"6\": &#123;\"m\", \"n\", \"o\"&#125;, \"7\": &#123;\"p\", \"q\", \"r\", \"s\"&#125;, \"8\": &#123;\"t\", \"u\", \"v\"&#125;, \"9\": &#123;\"w\", \"x\", \"y\", \"z\"&#125;, &#125; getTwoLetterCombinations := func(num1, num2 []string) []string &#123; var ( strList []string ) l1, l2 := len(num1), len(num2) i := 0 for i &lt; l1 &#123; j := 0 for j &lt; l2 &#123; strList = append(strList, num1[i]) j++ &#125; i++ &#125; i = 0 for i &lt; l2*l1 &#123; strList[i] += num2[i%l2] i++ &#125; return strList &#125; numStr := string(digits[0]) all = numMap[numStr] for index := 1; index &lt; len(digits); index++ &#123; numStr := string(digits[index]) numStrList := numMap[numStr] all = getTwoLetterCombinations(all, numStrList) &#125; return all&#125;本地测试123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; s := \"23\" fmt.Println(letterCombinations(s)) s = \"2\" fmt.Println(letterCombinations(s)) s = \"27\" fmt.Println(letterCombinations(s)) s = \"234\" fmt.Println(letterCombinations(s)) s = \"34\" fmt.Println(letterCombinations(s))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"16. 最接近的三数之和","slug":"leetcode-cn/16. 最接近的三数之和","date":"2018-03-15T16:00:00.000Z","updated":"2021-11-29T12:47:13.648Z","comments":true,"path":"2018/03/16/leetcode-cn/16. 最接近的三数之和/","link":"","permalink":"https://blazehu.github.io/2018/03/16/leetcode-cn/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。示例123给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).","text":"题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。示例123给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586func threeSumClosest(nums []int, target int) int &#123; var ( l int r int t int sumList []int sum int ) abs := func(x int) (int, bool) &#123; if x &lt; 0 &#123; return x * -1, true &#125; return x, false &#125; length := func(x, y int) int &#123; if x &gt;= 0 &amp;&amp; y &lt;= 0 &#123; return x - y &#125; else if x &lt;= 0 &amp;&amp; y &gt;= 0 &#123; return y - x &#125; else &#123; if x &gt; y &#123; return x - y &#125; else &#123; return y - x &#125; &#125; &#125; l, r = 0, len(nums)-1 if r &lt; 2 &#123; return 0 &#125; if r == 2 &#123; return nums[0] + nums[1] + nums[2] &#125; sort.Ints(nums) for &#123; if l &gt;= r &#123; break &#125; m := nums[l] + nums[r] perfectValue := target - m dValue, direction := -1, true for index := 0; index &lt; len(nums); index++ &#123; if index == l || index == r &#123; continue &#125; if nums[index] == perfectValue &#123; return target &#125; x, y := abs(nums[index] - perfectValue) if dValue &lt; 0 &#123; dValue, direction, t = x, y, nums[index] continue &#125; if dValue &gt; x &#123; dValue, direction, t = x, y, nums[index] &#125; &#125; sumList = append(sumList, m+t) if direction &#123; l++ &#125; else &#123; r-- &#125; &#125; sort.Ints(sumList) if len(sumList) &lt; 1 &#123; return 0 &#125; else if len(sumList) == 1 &#123; return sumList[0] &#125; else &#123; sum = sumList[0] dValue := length(sum, target) index := 1 for index &lt; len(sumList) &#123; if dValue &gt; length(sumList[index], target) &#123; sum = sumList[index] dValue = length(sum, target) &#125; index++ &#125; &#125; return sum&#125;本地测试123456789101112131415package mainimport ( \"fmt\" \"sort\")func main() &#123; nums, target := []int&#123;-1, 2, 1, -4&#125;, 1 fmt.Println(threeSumClosest(nums, target)) nums, target = []int&#123;-1, 0, 1, 1, 55&#125;, 3 fmt.Println(threeSumClosest(nums, target)) nums, target = []int&#123;1, 2, 5, 10, 11&#125;, 12 fmt.Println(threeSumClosest(nums, target))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum-closest","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"15. 三数之和","slug":"leetcode-cn/15. 三数之和","date":"2018-03-14T16:00:00.000Z","updated":"2021-11-29T12:47:13.648Z","comments":true,"path":"2018/03/15/leetcode-cn/15. 三数之和/","link":"","permalink":"https://blazehu.github.io/2018/03/15/leetcode-cn/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目描述给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。说明答案中不可以包含重复的三元组。示例1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]]","text":"题目描述给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。说明答案中不可以包含重复的三元组。示例1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]]解法1234567891011121314151617181920212223242526272829303132func threeSum(nums []int) [][]int &#123; sort.Ints(nums) retNum := make([][]int, 0) numLength := len(nums) for i := 0; (i &lt; numLength-2) &amp;&amp; (nums[i] &lt;= 0); i++ &#123; k := i + 1 j := numLength - 1 if (i &gt; 0) &amp;&amp; (nums[i] == nums[i-1]) &#123; continue &#125; for k &lt; j &#123; a, b, c := nums[i], nums[k], nums[j] if a+b+c &lt; 0 &#123; k++ &#125; else if a+b+c &gt; 0 &#123; j-- &#125; else &#123; subRet := append([]int&#123;&#125;, a, b, c) retNum = append(retNum, subRet) for (k &lt; j) &amp;&amp; (b == nums[k+1]) &#123; k++ &#125; for (k &lt; j) &amp;&amp; (c == nums[j-1]) &#123; j-- &#125; k++ j-- &#125; &#125; &#125; return retNum&#125;本地测试123456789101112131415161718192021package mainimport ( \"fmt\" \"sort\")func main() &#123; nums := []int&#123;-1, 0, 1, 2, -1, -4&#125; fmt.Println(threeSum(nums)) nums = []int&#123;&#125; fmt.Println(threeSum(nums)) nums = []int&#123;1, 1, -2&#125; fmt.Println(threeSum(nums)) nums = []int&#123;0, 0, 0&#125; fmt.Println(threeSum(nums)) nums = []int&#123;-4, -2, -2, -2, 0, 1, 2, 2, 2, 3, 3, 4, 4, 6, 6&#125; fmt.Println(threeSum(nums)) nums = []int&#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125; fmt.Println(threeSum(nums))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"14. 最长公共前缀","slug":"leetcode-cn/14. 最长公共前缀","date":"2018-03-13T16:00:00.000Z","updated":"2021-11-29T12:47:13.648Z","comments":true,"path":"2018/03/14/leetcode-cn/14. 最长公共前缀/","link":"","permalink":"https://blazehu.github.io/2018/03/14/leetcode-cn/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。说明所有输入只包含小写字母 a-z。示例12345678示例 1:输入: [\"flower\",\"flow\",\"flight\"]输出: \"fl\"示例 2:输入: [\"dog\",\"racecar\",\"car\"]输出: \"\"解释: 输入不存在公共前缀。","text":"题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。说明所有输入只包含小写字母 a-z。示例12345678示例 1:输入: [\"flower\",\"flow\",\"flight\"]输出: \"fl\"示例 2:输入: [\"dog\",\"racecar\",\"car\"]输出: \"\"解释: 输入不存在公共前缀。解法12345678910111213141516171819202122232425262728293031func longestCommonPrefix(strs []string) string &#123; var ( index int prefixStr uint8 ) if len(strs) &lt; 1 &#123; return \"\" &#125; else if len(strs) == 1 &#123; return strs[0] &#125; if len(strs[0]) &lt; 1 &#123; return \"\" &#125; index = 0 for &#123; if index &gt;= len(strs[0]) &#123; return strs[0][:index] &#125; for strIndex := 1; strIndex &lt; len(strs); strIndex++ &#123; if index &gt;= len(strs[strIndex]) &#123; return strs[0][:index] &#125; prefixStr = strs[0][index] if strs[strIndex][index] != prefixStr &#123; return strs[0][:index] &#125; &#125; index++ &#125; return strs[0][:index]&#125;本地测试123456789101112131415161718package mainimport \"fmt\"func main() &#123; s := []string&#123;\"flower\", \"flow\", \"flight\"&#125; fmt.Println(longestCommonPrefix(s)) s = []string&#123;\"dog\", \"area\", \"car\"&#125; fmt.Println(longestCommonPrefix(s)) s = []string&#123;\"a\", \"a\", \"ab\"&#125; fmt.Println(longestCommonPrefix(s)) s = []string&#123;\"abcd\", \"a\", \"ab\"&#125; fmt.Println(longestCommonPrefix(s)) s = []string&#123;\"a\"&#125; fmt.Println(longestCommonPrefix(s)) s = []string&#123;\"a\", \"ac\"&#125; fmt.Println(longestCommonPrefix(s))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"13. 罗马数字转整数","slug":"leetcode-cn/13. 罗马数字转整数","date":"2018-03-12T16:00:00.000Z","updated":"2021-11-29T12:47:13.648Z","comments":true,"path":"2018/03/13/leetcode-cn/13. 罗马数字转整数/","link":"","permalink":"https://blazehu.github.io/2018/03/13/leetcode-cn/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","excerpt":"题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：1234I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。","text":"题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：1234I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例1234567891011121314151617示例 1:输入: \"III\"输出: 3示例 2:输入: \"IV\"输出: 4示例 3:输入: \"LVIII\"输出: 58解释: L = 50, V= 5, III = 3.示例 4:输入: \"MCMXCIV\"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.解法1234567891011121314151617181920212223242526272829func romanToInt(s string) int &#123; var ( num int b int e int flag bool // 用来判断最后一位有效罗马数字是否计算过 ) numMap := map[string]int&#123; \"I\": 1, \"II\": 2, \"III\": 3, \"IV\": 4, \"V\": 5, \"VI\": 6, \"VII\": 7, \"VIII\": 8, \"IX\": 9, \"X\": 10, \"XX\": 20, \"XXX\": 30, \"XL\": 40, \"L\": 50, \"LX\": 60, \"LXX\": 70, \"LXXX\": 80, \"XC\": 90, \"C\": 100, \"CC\": 200, \"CCC\": 300, \"CD\": 400, \"D\": 500, \"DC\": 600, \"DCC\": 700, \"DCCC\": 800, \"CM\": 900, \"M\": 1000, \"MM\": 2000, \"MMM\": 3000, &#125; flag = true for b, e = 0, 1; e &lt;= len(s); e++ &#123; if numMap[s[b:e]] == 0 &#123; flag = false num += numMap[s[b:e-1]] b = e - 1 &#125; else if e == len(s) &#123; flag = true num += numMap[s[b:e]] &#125; &#125; if !flag &#123; num += numMap[s[b:e-1]] &#125; return num&#125;本地测试12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; s := \"III\" fmt.Println(romanToInt(s)) s = \"IV\" fmt.Println(romanToInt(s)) s = \"IX\" fmt.Println(romanToInt(s)) s = \"LVIII\" fmt.Println(romanToInt(s)) s = \"MCMXCIV\" fmt.Println(romanToInt(s)) s = \"DCXXI\" fmt.Println(romanToInt(s)) s = \"XIII\" fmt.Println(romanToInt(s)) s = \"XI\" fmt.Println(romanToInt(s))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"12. 整数转罗马数字","slug":"leetcode-cn/12. 整数转罗马数字","date":"2018-03-11T16:00:00.000Z","updated":"2021-11-29T12:47:13.647Z","comments":true,"path":"2018/03/12/leetcode-cn/12. 整数转罗马数字/","link":"","permalink":"https://blazehu.github.io/2018/03/12/leetcode-cn/12.%20%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","excerpt":"题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：1234I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。","text":"题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：1234I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。示例123456789101112131415161718192021示例 1:输入: 3输出: \"III\"示例 2:输入: 4输出: \"IV\"示例 3:输入: 9输出: \"IX\"示例 4:输入: 58输出: \"LVIII\"解释: L = 50, V = 5, III = 3.示例 5:输入: 1994输出: \"MCMXCIV\"解释: M = 1000, CM = 900, XC = 90, IV = 4.解法12345678910111213141516171819202122func intToRoman(num int) string &#123; var ( numStr string k int ) numMap := map[int][]string&#123; 0: &#123;\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"&#125;, 1: &#123;\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"&#125;, 2: &#123;\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"&#125;, 3: &#123;\"\", \"M\", \"MM\", \"MMM\"&#125;, &#125; if num &lt; 1 || num &gt; 3999 &#123; return \"\" &#125; else &#123; for num &gt; 0 &#123; numStr = numMap[k][num%10] + numStr num /= 10 k++ &#125; &#125; return numStr&#125;本地测试12345678910111213141516package mainimport \"fmt\"func main() &#123; n := 3 fmt.Println(intToRoman(n)) n = 4 fmt.Println(intToRoman(n)) n = 9 fmt.Println(intToRoman(n)) n = 58 fmt.Println(intToRoman(n)) n = 1994 fmt.Println(intToRoman(n))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-to-roman","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"11. 盛最多水的容器","slug":"leetcode-cn/11. 盛最多水的容器","date":"2018-03-10T16:00:00.000Z","updated":"2021-11-29T12:47:13.647Z","comments":true,"path":"2018/03/11/leetcode-cn/11. 盛最多水的容器/","link":"","permalink":"https://blazehu.github.io/2018/03/11/leetcode-cn/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"题目描述给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明你不能倾斜容器，且 n 的值至少为 2。示例12输入：[1,8,6,2,5,4,8,3,7]输出：49","text":"题目描述给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明你不能倾斜容器，且 n 的值至少为 2。示例12输入：[1,8,6,2,5,4,8,3,7]输出：49解法12345678910111213141516171819202122232425262728293031323334func maxArea(height []int) int &#123; var ( b int e int area int ) getArea := func(x1, x2 int) int &#123; x := x1 - x2 if x &lt; 0 &#123; x *= -1 &#125; if height[x1] &gt; height[x2] &#123; return height[x2] * x &#125; else &#123; return height[x1] * x &#125; &#125; getMax := func(x, y int) int &#123; if x &gt; y &#123; return x &#125; return y &#125; b, e = 0, len(height)-1 for b &lt; e &#123; area = getMax(getArea(b, e), area) if height[b] &lt; height[e] &#123; b++ &#125; else &#123; e-- &#125; &#125; return area&#125;本地测试12345678910package mainimport \"fmt\"func main() &#123; n := []int&#123;2, 3, 4, 5, 18, 17, 6&#125; fmt.Println(maxArea(n)) n = []int&#123;1, 8, 6, 2, 5, 4, 8, 3, 7&#125; fmt.Println(maxArea(n))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"10. 正则表达式匹配","slug":"leetcode-cn/10. 正则表达式匹配","date":"2018-03-09T16:00:00.000Z","updated":"2021-11-29T12:47:13.647Z","comments":true,"path":"2018/03/10/leetcode-cn/10. 正则表达式匹配/","link":"","permalink":"https://blazehu.github.io/2018/03/10/leetcode-cn/10.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"题目描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。说明s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。","text":"题目描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。说明s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例123456789101112131415161718192021222324252627282930313233示例 1:输入:s = \"aa\"p = \"a\"输出: false解释: \"a\" 无法匹配 \"aa\" 整个字符串。示例 2:输入:s = \"aa\"p = \"a*\"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。示例 3:输入:s = \"ab\"p = \".*\"输出: true解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。示例 4:输入:s = \"aab\"p = \"c*a*b\"输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。示例 5:输入:s = \"mississippi\"p = \"mis*is*p*.\"输出: false解法1234567891011121314151617181920212223242526272829303132333435363738394041func isMatch(s string, p string) bool &#123; strList := regexp.MustCompile(p).FindAllString(s, -1) for index := 0; index &lt; len(strList); index++ &#123; if strList[index] == s &#123; return true &#125; &#125; return false&#125;func isMatch(s string, p string) bool &#123; m, n := len(s), len(p) matches := func(i, j int) bool &#123; if i == 0 &#123; return false &#125; if p[j-1] == '.' &#123; return true &#125; return s[i-1] == p[j-1] &#125; f := make([][]bool, m + 1) for i := 0; i &lt; len(f); i++ &#123; f[i] = make([]bool, n + 1) &#125; f[0][0] = true for i := 0; i &lt;= m; i++ &#123; for j := 1; j &lt;= n; j++ &#123; if p[j-1] == '*' &#123; f[i][j] = f[i][j] || f[i][j-2] if matches(i, j - 1) &#123; f[i][j] = f[i][j] || f[i-1][j] &#125; &#125; else if matches(i, j) &#123; f[i][j] = f[i][j] || f[i-1][j-1] &#125; &#125; &#125; return f[m][n]&#125;本地测试123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"regexp\")func main() &#123; // . 46, * 42 s, p := \"aa\", \"a\" fmt.Println(isMatch(s, p) == false) s, p = \"aa\", \"a*\" fmt.Println(isMatch(s, p) == true) s, p = \"ab\", \".*\" fmt.Println(isMatch(s, p) == true) s, p = \"ab\", \".*c\" fmt.Println(isMatch(s, p) == false) s, p = \"aab\", \"c*a*b\" fmt.Println(isMatch(s, p) == true) s, p = \"mississippi\", \"mis*is*p*.\" fmt.Println(isMatch(s, p) == false) s, p = \"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\" fmt.Println(isMatch(s, p) == true) s, p = \"aaacb\", \"a*acb\" fmt.Println(isMatch(s, p) == true) s, p = \"aaa\", \"a*a\" fmt.Println(isMatch(s, p) == true) s, p = \"aaa\", \"ab*a*c*a\" fmt.Println(isMatch(s, p) == true)&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/regular-expression-matching","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"9. 回文数","slug":"leetcode-cn/9. 回文数","date":"2018-03-08T16:00:00.000Z","updated":"2021-11-29T12:47:13.653Z","comments":true,"path":"2018/03/09/leetcode-cn/9. 回文数/","link":"","permalink":"https://blazehu.github.io/2018/03/09/leetcode-cn/9.%20%E5%9B%9E%E6%96%87%E6%95%B0/","excerpt":"题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例12345678910111213示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。","text":"题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例12345678910111213示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。解法12345678910111213141516func isPalindrome(x int) bool &#123; if x &lt; 0 &#123; return false &#125; if x == 0 &#123; return true &#125; str := strconv.Itoa(x) strLength := len(str) for index := 0; index &lt; strLength; index++ &#123; if str[index] != str[strLength-index-1] &#123; return false &#125; &#125; return true&#125;本地测试123456789101112131415package mainimport ( \"fmt\" \"strconv\")func main() &#123; n := 121 fmt.Println(isPalindrome(n), true) n = -121 fmt.Println(isPalindrome(n), false) n = 10 fmt.Println(isPalindrome(n), false)&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-number","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"8. 字符串转换整数 (atoi)","slug":"leetcode-cn/8. 字符串转换整数 (atoi)","date":"2018-03-07T16:00:00.000Z","updated":"2021-11-29T12:47:13.653Z","comments":true,"path":"2018/03/08/leetcode-cn/8. 字符串转换整数 (atoi)/","link":"","permalink":"https://blazehu.github.io/2018/03/08/leetcode-cn/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/","excerpt":"题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。说明本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。","text":"题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。说明本题中的空白字符只包括空格字符 ‘ ‘ 。假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。示例1234567891011121314151617181920212223242526示例 1:输入: \"42\"输出: 42示例 2:输入: \" -42\"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3:输入: \"4193 with words\"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。示例 4:输入: \"words and 987\"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5:输入: \"-91283472332\"输出: -2147483648解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func myAtoi(str string) int &#123; var ( f int numStr string num int k int ) for &#123; if len(str) &lt; 1 &#123; return 0 &#125; ch := str[0] if ch == 32 &#123; str = str[1:] &#125; else &#123; break &#125; &#125; ch := str[0] if ch == 45 &#123; str = str[1:] f = -1 &#125; else if ch == 43 &#123; str = str[1:] f = 1 &#125; else if ch &gt;= 48 &amp;&amp; ch &lt;= 57 &#123; f = 1 &#125; else &#123; f = 0 &#125; if f == 0 &#123; return 0 &#125; else &#123; for index := 0; index &lt; len(str); index++ &#123; if str[index] &gt;= 48 &amp;&amp; str[index] &lt;= 57 &#123; numStr += string(str[index]) &#125; else &#123; break &#125; &#125; &#125; newNumLength := len(numStr) for index := 0; index &lt; newNumLength; index++ &#123; if k != 0 &#123; num *= 10 &#125; num += int(numStr[index]) - 48 k++ if num*f &gt;= 2147483648 &#123; return 2147483647 &#125; if num*f &lt; -2147483648 &#123; return -2147483648 &#125; &#125; num = num * f return num&#125;本地测试123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\")func main() &#123; s := \"42\" fmt.Println(myAtoi(s), 42) s = \" \" fmt.Println(myAtoi(s), 0) s = \" \" fmt.Println(myAtoi(s), 0) s = \"\" fmt.Println(myAtoi(s), 0) s = \"-42\" fmt.Println(myAtoi(s), -42) s = \" -42\" fmt.Println(myAtoi(s), -42) s = \"+42\" fmt.Println(myAtoi(s), 42) s = \"0\" fmt.Println(myAtoi(s), 0) s = \"9\" fmt.Println(myAtoi(s), 9) s = \"4193 with words\" fmt.Println(myAtoi(s), 4193) s = \"words and 987\" fmt.Println(myAtoi(s), 0) s = \"-91283472332\" fmt.Println(myAtoi(s), -2147483648) s = \"2147483648\" fmt.Println(myAtoi(s), 2147483647) s = \"9223372036854775808\" fmt.Println(myAtoi(s), 2147483647)&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/string-to-integer-atoi","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"7. 整数反转","slug":"leetcode-cn/7. 整数反转","date":"2018-03-06T16:00:00.000Z","updated":"2021-11-29T12:47:13.653Z","comments":true,"path":"2018/03/07/leetcode-cn/7. 整数反转/","link":"","permalink":"https://blazehu.github.io/2018/03/07/leetcode-cn/7.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1234567891011示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21","text":"题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1234567891011示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21解法12345678910111213141516171819202122232425func reverse(x int) int &#123; var ( n int k int f int ) f = 1 if x &lt; 0 &#123; f = -1 x *= f &#125; for x &gt; 0 &#123; if k != 0 &#123; n *= 10 &#125; n += x % 10 x /= 10 k++ &#125; n *= f if n &gt; 2147483648 || n &lt; -2147483648 &#123; n = 0 &#125; return n&#125;本地测试123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; n := 123 fmt.Println(reverse(n), n) n = -123 fmt.Println(reverse(n), n) n = 120 fmt.Println(reverse(n), n) n = 1534236469 fmt.Println(reverse(n), n) n = 1563847412 fmt.Println(reverse(n), n)&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"6. Z 字形变换","slug":"leetcode-cn/6. Z 字形变换","date":"2018-03-05T16:00:00.000Z","updated":"2021-11-29T12:47:13.653Z","comments":true,"path":"2018/03/06/leetcode-cn/6. Z 字形变换/","link":"","permalink":"https://blazehu.github.io/2018/03/06/leetcode-cn/6.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","excerpt":"题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows);示例1234567891011121314示例 1:输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\"示例 2:输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L D RE O E I IE C I H NT S G","text":"题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows);示例1234567891011121314示例 1:输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\"示例 2:输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L D RE O E I IE C I H NT S G解法12345678910111213141516171819202122func convert(s string, numRows int) string &#123; var ( convertStr = \"\" convertSubStrList = make([]string, numRows) ) if numRows &lt; 1 &#123; return \"\" &#125; else if numRows == 1 &#123; return s &#125; for index := 0; index &lt; len(s); index++ &#123; k := index % (2*numRows - 2) y := 2*numRows - 2 - k if k &gt;= 0 &amp;&amp; k &lt; numRows &#123; convertSubStrList[k] += string(s[index]) &#125; else if y &gt;= 0 &amp;&amp; y &lt; numRows &#123; convertSubStrList[y] += string(s[index]) &#125; &#125; convertStr = strings.Join(convertSubStrList, \"\") return convertStr&#125;本地测试12345678910111213package mainimport ( \"fmt\" \"strings\")func main() &#123; s, l := \"LEETCODEISHIRING\", 3 fmt.Println(convert(s, l), \"LCIRETOESIIGEDHN\") s, l = \"LEETCODEISHIRING\", 4 fmt.Println(convert(s, l), \"LDREOEIIECIHNTSG\")&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zigzag-conversion","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"5. 最长回文子串","slug":"leetcode-cn/5. 最长回文子串","date":"2018-03-04T16:00:00.000Z","updated":"2021-11-29T12:47:13.653Z","comments":true,"path":"2018/03/05/leetcode-cn/5. 最长回文子串/","link":"","permalink":"https://blazehu.github.io/2018/03/05/leetcode-cn/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例12345678示例 1：输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。示例 2：输入: \"cbbd\"输出: \"bb\"","text":"题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例12345678示例 1：输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。示例 2：输入: \"cbbd\"输出: \"bb\"解法123456789101112131415161718192021222324252627282930313233343536373839func longestPalindrome(s string) string &#123; var ( subStr = \"\" lenS int index int subK int maxLeftIndex int maxRightIndex int ) lenS = 2*len(s) - 1 for index &lt; lenS &#123; subK = 0 for &#123; leftIndex, rightIndex := index-subK, index+subK if leftIndex%2 != 0 &#123; leftIndex-- &#125; if rightIndex%2 != 0 &#123; rightIndex++ &#125; if leftIndex &lt; 0 || rightIndex &gt;= lenS &#123; break &#125; if s[leftIndex/2] == s[rightIndex/2] &#123; if maxRightIndex-maxLeftIndex &lt; rightIndex/2-leftIndex/2 &#123; maxLeftIndex, maxRightIndex = leftIndex/2, rightIndex/2 &#125; subK++ &#125; else &#123; break &#125; &#125; index++ &#125; if maxRightIndex &lt; len(s) &#123; subStr = s[maxLeftIndex:maxRightIndex+1] &#125; return subStr&#125;本地测试1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; s := \"babad\" fmt.Println(longestPalindrome(s)) s = \"cbbd\" fmt.Println(longestPalindrome(s)) s = \"abcd\" fmt.Println(longestPalindrome(s)) s = \"cbbb\" fmt.Println(longestPalindrome(s)) s = \"bbbc\" fmt.Println(longestPalindrome(s)) s = \"ababa\" fmt.Println(longestPalindrome(s)) s = \"bbbb\" fmt.Println(longestPalindrome(s))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-palindromic-substring","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"4. 寻找两个正序数组的中位数","slug":"leetcode-cn/4. 寻找两个正序数组的中位数","date":"2018-03-03T16:00:00.000Z","updated":"2021-11-29T12:47:13.652Z","comments":true,"path":"2018/03/04/leetcode-cn/4. 寻找两个正序数组的中位数/","link":"","permalink":"https://blazehu.github.io/2018/03/04/leetcode-cn/4.%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。示例12345678910nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5","text":"题目描述给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。示例12345678910nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5解法12345678910111213141516171819202122232425262728293031323334353637383940func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; var ( nums []int minNum int index int index1 int index2 int m float64 ) nums1Len, nums2Len := len(nums1), len(nums2) numsTotal := nums1Len + nums2Len for index = 0; index &lt; numsTotal; index++ &#123; if index &gt; numsTotal/2 &#123; break &#125; if index1 &lt; nums1Len &amp;&amp; index2 &lt; nums2Len &#123; if nums1[index1] &lt; nums2[index2] &#123; minNum = nums1[index1] index1++ &#125; else &#123; minNum = nums2[index2] index2++ &#125; &#125; else if index1 &lt; nums1Len &#123; minNum = nums1[index1] index1++ &#125; else if index2 &lt; nums2Len &#123; minNum = nums2[index2] index2++ &#125; else &#123; &#125; nums = append(nums, minNum) &#125; if numsTotal%2 != 0 &#123; m = float64(nums[index-1]) &#125; else &#123; m = float64(nums[index-1]+nums[index-2]) / 2 &#125; return m&#125;本地测试1234567891011121314package mainimport \"fmt\"func main() &#123; a, b := []int&#123;1, 3&#125;, []int&#123;2&#125; fmt.Println(findMedianSortedArrays(a, b)) a, b = []int&#123;1, 2&#125;, []int&#123;3, 4, 5&#125; fmt.Println(findMedianSortedArrays(a, b)) a, b = []int&#123;1, 4&#125;, []int&#123;2, 3&#125; fmt.Println(findMedianSortedArrays(a, b)) a, b = []int&#123;1, 4, 5, 9&#125;, []int&#123;2, 3, 8, 10&#125; fmt.Println(findMedianSortedArrays(a, b))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"3. 无重复字符的最长子串","slug":"leetcode-cn/3. 无重复字符的最长子串","date":"2018-03-02T16:00:00.000Z","updated":"2021-11-29T12:47:13.652Z","comments":true,"path":"2018/03/03/leetcode-cn/3. 无重复字符的最长子串/","link":"","permalink":"https://blazehu.github.io/2018/03/03/leetcode-cn/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例1234567891011121314输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例 2:输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例 3:输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。","text":"题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例1234567891011121314输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例 2:输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例 3:输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。解法12345678910111213141516171819202122232425262728293031func lengthOfLongestSubstring(s string) int &#123; if s == \"\" &#123; return 0 &#125; var ( maxX = 0 maxY = 1 x = 0 y = 1 ) charList := []byte(s) for x &lt;= y &amp;&amp; y &lt; len(charList) &#123; isIn := false for _, i := range charList[x:y] &#123; if i == charList[y] &#123; isIn = true break &#125; &#125; if isIn &#123; x += 1 &#125; else &#123; y += 1 &#125; if y-x &gt; maxY-maxX &#123; maxY, maxX = y, x &#125; &#125; return maxY - maxX&#125;本地测试123456789101112package mainimport \"fmt\"func main() &#123; a := \"abcabcbb\" fmt.Println(lengthOfLongestSubstring(a)) b := \"bbbbb\" fmt.Println(lengthOfLongestSubstring(b)) c := \"pwwkew\" fmt.Println(lengthOfLongestSubstring(c))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"2. 两数相加","slug":"leetcode-cn/2. 两数相加","date":"2018-03-01T16:00:00.000Z","updated":"2021-11-29T12:47:13.649Z","comments":true,"path":"2018/03/02/leetcode-cn/2. 两数相加/","link":"","permalink":"https://blazehu.github.io/2018/03/02/leetcode-cn/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807","text":"题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; h := &amp;ListNode&#123;&#125; for s := h; l1 != nil; l1 = l1.Next &#123; s.Val = l1.Val if l1.Next != nil &#123; s.Next = &amp;ListNode&#123;&#125; &#125; s = s.Next &#125; k := 0 s, e := h, h for l2 != nil &#123; s.Val += l2.Val + k k = 0 if s.Val &gt;= 10 &#123; s.Val -= 10 k = 1 &#125; if s.Next == nil &#123; s.Next = &amp;ListNode&#123;&#125; &#125; e = s s = s.Next l2 = l2.Next &#125; for k != 0 &amp;&amp; s != nil &#123; s.Val += k k = 0 if s.Val &gt;= 10 &#123; s.Val -= 10 k = 1 &#125; s = s.Next e = e.Next &#125; if k != 0 &#123; if s != nil &#123; e.Next.Val += 1 &#125; else &#123; e.Next = &amp;ListNode&#123;Val: 1&#125; &#125; &#125; for s != nil &#123; if s.Val == 0 &amp;&amp; s.Next == nil &#123; e.Next = nil &#125; s = s.Next e = e.Next &#125; return h&#125;本地测试12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"type ListNode struct &#123; Val int Next *ListNode&#125;func print(h *ListNode) &#123; for h != nil &#123; fmt.Print(h.Val) h = h.Next &#125; fmt.Println()&#125;func main() &#123; l1 := ListNode&#123;Val: 2, Next: &amp;ListNode&#123;Val: 4, Next: &amp;ListNode&#123;Val: 3&#125;&#125;&#125; l2 := ListNode&#123;Val: 5, Next: &amp;ListNode&#123;Val: 6, Next: &amp;ListNode&#123;Val: 4&#125;&#125;&#125; print(addTwoNumbers(&amp;l1, &amp;l2)) l1 = ListNode&#123;Val: 0&#125; l2 = ListNode&#123;Val: 5, Next: &amp;ListNode&#123;Val: 6, Next: &amp;ListNode&#123;Val: 4&#125;&#125;&#125; print(addTwoNumbers(&amp;l1, &amp;l2)) l1 = ListNode&#123;Val: 9, Next: &amp;ListNode&#123;Val: 9&#125;&#125; l2 = ListNode&#123;Val: 9&#125; print(addTwoNumbers(&amp;l1, &amp;l2)) l1 = ListNode&#123;Val: 8, Next: &amp;ListNode&#123;Val: 9, Next: &amp;ListNode&#123;Val: 9&#125;&#125;&#125; l2 = ListNode&#123;Val: 2&#125; print(addTwoNumbers(&amp;l1, &amp;l2))&#125;来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"1. 两数之和","slug":"leetcode-cn/1. 两数之和","date":"2018-02-28T16:00:00.000Z","updated":"2021-11-29T12:47:13.647Z","comments":true,"path":"2018/03/01/leetcode-cn/1. 两数之和/","link":"","permalink":"https://blazehu.github.io/2018/03/01/leetcode-cn/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例123给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]","text":"题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例123给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]解法暴力解法123456789101112func twoSum(nums []int, target int) []int &#123; var ret []int for index1, num1 := range nums &#123; for index2, num2 := range nums &#123; if index1 != index2 &amp;&amp; num1+num2 == target &#123; ret = []int&#123;index2, index1&#125; return ret &#125; &#125; &#125; return ret&#125;时间复杂度： O(n^2)空间复杂度： O(1)一遍哈希表1234567891011121314151617181920212223func twoSum(nums []int, target int) []int &#123; var ( ret []int numsMap map[int][]int ) numsMap = make(map[int][]int, len(nums)) for index, num := range nums &#123; if _, ok := numsMap[num]; ok &#123; numsMap[num] = append(numsMap[num], index) &#125; else &#123; numsMap[num] = []int&#123;index&#125; &#125; if indexList, ok := numsMap[target-num]; ok &#123; for _, i := range indexList &#123; if i != index &#123; ret = []int&#123;i, index&#125; return ret &#125; &#125; &#125; &#125; return ret&#125;时间复杂度： O(n)空间复杂度： O(n)来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum","categories":[{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"}]},{"title":"nginx location 匹配规则","slug":"nginx/nginx location 正则写法","date":"2017-08-11T16:00:00.000Z","updated":"2021-11-29T12:47:13.655Z","comments":true,"path":"2017/08/12/nginx/nginx location 正则写法/","link":"","permalink":"https://blazehu.github.io/2017/08/12/nginx/nginx%20location%20%E6%AD%A3%E5%88%99%E5%86%99%E6%B3%95/","excerpt":"匹配命令123456~ 正则匹配，区分大小写~* 正则匹配，不区分大小写= 普通字符精确匹配，如果找到，停止搜索^~ 普通字符匹配（如果该选项匹配，只匹配该选项，一般用来匹配目录）/ 通用匹配，如果没有其它匹配，任何请求都会匹配到@ 定义命名的 location，使用在内部定向时，例如：error_page、try_files匹配优先级（与在配置文件中的顺序无关）12341. 精确匹配 ”=“ 会第一个被处理。如果发现精确匹配，停止搜索。2. 匹配最长的规则，如果这个规则带有 ^~ 修饰符，停止搜索。3. 存储 #2 的最长匹配规则，然后按在配置文件中的定义顺序匹配正则表达，若匹配到正则表达式，停止搜索。4. 若没有匹配到正则表达式，使用存储的 #2 的最长匹配。","text":"匹配命令123456~ 正则匹配，区分大小写~* 正则匹配，不区分大小写= 普通字符精确匹配，如果找到，停止搜索^~ 普通字符匹配（如果该选项匹配，只匹配该选项，一般用来匹配目录）/ 通用匹配，如果没有其它匹配，任何请求都会匹配到@ 定义命名的 location，使用在内部定向时，例如：error_page、try_files匹配优先级（与在配置文件中的顺序无关）12341. 精确匹配 ”=“ 会第一个被处理。如果发现精确匹配，停止搜索。2. 匹配最长的规则，如果这个规则带有 ^~ 修饰符，停止搜索。3. 存储 #2 的最长匹配规则，然后按在配置文件中的定义顺序匹配正则表达，若匹配到正则表达式，停止搜索。4. 若没有匹配到正则表达式，使用存储的 #2 的最长匹配。官方文档Directives with the = prefix that match the query exactly. If found, searching stops.All remaining directives with conventional strings, longest match first. If this match used the ^~ prefix, searching stops.Regular expressions, in order of definition in the configuration file.If #3 yielded a match, that result is used. Else the match from #2 is used.= 前缀的指令严格匹配这个查询。如果找到，停止搜索。所有剩下的常规字符串，最长的匹配。如果这个匹配使用 ^〜 前缀，搜索停止。正则表达式，在配置文件中定义的顺序。如果第三条规则产生匹配的话，结果被使用。否则，使用第二条规则的结果。例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# @location 例子error_page 404 = @fetch;location @fetch &#123; [ configuration X ]&#125;location = / &#123; # 精确匹配 / [ configuration A ] &#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ] &#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ] &#125;location ~ /documents/Abc &#123; [ configuration CC ] &#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索，采用这一条 [ configuration D ] &#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ] &#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ] &#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F 与 G 的放置顺序是没有关系的 [ configuration G ] &#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效 # 先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ] &#125;location ~* /js/.*/\\.js常用例子静态文件处理静态文件请求，这是 nginx 作为 http 服务器的强项，有两种配置模式，目录匹配或后缀匹配，任选其一或搭配使用123456789# 目录匹配location ^~ /static/ &#123; root /webroot/static/;&#125;# 后缀匹配location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123; alias /webroot/res/;&#125;参考资料https://www.nginx.cn/115.html","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://blazehu.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blazehu.github.io/tags/Nginx/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blazehu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"nginx 负载均衡","slug":"nginx/nginx 负载均衡","date":"2017-08-10T16:00:00.000Z","updated":"2021-11-29T12:47:13.655Z","comments":true,"path":"2017/08/11/nginx/nginx 负载均衡/","link":"","permalink":"https://blazehu.github.io/2017/08/11/nginx/nginx%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"简介nginx 通过 upstream 实现负载均衡， upstream 目前支持5种方式。轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。1234upstream backserver &#123; server 192.168.0.14; server 192.168.0.15; &#125;指定权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。1234upstream backserver &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; &#125;","text":"简介nginx 通过 upstream 实现负载均衡， upstream 目前支持5种方式。轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。1234upstream backserver &#123; server 192.168.0.14; server 192.168.0.15; &#125;指定权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。1234upstream backserver &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; &#125;IP 绑定 ip_hash每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。12345upstream backserver &#123; ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; &#125;fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。12345upstream backserver &#123; server server1; server server2; fair; &#125;url_hash（第三方）按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。123456upstream backserver &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; &#125;其他upstream 还可以为每个设备设置状态值，这些状态值的含义分别如下：状态值含义down表示单前的 server 暂时不参与负载weight默认为1， weight 越大负载的权重就越大max_fails允许请求失败的次数默认为1，当超过最大次数时返回 proxy_next_upstream 模块定义的错误fail_timeoutmax_fails 次失败后，暂停的时间backup其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器，所以这台机器压力会最轻例如：12345678upstream bakend&#123; # 定义负载均衡设备的 Ip 及设备状态 ip_hash; server 10.0.0.11:9090 down; server 10.0.0.11:8080 weight=2; server 10.0.0.11:6060; server 10.0.0.11:7070 backup; &#125;超时时间设置django + uwsgi + nginx 部署的 web 站点运行时报504 ， 可能是超时时间设置有问题。nginx 和 uwsgi 整合时有三个参数可以用于设置超时时间，在 nginx 配置文件 http -&gt; server -&gt; location 中设置。123uwsgi_connect_timeout ：默认60秒，与 uwsgi-server 连接的超时时间，该值不能超过75秒.若在超时时间内未能成功连接则断开连接尝试。 uwsgi_read_timeout ：默认60秒，nginx等待 uwsgi 进程发送响应数据的超时时间。若有需要长时间运行才能产生输出结果的uwsgi进程则需将此参数调高。若在错误日志文件中看到 upstream timed out 需将此参数调高。若超过超时时间还未收到响应则 nginx 关闭连接。 uwsgi_send_timeout ：默认60秒，nginx 向 uwsgi 进程发送请求的超时时间。超时时间由两次写操作的时间间隔算，而非整个请求。若超过超时时间仍没写入动作则 nginx 关闭连接。注：这里还需要排除其他原因，根据具体环境而定，如使用 aws 的 LB 就会有空闲时间的限制响应状态码12345504 网关超时 Gateway timeout（例如nginx正在处理但是程序执行过程太长，nginx配置的等待时间较短，于是时间到了超时返回504，排查超时时间等因素）502 网关错误 Bad Gateway 服务不给nginx任何响应 （例如uwsgi最多只能处理300个请求，但nginx转发了600个请求，uwsgi不给nginx任何响应，502）500 服务器内部错误，可能是服务内部有问题（例如代码内部有问题）404 找不到该网页（可能web 路径有问题 ）200 正常状态","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://blazehu.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blazehu.github.io/tags/Nginx/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://blazehu.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"CSRF 简介","slug":"common/CSRF 简介","date":"2017-06-03T16:00:00.000Z","updated":"2021-11-29T12:47:13.645Z","comments":true,"path":"2017/06/04/common/CSRF 简介/","link":"","permalink":"https://blazehu.github.io/2017/06/04/common/CSRF%20%E7%AE%80%E4%BB%8B/","excerpt":"CSRF 是什么？CSRF（Cross-site Request Forgery）跨站请求伪造，缩写为：CSRF/XSRF。 也被称为：one click attack/session riding。","text":"CSRF 是什么？CSRF（Cross-site Request Forgery）跨站请求伪造，缩写为：CSRF/XSRF。 也被称为：one click attack/session riding。攻击原理利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。例子1234背景：有网站 a, b1. a网站通过标签 &lt;img src=\"http://b?xx=xx&amp;x=x\"&gt; 构造了一个 get 请求,这个请求为 b 的地址并且携带了一些请求参数2. 浏览器发起请求的时候看到的域名是 b 的域名就会携带 b 网站下的 cookie3. 如果 cookie 里携带了一些认证信息，b 网站就会认为这是一个正常的请求从而导致了一些安全问题该攻击可以实施的点在于：1231. 浏览器在发起 get 请求的时候会默认携带该请求域名下的 cookie2. 一般而言浏览器有同源策略的限制，但是通过标签 &lt;img src=\"\"&gt; 或者 script 所构造的请求不会有这个限制3. b 网站允许 get 请求去执行一些操作防御措施检查 Referer添加校验 Token","categories":[],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://blazehu.github.io/tags/CSRF/"}]},{"title":"siege 压测工具","slug":"common/siege 压测工具","date":"2017-05-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.646Z","comments":true,"path":"2017/05/21/common/siege 压测工具/","link":"","permalink":"https://blazehu.github.io/2017/05/21/common/siege%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/","excerpt":"简介siege 是一款高性能的 http 压力测试工具。siege 支持身份验证、 cookies、 http、 https 和 ftp 协议。应用举例123456789101112131415161. 对指定站点进行压测siege -c 300 -t 5s URL2.文件中包含的若干URL进行批量测试siege -c 300 -t 5s -f URL_File_Name3. 支持多个Header参数siege -c 300 -t 5s -H \"Authorization: XXXX\" -H \"SX: 1212\" URL4. 支持application/json方式请求siege -c 300 -t 5s 'URL POST &lt; data.json' siege -c 300 -t 5s 'URL PUT &lt; data.json'","text":"简介siege 是一款高性能的 http 压力测试工具。siege 支持身份验证、 cookies、 http、 https 和 ftp 协议。应用举例123456789101112131415161. 对指定站点进行压测siege -c 300 -t 5s URL2.文件中包含的若干URL进行批量测试siege -c 300 -t 5s -f URL_File_Name3. 支持多个Header参数siege -c 300 -t 5s -H \"Authorization: XXXX\" -H \"SX: 1212\" URL4. 支持application/json方式请求siege -c 300 -t 5s 'URL POST &lt; data.json' siege -c 300 -t 5s 'URL PUT &lt; data.json'常用参数参数描述-c并发数-t压力测试时间，可以在时间后加单位-r重复次数。与-t含义相同，设一个即可-f包含URL的文本名字-bBENCHMARK模式，请求之间无需延迟-p打印整个页面的内容-H给请求添加头，支持多个-A给请求设置User-Agent-T给请求设置Content-Type性能参数性能参数描述Transactions总共测试次数Availability成功次数百分比Elapsed time总共耗时多少秒Data transferred总共数据传输Response time等到响应耗时Transaction rate平均每秒处理请求数Throughput吞吐率Concurrency最高并发Successful transactions成功的请求数Failed transactions失败的请求数参考资料https://www.joedog.org/siege-manual/https://www.jianshu.com/p/74c465ff136f/","categories":[{"name":"工具","slug":"工具","permalink":"https://blazehu.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Siege","slug":"Siege","permalink":"https://blazehu.github.io/tags/Siege/"}]},{"title":"Sanic 初识","slug":"python/Sanic初识","date":"2016-12-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.662Z","comments":true,"path":"2016/12/21/python/Sanic初识/","link":"","permalink":"https://blazehu.github.io/2016/12/21/python/Sanic%E5%88%9D%E8%AF%86/","excerpt":"OverviewSanic is a Python 3.7+ web server and web framework that’s written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy.","text":"OverviewSanic is a Python 3.7+ web server and web framework that’s written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy.Example下面是一个简单的例子，使用到如下库：12345sanic (sanic is a flask-like python3.5+ web server)peewee (simple and small ORM)PyMySQL (mysql database driver)marshmallow (serialize and deserialize models)AoikLiveReload (automatic reload app in development)目录结构启动服务123(sanic) [blazehu@MacBook ~]$ python3 app.py2018-12-21 10:53:50 - (sanic)[INFO]: Goin' Fast @ http://0.0.0.0:80002018-12-21 10:53:50 - (sanic)[INFO]: Starting worker [44832]访问测试create a new employeelist employeeslogs12345678(sanic) [blazehu@MacBook ~]$ python3 app.py2018-12-21 10:53:50 - (sanic)[INFO]: Goin' Fast @ http://0.0.0.0:80002018-12-21 10:53:50 - (sanic)[INFO]: Starting worker [44832]2018-12-21 10:59:54 - (network)[INFO][127.0.0.1:55817]: GET http://127.0.0.1:8000/employee/ 200 2672018-12-21 11:00:03 - (network)[INFO][127.0.0.1:55865]: GET http://127.0.0.1:8000/employee/ 200 2672018-12-21 11:01:05 - (network)[INFO][127.0.0.1:56135]: GET http://127.0.0.1:8000/employee/ 200 382018-12-21 11:01:44 - (network)[INFO][127.0.0.1:56325]: POST http://127.0.0.1:8000/employee/ 200 282018-12-21 11:02:38 - (network)[INFO][127.0.0.1:56562]: GET http://127.0.0.1:8000/employee/ 200 95具体实现models.py1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-from peewee import *from playhouse.pool import MySQLDatabasefrom playhouse.shortcuts import RetryOperationalErrorimport configclass RetryMysqlDatabase(RetryOperationalError, MySQLDatabase): def __init__(self, database, **kwargs): super(MySQLDatabase, self).__init__(database, **kwargs) def sequence_exists(self, seq): passdb = RetryMysqlDatabase( database=config.DB_NAME, host=config.DB_HOST, user=config.DB_USER, passwd=config.DB_PASSWORD, port=config.DB_PORT,)class BaseModel(Model): \"\"\"A base model that will use our MySQL database\"\"\" is_deleted = BooleanField(u'是否删除', default=False) class Meta: database = dbclass Employee(BaseModel): # base info number = CharField(verbose_name=u'编号', unique=True) name = CharField(verbose_name=u'姓名', null=True) email = CharField(verbose_name=u'邮箱', null=True)serialize.py1234567891011121314# -*- coding: utf-8 -*-from marshmallow import Schema, fields, post_loadimport modelsclass EmployeeSchema(Schema): # 基本信息 number = fields.String() name = fields.String() email = fields.Email() @post_load def make_employee(self, data): return models.Employee(**data)views.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*-from sanic.views import HTTPMethodViewfrom sanic import Blueprint, responsefrom models import Employeeimport serializeemployee_bp = Blueprint(\"employee_bp\")class EmployeeView(HTTPMethodView): async def get(self, request): employees = Employee.select().where(Employee.is_deleted == 0) schema = serialize.EmployeeSchema() data = schema.dump(employees, many=True).data return response.json(&#123;\"code\": 200, \"msg\": \"success\", \"data\": data&#125;) async def post(self, request): data = request[\"POST\"] employee_schema = serialize.EmployeeSchema() _, error = employee_schema.load(data) if error: msg = \"\" for error_item in error: error_detail = error.get(error_item) if isinstance(error_detail, list): error_detail = ','.join(error_detail) else: error_detail = str(error_detail) msg += \"&#123;0&#125;: &#123;1&#125;\".format(error_item, error_detail) return response.json(&#123;\"code\": 500, \"msg\": msg&#125;) else: number = data.get(\"number\") try: Employee.get(Employee.number == number) return response.json(&#123;\"code\": 500, \"msg\": \"the number is uniq\"&#125;) except Employee.DoesNotExist: employee = Employee() for key in data: value = data.get(key) if hasattr(employee, key): setattr(employee, key, value) employee.save() return response.json(&#123;\"code\": 201, \"msg\": \"success\"&#125;)employee_bp.add_route(EmployeeView.as_view(), \"/\")app.py1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-from sanic import Sanicfrom sanic_cors import CORSfrom aoiklivereload import LiveReloaderfrom views import employee_bpfrom models import db, Employeeimport configapp = Sanic(__name__)app.blueprint(employee_bp, url_prefix='/employee')CORS(app, automatic_options=True)@app.middleware('request')async def transform_data_request(request): try: request['POST'] = request.json if request.json else &#123;&#125; request['GET'] = request.args if request.args else &#123;&#125; except Exception as e: print(repr(e))@app.middleware('response')async def close_db(request, response): if not db.is_closed(): db.close()# application configapp.config.from_object(config)# init the databasedb.create_tables([Employee, ], safe=True)if __name__ == '__main__': # reload the app reloader = LiveReloader() reloader.start_watcher_thread() # run server debug app.run(host='0.0.0.0', port=8000, debug=True)config.py123456789101112# -*- coding: utf-8 -*-# 关闭长连接KEEP_ALIVE = False# 关闭启动logoLOGO = None# Mysql Database for devDB_HOST = '127.0.0.1'DB_PORT = 3306DB_NAME = 'sanic'DB_USER = 'root'DB_PASSWORD = '123456'requirements.txt12345678# python 3.7.2PyMySQL==0.7.11AoikLiveReload==0.1.0peewee==2.8.5marshmallow==2.13.6sanic-crud==0.2.4Sanic-Cors==0.6.0.0sanic==0.6.0start.sh12345# dev, demo debug python3 app.py# deploygunicorn app:app --bind 0.0.0.0:8000 --worker-class sanic.worker.GunicornWorker","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"},{"name":"Sanic","slug":"Sanic","permalink":"https://blazehu.github.io/tags/Sanic/"}]},{"title":"Python 高阶函数","slug":"python/base/python 高阶函数","date":"2016-05-20T16:00:00.000Z","updated":"2021-11-29T12:47:13.667Z","comments":true,"path":"2016/05/21/python/base/python 高阶函数/","link":"","permalink":"https://blazehu.github.io/2016/05/21/python/base/python%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","excerpt":"简介高阶函数是一种将函数作为参数，或者把函数作为结果返回的函数。map 、 reduce 、 filter 、 sorted 就是高阶函数的典型例子。","text":"简介高阶函数是一种将函数作为参数，或者把函数作为结果返回的函数。map 、 reduce 、 filter 、 sorted 就是高阶函数的典型例子。map 函数map 函数的作用是将一个列表映射到另一个列表。1234567891011121314151617181920212223242526272829# map(function, sequence)def function1(x): return x*2def function2(x, y): return x * ydef function3(t): return t[0] + t[1] + t[2]def function4(x): return x, x**2s1 = [1, 2, 3, 4]s2 = [2, 3, 4, 5]s3 = [3, 4, 5, 6]print(map(function1, s1))# [2, 4, 6, 8]print(map(function2, s1, s2))# [2, 6, 12, 20]print(map(function3, zip(s1, s2, s3)))# [6, 9, 12, 15]print(map(function4, s1))# [(1, 1), (2, 4), (3, 9), (4, 16)]上面的四个函数，根据参数的个数，参数的类型，返回值的个数，返回值的类型来测试map函数。reduce 函数reduce 的作用是将一个列表归纳为一个输出。有三个参数分别是 fucntion 、 sequence 、 startValue 。function 必须是带有两个参数的函数。startValue 可以不设置，初始化值，如果不设置那么初始化运算使用 sequence 的 s[0] 和 s[1] 进行运算，设置则是startValue 和 s[0] 运算，然后依次计算 fucntion(s[1], s[2]) ……1234567891011121314151617181920212223# reduce(function, sequence, startValue)def function1(x): return x*2def function2(x, y): return x * ydef function3(t): return t[0] + t[1] + t[2]def function4(x): return x, x**2s1 = [1, 2, 3, 4]s2 = [2, 3, 4, 5]s3 = [3, 4, 5, 6]print(reduce(function2, s1))# 24print(reduce(function2, s1, 2))# 48filter 函数filter 函数是过滤掉列表中的一些元素。这里要注意的是 filter 通过函数的返回的 bool 值来判断是否过滤，最好设置为 true or false。1234567def function5(x): return x % 2s1 = [1, 2, 3, 4]print(filter(function5, s1))# [1, 3]sorted 函数接收一个 key 函数来实现自定义的排序。普通排序1234# sorted(iterable, key=None, reverse=False) &gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]绝对值排序12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]参考资料https://www.liaoxuefeng.com/wiki/1016959663602400/1017328655674400","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://blazehu.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Python 匿名函数","slug":"python/base/python 匿名函数","date":"2016-05-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.666Z","comments":true,"path":"2016/05/20/python/base/python 匿名函数/","link":"","permalink":"https://blazehu.github.io/2016/05/20/python/base/python%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","excerpt":"前言有些时候我们只是为了定义一些简单的操作，显式地定义函数略显麻烦，这时候我们可以直接使用匿名函数。","text":"前言有些时候我们只是为了定义一些简单的操作，显式地定义函数略显麻烦，这时候我们可以直接使用匿名函数。lambda 表达式lambda 表达式又称为匿名函数，通常和其他高阶函数配合使用。匿名函数不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。123456789101112131415161718192021222324252627# lambda &lt;参数&gt;: 函数体def function1(x): return x*2def function2(x, y): return x * ydef function3(x): return x**2def function4(x): return x % 2f1 = lambda x: x*2f2 = lambda x, y: x * yf3 = lambda x: x**2f4 = lambda x: x%2print(f1(2))# 4print(f2(2, 3))# 6print(f3(3))# 9print(f4(4), f4(7))# 0, 1参考资料https://www.liaoxuefeng.com/wiki/1016959663602400/1017451447842528","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://blazehu.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Python 内置函数","slug":"python/base/python 内置函数","date":"2016-05-17T16:00:00.000Z","updated":"2021-11-29T12:47:13.665Z","comments":true,"path":"2016/05/18/python/base/python 内置函数/","link":"","permalink":"https://blazehu.github.io/2016/05/18/python/base/python%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","excerpt":"简介Python 解释器内置了很多函数和类型，以便于我们使用。","text":"简介Python 解释器内置了很多函数和类型，以便于我们使用。内置函数abs()delattr()hash()memoryview()set()all()dict()help()min()setattr()any()dir()hex()next()slice()ascii()divmod()id()object()sorted()bin()enumerate()input()oct()staticmethod()bool()eval()int()open()str()breakpoint()exec()isinstance()ord()sum()bytearray()filter()issubclass()pow()super()bytes()float()iter()print()tuple()callable()format()len()property()type()chr()frozenset()list()range()vars()classmethod()getattr()locals()repr()zip()compile()globals()map()reversed()__import__()complex()hasattr()max()round()常用函数介绍数学计算abs()返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。pow()pow() 方法返回 xy（x的y次方） 的值。min()min() 方法返回给定参数的最小值，参数可以为序列。max()max() 方法返回给定参数的最大值，参数可以为序列。sum()sum() 方法对系列进行求和计算。对象操作getattr()getattr() 函数用于返回一个对象属性值。hasattr()hasattr() 函数用于判断对象是否包含对应的属性。setattr()setattr() 函数对应函数 getattr()，用于设置属性值，该属性不一定是存在的。delattr()delattr 函数用于删除属性。delattr(x, ‘foobar’) 相等于 del x.foobar。字符操作chr()chr() 用一个整数作参数，返回一个对应的字符。ord()ord() 函数是 chr() 函数（对于 8 位的 ASCII 字符串）的配对函数，它以一个字符串（Unicode 字符）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。可迭代对象sorted()sorted() 函数对所有可迭代的对象进行排序操作。enumerate()enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。zip()zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。通用type()type() 函数如果你只有第一个参数则返回对象的类型，三个参数返回新的类型对象。isinstance()isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。id()id() 函数返回对象的唯一标识符，标识符是一个整数。eval()eval() 函数用来执行一个字符串表达式，并返回表达式的值。参考资料https://docs.python.org/zh-cn/3.7/library/functions.htmlhttps://www.runoob.com/python3/python3-built-in-functions.html","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"Python 正则表达式","slug":"python/base/python 正则表达式","date":"2016-05-11T16:00:00.000Z","updated":"2021-11-29T12:47:13.667Z","comments":true,"path":"2016/05/12/python/base/python 正则表达式/","link":"","permalink":"https://blazehu.github.io/2016/05/12/python/base/python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"简介正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它 “匹配” 了，否则，该字符串就是不合法的。re 模块Python 自1.5版本起增加了 re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。","text":"简介正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它 “匹配” 了，否则，该字符串就是不合法的。re 模块Python 自1.5版本起增加了 re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。模式描述.可以匹配任意单个字符除了 \\n*匹配前一个字符0次或者n次?匹配前一个字符0次或者1次^表示匹配的字符必须在最前面$表示匹配的字符必须在最后面+表示匹配前一个字符1次或者n次\\d+匹配数字\\d匹配单个数字.*贪心算法，提取最多的内容.*?非贪心算法，提取内容x|y表示匹配 x or y[abc]表示匹配 abc 当中的任意一个字符，可以使用连接符- ：例如 [a-z][^abc]表示匹配除了列出字符以外的所有字符，是[abc]的补集{n}表示匹配前面n个字符{n,}表示匹配至少n个前面的字符{n, m}表示匹配至少n个最多m个前面的字符使用括号的话，括号内的是返回的结果。re 函数re.S : 正则匹配的时候包括 \\nfindall() : 返回匹配的所有结果列表search() : 返回匹配到的第一个结果sub() ： 替换匹配的结果compile() ： 把正则表达式编译为正则表达式对象例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#encoding=utf-8import resecret_code = 'hadkfalifexxIxxasdasdaxxsdasdxxasadasdaxxsdaxxs'# . 的使用举例a = 'xz123'b = re.findall('x.', a)# 匹配前一个字符0次或无限次# * 的使用举例a = 'xyxy123'b = re.findall('x*', a)# 匹配前一个字符0次或者1次# ? 的使用举例a = 'xyx123'b = re.findall('x?', a)# 组合方式# .* 贪心算法，提取最多的内容b = re.findall('xx.*xx', secret_code)# .*? 非贪心算法，提取内容b = re.findall('xx.*?xx', secret_code)# 使用括号和不适用括号的区别b = re.findall('xx(.*)xx', secret_code)# .*? 非贪心算法，提取内容b = re.findall('xx(.*?)xx', secret_code)# re.S 的作用是使 find 包括 \\nsecret_code = '''hadkfalifexxIxxasdasdaxxsdasdxxasadasdaxxsdaxxs'''b = re.findall('xx(.*?)xx', secret_code)b = re.findall('xx(.*?)xx', secret_code, re.S)# 对比 findall 和 search 的区别b = re.findall('xx(.*?)xx', secret_code)b = re.search('xx(.*?)xx(.*?)xx', secret_code).group(2)# sub 的使用举例#替换b = re.sub('xx(.*?)xx(.*?)xx', \"123%d123\", secret_code)b = re.sub('xx(.*?)xx(.*?)xx', \"123%d123\" % 789, secret_code)# compile 的用法pattern = 'xx(.*?)xx'new_pattern = re.compile(pattern, re.S)b = re.findall(new_pattern, secret_code)# ['I', 's\\ndasd', 'sda']# 匹配数字( \\d+ 匹配数字连续的依旧连续, \\d 匹配数字分成一个一个数字)a = 'asdasd123123vvvdsdfsd76989aowoie'b = re.findall('(\\d+)', a)# ['123123', '76989']参考资料https://www.runoob.com/python/python-reg-expressions.htmlhttps://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blazehu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"Python 列表推导式","slug":"python/base/python 列表推导式","date":"2016-05-09T16:00:00.000Z","updated":"2021-11-29T12:47:13.665Z","comments":true,"path":"2016/05/10/python/base/python 列表推导式/","link":"","permalink":"https://blazehu.github.io/2016/05/10/python/base/python%20%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F/","excerpt":"简介列表推导式即 List Comprehensions ，简单却强大。列表推导式的格式12[x for item in sequence &lt;if (conditions)&gt;] # 这里的x是对 item进行的操作[表达式 for 变量 in 列表 if 条件] # 列表推导式会比for循环快很多","text":"简介列表推导式即 List Comprehensions ，简单却强大。列表推导式的格式12[x for item in sequence &lt;if (conditions)&gt;] # 这里的x是对 item进行的操作[表达式 for 变量 in 列表 if 条件] # 列表推导式会比for循环快很多例子123456789101112131415161718192021In [1]: [x**2 for x in range(5) if x &lt; 2]Out[1]: [0, 1]# 省略条件语句In [2]: [x**2 for x in range(5)]Out[2]: [0, 1, 4, 9, 16]# 自定义表达式和条件语句In [3]: [(x, x**2) for x in (1, 2, 3, 4, 5, 6) if x % 3]Out[3]: [(1, 1), (2, 4), (4, 16), (5, 25)]# 多个 for 和多个 if In [4]: [(x, y) for x in range(5) if not x % 3 for y in range(5) if not y % 2]Out[4]: [(0, 0), (0, 2), (0, 4), (3, 0), (3, 2), (3, 4)]# 表达式可以是函数In [7]: [sum([x, y]) for x in range(5) for y in range(2)]Out[7]: [0, 1, 1, 2, 2, 3, 3, 4, 4, 5]In [8]: [sum([x, y]) for (x, y) in zip([1, 2, 3, 4], [2, 3, 4, 5])]Out[8]: [3, 5, 7, 9]参考资料https://www.liaoxuefeng.com/wiki/1016959663602400/1017317609699776","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"Python 动态类型","slug":"python/base/python 动态类型","date":"2016-05-07T16:00:00.000Z","updated":"2021-11-29T12:47:13.666Z","comments":true,"path":"2016/05/08/python/base/python 动态类型/","link":"","permalink":"https://blazehu.github.io/2016/05/08/python/base/python%20%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B/","excerpt":"简介Python 的数据类型分为 mutable 和 immutable ， mutable 和 immutable 字面意思理解就是说数据可变和数据不可变。mutable: list、dictinmutable: int、 string、 float、 tuple…","text":"简介Python 的数据类型分为 mutable 和 immutable ， mutable 和 immutable 字面意思理解就是说数据可变和数据不可变。mutable: list、dictinmutable: int、 string、 float、 tuple…动态类型由于 Python 的变量 (variable) 不需要声明，而在赋值的时候，变量可以重新赋值为任意值，这就涉及到 Python 的一个重要的核心概念： 动态类型 (dynamic typing) 。一切皆对象在这里重复强调一下在 Python 中一切皆对象，Python 是纯血统的面向对象的编程语言，与 java 不同。我们知道 Java 中有装箱和拆箱，基本数据类型 int 在持久化的过程中是需要封装为 Integer 的。但是在 Python 中，一切皆对象。什么都是对象，包括你的代码，对象是存储在内存中的实体，我们在程序中使用的都是对象名，只是指向这个对象的一个引用 (reference)。引用引用和对象分离，是动态类型的核心，引用可以随时的指向一个新的对象。 这不同于 C++ 中的指针和引用的概念，在 C++ 中指针在逻辑上是独立存在的，但是引用是和对象绑定在一起的。例子12a = 'blazehu'a = 2第一行：在内存中建立了对象 ‘blazehu’(字符串类型)，通过赋值让引用 a 指向它。第二行：2是在内存中存在的整数对象，将引用 a 指向2，于是 ‘blazehu’ 就没有引用指向它， Python 会自动的将这种没有引用指向的垃圾销毁掉，释放相应的内存空间。immutable（不可变数据类型）12345678910&gt;&gt;&gt; def func(x):... x = 1... print(x)...&gt;&gt;&gt; x = 2&gt;&gt;&gt; func(x)1&gt;&gt;&gt; print(x)2&gt;&gt;&gt;这样类似于 C/C++ 中的值传递，即传递的引用不能改变自身，只是改变了引用的指向。mutable（可变数据类型）123456789&gt;&gt;&gt; def func(x):... x[0] = 4... print(x)...&gt;&gt;&gt; x = [1]&gt;&gt;&gt; func(x)[4]&gt;&gt;&gt; print(x)[4]这就类似于 C/C++ 中的指针传递，即传递的引用可以引用自身的元素改变自身，改变了引用的值。 但是元组 (tuple) ，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是 immutable object 。Tips对于较小的整数和短字符 Python 会缓存这些对象，而不是频繁的创建和销毁。256 is an existing object but 257 isn’t. When you start up python the numbers from -5 to 256 will be allocated. These numbers are used a lot, so it makes sense just to have them ready.12345678910111213141516&gt;&gt;&gt; id(256)10922528&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; id(a)10922528&gt;&gt;&gt; id(b)10922528&gt;&gt;&gt; id(257)140084850247312&gt;&gt;&gt; x = 257&gt;&gt;&gt; y = 257&gt;&gt;&gt; id(x)140084850247440&gt;&gt;&gt; id(y)140084850247344总结对于 inmutable object 我们在函数参数传递是值传递对于 mutable object 我们在函数参数传递是指针传递参考资料https://github.com/satwikkansal/wtfpythonhttps://www.cnblogs.com/vamei/archive/2012/07/10/2582795.html","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"Python 包裹传递和解包裹","slug":"python/base/python 包裹传递和解包裹","date":"2016-05-06T16:00:00.000Z","updated":"2021-11-29T12:47:13.666Z","comments":true,"path":"2016/05/07/python/base/python 包裹传递和解包裹/","link":"","permalink":"https://blazehu.github.io/2016/05/07/python/base/python%20%E5%8C%85%E8%A3%B9%E4%BC%A0%E9%80%92%E5%92%8C%E8%A7%A3%E5%8C%85%E8%A3%B9/","excerpt":"包裹传递在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。 这时候，包裹 (packing) 位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。","text":"包裹传递在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。 这时候，包裹 (packing) 位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。例子一12345678910&gt;&gt;&gt; def func(*name):... print(type(name))... print(name)...&gt;&gt;&gt; func(1, 2, 3)&lt;class 'tuple'&gt;(1, 2, 3)&gt;&gt;&gt; func(1, 2, 3, 5, 6, 9)&lt;class 'tuple'&gt;(1, 2, 3, 5, 6, 9)两次调用，尽管参数个数不同，都基于同一个 func 定义。在 func 的参数表中，所有的参数被 name 收集，根据位置合并成一个元组 (tuple) ，这就是包裹位置传递。name 是包裹位置传递所用的元组名，在定义 func 时，在 name 前加 * 号。例子二12345678910&gt;&gt;&gt; def func(**x):... print(type(x))... print(x)...&gt;&gt;&gt; func(a=1, b=2)&lt;class 'dict'&gt;&#123;'a': 1, 'b': 2&#125;&gt;&gt;&gt; func(a=1, b=2, c=3)&lt;class 'dict'&gt;&#123;'a': 1, 'b': 2, 'c': 3&#125;与上面一个例子类似， dict 是一个字典，收集所有的关键字，传递给函数 func 。参数 dict 是包裹关键字传递所用的字典，在 dict 前加 **。解包裹* 和 ** ，也可以在调用的时候使用，即解包裹 (unpacking) ，下面为例：123456789&gt;&gt;&gt; def func(a, b ,c):... print(a, b, c)...&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; func(*args)1 2 3&gt;&gt;&gt; kwargs = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; func(**kwargs)1 2 3总结包裹传递在定义函数时，元组前加 * 、字典前加 ** 。包裹和解包裹并不是相反操作，是两个相对独立的过程。","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"Python 执行系统命令","slug":"python/base/python 执行系统命令","date":"2016-05-01T16:00:00.000Z","updated":"2021-11-29T12:47:13.666Z","comments":true,"path":"2016/05/02/python/base/python 执行系统命令/","link":"","permalink":"https://blazehu.github.io/2016/05/02/python/base/python%20%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/","excerpt":"简介Python 执行系统命令有很多种方法，下面给出了常见的四种方式。","text":"简介Python 执行系统命令有很多种方法，下面给出了常见的四种方式。os.systemos.system 直接调用标准 C 的 system() 函数，仅仅在一个子终端运行系统命令，而不能获取命令执行后的返回信息，返回脚本的退出状态码。用于测试的 shell 脚本 test.sh12echo \"Hello World!!!\"exit 3测试1234567&gt;&gt;&gt; import os&gt;&gt;&gt; status = os.system(\"bash test.sh\")Hello World!!!&gt;&gt;&gt; status768&gt;&gt;&gt; status &gt;&gt; 83该方法在调用完 shell 脚本后，返回一个16位的二进制数，低位为杀死所调用脚本的信号号码，高位为脚本的退出状态码。 返回的结果都是0（使用位运算向右位移8位得到的结果就是高位值），代表代码正常退出。我们如果需要的到脚本执行后返回的状态码，可以使用位运算得到。os.popen这种调用方法是通过管道的方式来实现的，函数返回一个 file-like 的对象，里面的内容是脚本输出的内容（可以简单的理解为 echo 的输出内容）。用于测试的 shell 脚本 test.sh1echo \"Hello World!!!\"测试1234567&gt;&gt;&gt; import os&gt;&gt;&gt; output = os.popen(\"bash test.sh\")&gt;&gt;&gt; output&lt;open file 'bash test.sh', mode 'r' at 0x1031bd780&gt;&gt;&gt;&gt; output.read()'Hello World!!!\\n'&gt;&gt;&gt;commands 模块1. getstatusoutput(cmd)使用 os.popen() 执行命令 cmd ，然后返回两个元素的元组（status, result）。执行方式： { cmd; } 2&gt;&amp;1 ，返回结果里包含标准输出和标准错误。2. getoutput(cmd)只返回执行的结果，忽略状态码。3. getstatus(file)返回 ls -ld file 执行的结果测试123456&gt;&gt;&gt; import commands&gt;&gt;&gt; status, output = commands.getstatusoutput(\"bash test.sh\")&gt;&gt;&gt; status768&gt;&gt;&gt; output'Hello World!!!'subprocess 模块功能强大的子进程管理模块。测试123456&gt;&gt;&gt; import subprocess&gt;&gt;&gt; p = subprocess.Popen(\"bash test.sh\", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)&gt;&gt;&gt; p.stdout.read()'Hello World!!!\\n'&gt;&gt;&gt; p.stderr.read()''","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"Python 第三方模块","slug":"python/base/python 模块安装","date":"2016-04-30T16:00:00.000Z","updated":"2021-11-29T12:47:13.666Z","comments":true,"path":"2016/05/01/python/base/python 模块安装/","link":"","permalink":"https://blazehu.github.io/2016/05/01/python/base/python%20%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85/","excerpt":"安装第三方模块在 Python 中，安装第三方模块，是通过包管理工具 pip 完成的。Mac 或 Linux 预安装了 pip 和 Python。","text":"安装第三方模块在 Python 中，安装第三方模块，是通过包管理工具 pip 完成的。Mac 或 Linux 预安装了 pip 和 Python。Linuxpip 安装123# 安装 pika 模块easy_install pikapip install pika源码安装Linux 上如果没有安装 pip 工具的话可以在官网上下载 pip 的源码包安装。12345tar -zxvf XXXX.tar.gz (or tar jxvf XXXX.tar.bz2) cd XXXX./configuremakemake installWindows如果 Windows 提示未找到命令，需要配置环境变量。即将 C:\\Python27\\Scripts 配置到 path 里。然后在 cmd 命令行使用 pip 或者 easy_install 命令安装需要的模块。可执行文件在官网上下载对应版本的 module 模块，直接安装。pip 安装easy_install 安装第三方模块安装路径Python 默认将三方模块安装到 site-packages ，但是如果使用 Debian 软件管理器安装，模块将被安装到 dist-packages 。查看第三方模块安装路径12from distutils.sysconfig import get_python_libprint (get_python_lib())参考资料https://www.cnblogs.com/kevin922/p/3161411.html","categories":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"}]},{"title":"双机热备（keepalived）","slug":"ops/keepalived","date":"2015-12-05T16:00:00.000Z","updated":"2021-11-29T12:47:13.656Z","comments":true,"path":"2015/12/06/ops/keepalived/","link":"","permalink":"https://blazehu.github.io/2015/12/06/ops/keepalived/","excerpt":"keepalived是什么？ Keepalived是Linux下一个轻量级别的高可用解决方案。除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件。","text":"keepalived是什么？ Keepalived是Linux下一个轻量级别的高可用解决方案。除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件。 Keepalived软件主要是通过VRRP协议实现高可用功能的。VRRP是Virtual Router RedundancyProtocol(虚拟路由器冗余协议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行。keepalived官网: http://www.keepalived.orgkeepalived高可用架构示意图keepalived实践提供2台物理机3个内网ip分别为：10.10.10.126（主节点），10.10.10.127（备用节点），10.10.10.129 （对外提供服务的虚拟IP）在这种模式下，虚拟IP：10.10.10.129，在某时刻只能属于某一个节点，另一个节点作为备用节点存在。当主节点不可用时，备用节点接管虚拟IP（即虚拟IP漂移至节点B），提供正常服务。安装在两台服务器上分别安装 keepalived使用源码包安装添加配置文件1234567891011121314151617181920212223#10.10.10.126sudo vim /etc/keepalived/keepalived.confglobal_defs &#123; router_id LVS_DEVEL&#125;vrrp_instance VI_1 &#123; state MASTER #设置为备服务器（状态参数 MASTER/BACKUP interface eth0 #虚IP地址放置的网卡位置 virtual_router_id 51 #保持主从服务器一致 priority 100 #优先级（决定是主还是备，越大越优先） advert_int 1 #心跳广播（VRRP Multicast）间隔（秒） authentication &#123; auth_type PASS #VRRP认证方式，主备必须一致 auth_pass 1234 #认证密码 &#125; virtual_ipaddress &#123; 10.10.10.129 #设备之间使用的虚拟ip地址，可以多个 &#125;&#125;注意：备份服务器 10.10.10.127 配置中 state 要改成 BACKUP，同时调低 priority。1234567891011121314151617181920212223#10.10.10.127sudo vim /etc/keepalived/keepalived.confglobal_defs &#123; router_id LVS_DEVEL&#125;vrrp_instance VI_1 &#123; state BACKUP #设置为备服务器（状态参数 MASTER/BACKUP interface eth0 #虚IP地址放置的网卡位置 virtual_router_id 51 #保持主从服务器一致 priority 99 #优先级（决定是主还是备，越大越优先） advert_int 1 #心跳广播（VRRP Multicast）间隔（秒） authentication &#123; auth_type PASS #VRRP认证方式，主备必须一致 auth_pass 1234 #认证密码 &#125; virtual_ipaddress &#123; 10.10.10.129 #设备之间使用的虚拟ip地址，可以多个 &#125;&#125;启动keepalived服务$ sudo service keepalived start$ keepalived -D -f /usr/local/etc/keepalived/keepalived.conf查看log消息: tail -f /var/log/messages启动主节点 10.10.10.126 后, messages日志为: 广播ARP消息重启keepalived服务之后使用: ip a 查看虚拟IP信息10.10.10.126 机器上有两个ip ： 本机IP 10.10.10.126 和 虚拟IP 10.10.10.12910.10.10.127 机器上有一个ip ： 本机IP 10.10.10.127在第三台机器上进行访问$ curl http://10.10.10.126$ curl http://10.10.10.127$ curl http://10.10.10.129为了防止备用节点浪费资源，可以使用相互热备分别修改126和127的机器的keepalived 配置文件，增加一个新的配置：VI_21234567891011121314151617181920212223242526272829303132vrrp_instance VI_1 &#123; state BACKUP #设置为备服务器（状态参数 MASTER/BACKUP interface eth0 #虚IP地址放置的网卡位置 virtual_router_id 51 #保持主从服务器一致 priority 99 #优先级（决定是主还是备，越大越优先） advert_int 1 #心跳广播（VRRP Multicast）间隔（秒） authentication &#123; auth_type PASS #VRRP认证方式，主备必须一致 auth_pass 1234 #认证密码 &#125; virtual_ipaddress &#123; 10.10.10.129 #设备之间使用的虚拟ip地址，可以多个 &#125;&#125;vrrp_instance VI_2 &#123; state MASTER #设置为主服务器（状态参数 master/backup） interface eth0 #虚IP地址放置的网卡位置 virtual_router_id 52 #保持主从服务器一致 priority 100 #优先级（决定是主还是备，越大越优先） advert_int 1 #心跳广播（VRRP Multicast）间隔（秒） authentication &#123; auth_type PASS #VRRP认证方式，主备必须一致 auth_pass 1234 #认证密码 &#125; virtual_ipaddress &#123; 10.10.10.130 #设备之间使用的虚拟ip地址，可以多个 &#125;&#125;","categories":[],"tags":[{"name":"keepalived","slug":"keepalived","permalink":"https://blazehu.github.io/tags/keepalived/"}]},{"title":"MySQL 之 AWS RDS 查看慢日志","slug":"mysql/MySQL AWS RDS","date":"2015-11-09T16:00:00.000Z","updated":"2021-11-29T12:47:13.654Z","comments":true,"path":"2015/11/10/mysql/MySQL AWS RDS/","link":"","permalink":"https://blazehu.github.io/2015/11/10/mysql/MySQL%20AWS%20RDS/","excerpt":"查看慢日志需要修改 RDS 的参数组，开启记录慢查询日志。","text":"查看慢日志需要修改 RDS 的参数组，开启记录慢查询日志。解决方案开启 RDS 记录慢查询日志，然后再次按照之前的文档查询日志，参考步骤如下：登陆 AWS Console 页面，打开 RDS 服务。左侧导航栏中找到参数组，修改参数组 sys-mysql，依次修改如下参数：slow_query_log要创建慢速查询日志，请设置为 1。默认值为 0。long_query_time要防止在慢速查询日志中记录快速运行的查询，请指定需要记录的最短查询执行时间值，以秒为单位。默认值为 10 秒，最小值为 0。如果大于这个规定的时间就会记录。log_output option可以指定为 FILE，TABLE 或者 NONE。NONE 为不记录，FILE 是以文件的形式保存，一小时一次。TABLE 是存储到 MySQL 的一个表当中，慢速查询写入 mysql.slow_log 表。如果配置的是 table 可以通过如下方式查看：1select * from mysql.slow_log;相关文档慢查询日志，参考如下文档：http://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/USER_LogAccess.Concepts.MySQL.html修改参数组，参考如下文档：http://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/USER_WorkingWithParamGroups.html#USER_WorkingWithParamGroups.Modifying其他文档主从相关文档http://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/mysql_rds_set_external_master.html其他操作文档http://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/Appendix.MySQL.CommonDBATasks.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blazehu.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"AWS","slug":"AWS","permalink":"https://blazehu.github.io/tags/AWS/"},{"name":"RDS","slug":"RDS","permalink":"https://blazehu.github.io/tags/RDS/"}]},{"title":"MySQL 主从同步","slug":"mysql/MySQL 主从同步","date":"2015-10-22T16:00:00.000Z","updated":"2021-11-29T12:47:13.654Z","comments":true,"path":"2015/10/23/mysql/MySQL 主从同步/","link":"","permalink":"https://blazehu.github.io/2015/10/23/mysql/MySQL%20%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/","excerpt":"简介主从同步分三个步骤：master 将改变记录到二进制日志 binary log 中（这些记录叫做二进制日志事件，binary log events）。slave 将 master 的 binary log events 拷贝到它的中继日志 relay log 中。slave 重做中继日志中的事件，将改变反映它自己的数据。原理图","text":"简介主从同步分三个步骤：master 将改变记录到二进制日志 binary log 中（这些记录叫做二进制日志事件，binary log events）。slave 将 master 的 binary log events 拷贝到它的中继日志 relay log 中。slave 重做中继日志中的事件，将改变反映它自己的数据。原理图配置主库生成快照如果数据库是 MYISAM 或者既有 MYISAM 又有 INNODB 的话使用如下命令导出一个快照：1mysqldump -uroot -p --lock-tables --events --triggers --routines --flush-logs --master-data=2 --databases test &gt; db.sql--locl-tables导出数据时锁表--events会把创建的所有事件也导出来--triggers会把创建的事务也导出来--routines这个是存储过程和存储方法--flush-log导出时先刷新下 binglog 日志--master-data=2导出的文件里 change master 是被注释掉的 ，等于1时不是注释的，这个根据自己的要求改，一般都会选择2因为在从服务器上需要 change 一下 主服务器的ip，端口 ，账号 ，密码如果数据库只有 INNODB，可以使用如下命令：1mysqldump -uroot -p --single-transaction --events --triggers --routines --flush-logs --master-data=2 --databases test &gt; db.sql--single-transaction这个参数只对 innodb 适用--databases后面跟除 mysql 以后的其他所有数据库的库名，我这里只有一个 test 库--master-data参数会记录导出快照时候的 mysql 二进制日志位置，下面会用到修改配置文件修改 mysql 的配置文件 my.cnf12345# 在 [mysqld] 配置段下添加如下字段server-id=1log-bin=logbinlog-do-db=database_name //需要同步的数据库，如果没有这一行那么表示同步所有的数据库binlog-ignore-db=mysql //被忽略的数据库新建同步账号1grant replication slave on *.* to repl@192.168.80.35 identified by 'password';重启服务1service mysqld restart查看日志情况1show master status配置从库修改配置文件修改 mysql 的配置文件 my.cnf123456789# 在 [mysqld] 配置段下添加如下字段server-id=2master-host=192.168.80.35master-user=replmaster-password=passwordmaster-port=3306master-connect-retry=60 //如果从服务器发现主服务器断掉，重新连接的时间差（秒）#replicate-ignore-db=mysql //忽略的数据库#replicate-do-db=repl //同步的数据库（需要备份的数据库名），不写本行代表需要同步所有的数据库重启服务1service mysqld restart快照还原，开始同步先将从主库生成的快照文件还原，然后在 master 主机上使用 grep 命令查找到二进制日志 binglog 的名称以及位置。12grep -i \"change master\" db.sql# -- CHANGE MASTER TO MASTER_LOG_FILE='log.xxxx', MASTER_LOG_POS=98;change master123stop slave;change master to master_host='192.168.80.35', master_user='repl', master_password='password', master_log_file='log.xxxx', master_log_pos=98;start slave;如果 Slave_IO_Running 、 Slave_SQL_Running 状态为 Yes，则表明设置成功。可能出现的问题start slave 报错错误提示ERROR 1200 (HY000): The server is not configured as slave; fix in config file or with CHANGE MASTER TO分析12执行 show slave status 提示 Empty set原因：slave 已经默认开启，要先关闭再开启解决12341. 先执行 slave stop2. 再执行 change master to master_host='192.168.80.35',master_user='repl',master_password='password', master_log_file='log.000003' ,master_log_pos=98;3. 再执行 slave start4. 最后查看状态 show slave status\\G测试主从同步在我们配置的主从同步的数据库下建测试表，对数据进行操作，然后在另一边查看是否同步。清除主从同步配置信息123mysql&gt; slave stop;mysql&gt; reset slave;mysql&gt; change master to master_user='', master_host='', master_password='';清除失败12345# 可能报错：ERROR 1210 (HY000): Incorrect arguments to MASTER_HOST 。解决办法如下：mysql&gt; change master to master_host=' ';# 上面的命令报错的原因，为 master_host=' ' 里面必须有内容，即使为空，也应该用空格代替，而不能什么都不写。参考资料https://www.cnblogs.com/myIvan/p/10164926.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blazehu.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MySQL 学习笔记","slug":"mysql/MySQL 学习笔记","date":"2015-08-31T16:00:00.000Z","updated":"2021-11-29T12:47:13.654Z","comments":true,"path":"2015/09/01/mysql/MySQL 学习笔记/","link":"","permalink":"https://blazehu.github.io/2015/09/01/mysql/MySQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"简介MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统) 应用软件之一。","text":"简介MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统) 应用软件之一。Server version: 5.7.17 MySQL Community Server (GPL)连接登录123mysql -u用户名 -p用户密码 （如果连接远端机器加上参数 -h 远端机器IP -P 端口）# 例子mysql -h 127.0.0.1 -P 3306 -uroot -ppassword登出1exit用户权限管理新建用户12mysql&gt; create user 'blazehu'@'127.0.0.1' identified by 'readonly';Query OK, 0 rows affected (0.01 sec)查看用户1234567891011mysql&gt; select Host, User from mysql.user;+-----------+-----------+| Host | User |+-----------+-----------+| % | root || 127.0.0.1 | blazehu || 127.0.0.1 | root || localhost | mysql.sys || localhost | root |+-----------+-----------+5 rows in set (0.00 sec)删除用户12mysql&gt; drop user 'blazehu'@'127.0.0.1';Query OK, 0 rows affected (0.00 sec)用户赋权使用 grant 增加新用户设置用户权限等 （可以直接对 mysql.user 用户表操作，来修改用户密码等）12mysql&gt; grant select, update, insert, delete on test.* to 'blazehu'@'127.0.0.1' identified by '123456';Query OK, 0 rows affected, 1 warning (0.00 sec)刷新权限12mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)查看用户权限12345678mysql&gt; show grants for 'blazehu'@'127.0.0.1';+---------------------------------------------------------------------------+| Grants for blazehu@127.0.0.1 |+---------------------------------------------------------------------------+| GRANT USAGE ON *.* TO 'blazehu'@'127.0.0.1' || GRANT SELECT, INSERT, UPDATE, DELETE ON `test`.* TO 'blazehu'@'127.0.0.1' |+---------------------------------------------------------------------------+2 rows in set (0.00 sec)用户重命名12mysql&gt; rename user 'blazehu'@'127.0.0.1' to 'blaze'@'127.0.0.1';Query OK, 0 rows affected (0.00 sec)修改密码123456mysql&gt; update mysql.user set authentication_string=password('123456') where user='blaze';Query OK, 0 rows affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 1mysql&gt; set password for 'blaze'@'127.0.0.1'=password('123456');Query OK, 0 rows affected, 1 warning (0.00 sec)也可以使用 mysqladmin 命令来修改密码。数据库基础操作显示数据库列表1234567891011mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test |+--------------------+5 rows in set (0.00 sec)创建数据库12mysql&gt; create database test default character set utf8;;Query OK, 1 row affected (0.00 sec)选择数据库12mysql&gt; use testDatabase changed删除数据库12mysql&gt; drop database test;Query OK, 0 rows affected (0.00 sec)数据表基础操作显示数据表123456789101112131415161718192021mysql&gt; show tables;+-----------------------------------+| Tables_in_test |+-----------------------------------+| account_permission || account_userpermission || auth_group || auth_group_permissions || auth_permission || auth_user || auth_user_groups || auth_user_user_permissions || authtoken_token || django_admin_log || django_cas_ng_proxygrantingticket || django_cas_ng_sessionticket || django_content_type || django_migrations || django_session |+-----------------------------------+15 rows in set (0.00 sec)查看数据库表结构1234567891011121314151617mysql&gt; desc auth_user;+--------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || password | varchar(128) | NO | | NULL | || last_login | datetime(6) | YES | | NULL | || is_superuser | tinyint(1) | NO | | NULL | || username | varchar(150) | NO | UNI | NULL | || first_name | varchar(30) | NO | | NULL | || last_name | varchar(150) | NO | | NULL | || email | varchar(254) | NO | | NULL | || is_staff | tinyint(1) | NO | | NULL | || is_active | tinyint(1) | NO | | NULL | || date_joined | datetime(6) | NO | | NULL | |+--------------+--------------+------+-----+---------+----------------+11 rows in set (0.00 sec)删除数据表12mysql&gt; drop table auth_user;Query OK, 0 rows affected (0.02 sec)查看建表语句12345678910111213141516171819202122mysql&gt; show create table auth_user \\G;*************************** 1. row *************************** Table: auth_userCreate Table: CREATE TABLE `auth_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `password` varchar(128) NOT NULL, `last_login` datetime(6) DEFAULT NULL, `is_superuser` tinyint(1) NOT NULL, `username` varchar(150) NOT NULL, `first_name` varchar(30) NOT NULL, `last_name` varchar(150) NOT NULL, `email` varchar(254) NOT NULL, `is_staff` tinyint(1) NOT NULL, `is_active` tinyint(1) NOT NULL, `date_joined` datetime(6) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb41 row in set (0.00 sec)ERROR:No query specified数据库表增删改查1234插入： insert into tablename values(\"\", \"\");删除： delete from tablename where ...;更新： update tablename set a=\"\" where ...;查找： select * from tablename where ...;创建索引123mysql&gt; alter table auth_user add key test__name(name) using btree;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0其他常用命令查看数据库变量信息1234567891011121314mysql&gt; show variables like \"character%\";+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | latin1 || character_set_connection | latin1 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | latin1 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.01 sec)查看数据库大小1234567mysql&gt; select concat(round(sum(DATA_LENGTH/1024/1024),2),'MB') as data from information_schema.TABLES where table_schema='test';+--------+| data |+--------+| 0.56MB |+--------+1 row in set (0.01 sec)查看数据表大小12345678910111213141516mysql&gt; SELECT TABLE_NAME, round(DATA_LENGTH/1024/1024,2) as data ,TABLE_ROWS FROM information_schema.TABLES WHERE TABLE_SCHEMA='test' order by data desc limit 10;+---------------------------+------+------------+| TABLE_NAME | data | TABLE_ROWS |+---------------------------+------+------------+| django_session | 4.45 | 410 || cloud_hostmaintenanceuser | 1.52 | 7648 || storage_cephbucket | 1.52 | 1284 || redis_draft_service_log | 0.52 | 990 || kubemetrics_nodeinfos | 0.42 | 1235 || saltstack_saltgrainsitems | 0.30 | 1409 || auth_user_groups | 0.23 | 3055 || storage_glusterbrick | 0.22 | 1328 || saltstack_addonversion | 0.17 | 1283 || auth_user | 0.14 | 1171 |+---------------------------+------+------------+10 rows in set (0.01 sec)修改默认分隔符默认分隔符为 “;”1delimiter //MySQL 主从，跳过一个错误1SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1;通过脚本操作数据库1mysql -h host -P port -uUsername -pPassword -e \"command\"备份和还原备份数据库mysqldump 命令1234567891011# 包括数据库中的数据root@demo:/# mysqldump -uroot -ppassword test &gt; test.sql# 不包括数据库中的数据root@demo:/# mysqldump -uroot -ppassword -d test &gt; test.sql# 数据库中的某张表（包含数据）root@demo:/# mysqldump -uroot -ppassword test auth_user &gt; test.sql# 数据库中的某张表（不包含数据）root@demo:/# mysqldump -uroot -ppassword -d test auth_user &gt; test.sql还原数据库mysql 命令1root@demo:/# mysql -uroot -ppassword test &lt; test.sqlsource 命令12mysql&gt; source test.sql;Query OK, 1 row affected (0.00 sec)备份数据表123mysql&gt; create table auth_user_bak as select * from auth_user;Query OK, 1 row affected (0.07 sec)Records: 1 Duplicates: 0 Warnings: 0热备工具qpress 解压工具percona-xtrabackup 热备工具相关问题在做数据库主从和备份的时候发现 dump 失败 ？mysqldump 失败的原因可能是 my.cnf “#innodb_force_recovery=1” 参数没有注释掉，这个参数放开会导致数据库不能做 insert、update、dump 数据库等操作。Ubuntu 12.04 安装 mysql-python 提示找不到 mysql_config ？安装 libmysqlclient-dev 库： sudo apt-get install libmysqlclient-dev 。安装完成之后在 /etc/mysql 下会生成默认的 my.cnf 配置文件 ，系统优先读取该路径下的配置文件信息，这时候需要注意检查配置文件是否正确。通过 shell watch mysql 的一些参数，发现 mysql 连接断开，报错 too many connection ？watch 每隔2秒钟 连接一次 mysql 导致数据库连接过多，数据库自动断开连不上。参考资料https://www.runoob.com/mysql/mysql-tutorial.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blazehu.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"c++学习之--冒泡排序","slug":"c++/c++学习之--冒泡排序","date":"2013-11-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.644Z","comments":true,"path":"2013/11/20/c++/c++学习之--冒泡排序/","link":"","permalink":"https://blazehu.github.io/2013/11/20/c++/c++%E5%AD%A6%E4%B9%A0%E4%B9%8B--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"例子123456789101112131415161718192021222324252627282930313233343536373839404142434445//冒泡排序 //时间复杂度是 O(pow(n,2))//maopao.cpp#include &lt;iostream&gt;using namespace std; #define N 10 void MpSort(int *a,int n)&#123; int i,j; for(i=0;i&lt;n-1;i++) &#123; for(j=0;j&lt;n-1-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; a[j]=a[j]+a[j+1]; a[j+1]=a[j]-a[j+1]; a[j]=a[j]-a[j+1]; &#125; &#125; &#125;&#125; int main()&#123; int i,j; int *a=new int[N]; for(i=0;i&lt;N;i++) &#123; cin&gt;&gt;a[i]; &#125; MpSort(a,N); for(i=0;i&lt;N;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return 0;&#125;测试12345678910111213[blazehu@MacBook ~]$ g++ -o maopao maopao.cpp[blazehu@MacBook ~]$ ./maopao09812365470 1 2 3 4 5 6 7 8 9","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://blazehu.github.io/tags/c/"}]},{"title":"c++学习之--堆排序","slug":"c++/c++学习之--堆排序","date":"2013-11-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.644Z","comments":true,"path":"2013/11/20/c++/c++学习之--堆排序/","link":"","permalink":"https://blazehu.github.io/2013/11/20/c++/c++%E5%AD%A6%E4%B9%A0%E4%B9%8B--%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//堆排序 (大顶堆)//不稳定，建堆需要时间较长 时间复杂度为 O(n*log2(n))//head.cpp#include &lt;iostream&gt;using namespace std;void Swap(int *x,int *y)&#123; int t; t=*x; *x=*y; *y=t; &#125; void HeapAdjust(int *a,int i,int size)&#123; int lchild=2*i; int rchild=2*i+1; int max=i; if(i&lt;=size/2) &#123; if(lchild&lt;=size &amp;&amp; a[lchild]&gt;a[max]) &#123; max=lchild; &#125; if(rchild&lt;=size &amp;&amp; a[rchild]&gt;a[max]) &#123; max=rchild; &#125; if(max!=i) &#123; Swap(&amp;a[i],&amp;a[max]); HeapAdjust(a,max,size); &#125; &#125;&#125; void BuildHeap(int *a,int size)&#123; int i; for(i=size/2;i&gt;=1;i--) &#123; HeapAdjust(a,i,size); &#125; &#125; void HeapSort(int *a,int size)&#123; BuildHeap(a,size); for(int i=size;i&gt;=1;i--) &#123; Swap(&amp;a[1],&amp;a[i]); HeapAdjust(a,1,i-1); &#125;&#125; int main()&#123; int n,i; cin&gt;&gt;n; int *a=new int[n+1]; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; HeapSort(a,n); for(i=1;i&lt;=n;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return 0;&#125;测试12345678910[blazehu@MacBook ~]$ g++ -o head head.cpp[blazehu@MacBook ~]$ ./head5368722 3 6 7 8[blazehu@MacBook ~]$","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://blazehu.github.io/tags/c/"}]},{"title":"c++学习之--快速排序","slug":"c++/c++学习之--快速排序","date":"2013-11-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.644Z","comments":true,"path":"2013/11/20/c++/c++学习之--快速排序/","link":"","permalink":"https://blazehu.github.io/2013/11/20/c++/c++%E5%AD%A6%E4%B9%A0%E4%B9%8B--%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//快速排序//最好的情况是 O(n*log2(n)) //最坏的情况将退化为冒泡排序为 O(pow(2,n))//kuaipai.cpp#include &lt;iostream&gt;using namespace std; #define N 10 int Partition(int *a,int low,int high)&#123; int temp; temp=a[low]; while(low&lt;high) &#123; while(low&lt;high &amp;&amp; temp&lt;a[high]) &#123; high--; &#125; if(low&lt;high) &#123; a[low]=a[high]; low++; &#125; while(low&lt;high &amp;&amp; a[low]&lt;temp) &#123; low++; &#125; if(low&lt;high) &#123; a[high]=a[low]; high--; &#125; &#125; a[low]=temp; return low;&#125; void QuickSort(int *a,int low,int high)&#123; int i; if(low&lt;high) &#123; i=Partition(a,low,high); QuickSort(a,low,i-1); QuickSort(a,i+1,high); &#125; &#125; int main()&#123; int low,high,temp; int *a=new int[N]; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;a[i]; &#125; QuickSort(a,0,N-1); for(int i=0;i&lt;N;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return 0;&#125;测试1234567891011121314[blazehu@MacBook ~]$ g++ -o quicksort kuaipai.cpp[blazehu@MacBook ~]$ ./quicksort13496782500 1 2 3 4 5 6 7 8 9[blazehu@MacBook ~]$","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://blazehu.github.io/tags/c/"}]},{"title":"c++学习之--直接插入排序","slug":"c++/c++学习之--直接插入排序","date":"2013-11-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.644Z","comments":true,"path":"2013/11/20/c++/c++学习之--直接插入排序/","link":"","permalink":"https://blazehu.github.io/2013/11/20/c++/c++%E5%AD%A6%E4%B9%A0%E4%B9%8B--%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"例子1234567891011121314151617181920212223242526272829303132333435363738394041424344//直接插入排序 //最好的情况是 O(n) 只需要扫一遍。//最坏的情况是 O(pow(n,2))//charu.cpp#include &lt;iostream&gt;using namespace std; #define N 10 void CrSort(int *a,int n)&#123; int i,t; for(i=1;i&lt;n;i++) &#123; t=a[i]; while(t&lt;a[i-1] &amp;&amp; i) &#123; a[i]=a[i-1]; i--; &#125; a[i]=t; &#125;&#125; int main()&#123; int i; int *a=new int[N]; for(i=0;i&lt;N;i++) &#123; cin&gt;&gt;a[i]; &#125; CrSort(a,N); for(i=0;i&lt;N;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return 0;&#125;测试12345678910111213[blazehu@MacBook ~]$ g++ -o demo charu.cpp[blazehu@MacBook ~]$ ./demo14325679800 1 2 3 4 5 6 7 8 9","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://blazehu.github.io/tags/c/"}]},{"title":"c++学习之--直接选择排序","slug":"c++/c++学习之--直接选择排序","date":"2013-11-19T16:00:00.000Z","updated":"2021-11-29T12:47:13.644Z","comments":true,"path":"2013/11/20/c++/c++学习之--直接选择排序/","link":"","permalink":"https://blazehu.github.io/2013/11/20/c++/c++%E5%AD%A6%E4%B9%A0%E4%B9%8B--%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//直接选择排序 //时间复杂度为 O(pow(n,2))//xuanze.cpp#include &lt;iostream&gt;using namespace std;#define N 10void XzSort(int *a,int n)&#123; int i,j,min_i,t; for(i=0;i&lt;n-1;i++) &#123; min_i=i; for(j=i+1;j&lt;n;j++) &#123; if(a[min_i]&gt;a[j]) &#123; min_i=j; &#125; &#125; if(min_i!=i) &#123; t=a[i]; a[i]=a[min_i]; a[min_i]=t; &#125; &#125; &#125;int main()&#123; int *a; a=new int[N]; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;a[i]; &#125; XzSort(a,N); for(int i=0;i&lt;N;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; return 0;&#125;测试12345678910111213[blazehu@MacBook ~]$ g++ -o test xuanze.cpp[blazehu@MacBook ~]$ ./test56473892100 1 2 3 4 5 6 7 8 9","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://blazehu.github.io/tags/c/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Golang","slug":"Golang","permalink":"https://blazehu.github.io/categories/Golang/"},{"name":"API 网关","slug":"API-网关","permalink":"https://blazehu.github.io/categories/API-%E7%BD%91%E5%85%B3/"},{"name":"工具","slug":"工具","permalink":"https://blazehu.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"算法","slug":"算法","permalink":"https://blazehu.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blazehu.github.io/categories/Nginx/"},{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/categories/Python/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blazehu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://blazehu.github.io/tags/PostgreSQL/"},{"name":"Golang","slug":"Golang","permalink":"https://blazehu.github.io/tags/Golang/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blazehu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blazehu.github.io/tags/RabbitMQ/"},{"name":"消息队列","slug":"消息队列","permalink":"https://blazehu.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"Kong","slug":"Kong","permalink":"https://blazehu.github.io/tags/Kong/"},{"name":"API 网关","slug":"API-网关","permalink":"https://blazehu.github.io/tags/API-%E7%BD%91%E5%85%B3/"},{"name":"Rundeck","slug":"Rundeck","permalink":"https://blazehu.github.io/tags/Rundeck/"},{"name":"定时任务","slug":"定时任务","permalink":"https://blazehu.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blazehu.github.io/tags/leetcode/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blazehu.github.io/tags/Nginx/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blazehu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://blazehu.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"CSRF","slug":"CSRF","permalink":"https://blazehu.github.io/tags/CSRF/"},{"name":"Siege","slug":"Siege","permalink":"https://blazehu.github.io/tags/Siege/"},{"name":"Python","slug":"Python","permalink":"https://blazehu.github.io/tags/Python/"},{"name":"Sanic","slug":"Sanic","permalink":"https://blazehu.github.io/tags/Sanic/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://blazehu.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"keepalived","slug":"keepalived","permalink":"https://blazehu.github.io/tags/keepalived/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blazehu.github.io/tags/MySQL/"},{"name":"AWS","slug":"AWS","permalink":"https://blazehu.github.io/tags/AWS/"},{"name":"RDS","slug":"RDS","permalink":"https://blazehu.github.io/tags/RDS/"},{"name":"c++","slug":"c","permalink":"https://blazehu.github.io/tags/c/"}]}