<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小千世界</title>
  
  
  <link href="https://blazehu.github.io/atom.xml" rel="self"/>
  
  <link href="https://blazehu.github.io/"/>
  <updated>2024-02-19T08:27:03.886Z</updated>
  <id>https://blazehu.github.io/</id>
  
  <author>
    <name>BlazeHu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang archive/zip 问题排查小记</title>
    <link href="https://blazehu.github.io/2024/02/18/golang/golang_archive_zip/"/>
    <id>https://blazehu.github.io/2024/02/18/golang/golang_archive_zip/</id>
    <published>2024-02-17T16:00:00.000Z</published>
    <updated>2024-02-19T08:27:03.886Z</updated>
    
    <content type="html"><![CDATA[<p>2021年给开发商做了一个<a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>，近期开发商反馈当上传的ipa文件比较大超过4G的时候上传失败。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>的技术架构如下图，，蓝盾插件请求版本体验后端，后端临时缓存文件并解析ipa和apk文件，获取包的相关信息（包名，版本号，图标等），然后上传至cos存储。服务端使用的golang的版本是<a href="https://go.dev/doc/go1.16" target="_blank" rel="noopener">go1.16</a>。<br><img src="/2024/02/18/golang/golang_archive_zip/ipapk.png" alt></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="插件侧报错"><a href="#插件侧报错" class="headerlink" title="插件侧报错"></a>插件侧报错</h4><p>用户反馈插件执行报错 <strong>“zip: not a valid zip file”</strong>（插件将ipa或者apk包上传至版本体验后端）<br><img src="/2024/02/18/golang/golang_archive_zip/plugin_error.png" alt></p><h4 id="服务端解析包报错"><a href="#服务端解析包报错" class="headerlink" title="服务端解析包报错"></a>服务端解析包报错</h4><p>通过排查后端服务日志，问题比较清晰，就是后端解析包的时候报错。解析<code>ipa</code>包的相关代码如下所示，整体逻辑比较简单，通过 <code>archive/zip</code> 读取<code>ipa</code>文件，通过正则找到 <code>plist</code> 和 <code>AppIcon</code> 文件，然后分别通过 <a href="howett.net/plist">plist</a> 和 <a href="github.com/andrianbdn/iospng">iospng</a> 解析<br>得到相关信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIpa</span><span class="params">(readerAt io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="params">(*App, error)</span></span> &#123;</span><br><span class="line">log.Info(<span class="string">"[upload] file size : "</span>, size)</span><br><span class="line"><span class="keyword">var</span> reInfoPlist = regexp.MustCompile(<span class="string">`Payload/[^/]+/Info\.plist`</span>)</span><br><span class="line"></span><br><span class="line">reader, err := zip.NewReader(readerAt, size)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"[upload] zip new reader failed, err: "</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plistFile, iosIconFile *zip.File</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> reader.File &#123;</span><br><span class="line">log.Info(<span class="string">"[upload] reader file: "</span>, f.Name)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reInfoPlist.MatchString(f.Name):</span><br><span class="line">plistFile = f</span><br><span class="line"><span class="keyword">case</span> strings.Contains(f.Name, <span class="string">"AppIcon60x60"</span>):</span><br><span class="line">iosIconFile = f</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"[upload] reader plist file: "</span>, plistFile.Name)</span><br><span class="line">log.Info(<span class="string">"[upload] reader icon file: "</span>, iosIconFile.Name)</span><br><span class="line">app, err := parseIpaFile(plistFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> ignore error</span></span><br><span class="line">log.Error(<span class="string">"[upload] parse ipa failed, err: "</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"[upload] parse ipa success, err: "</span>, app)</span><br><span class="line">icon, err := parseIpaIcon(iosIconFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> ignore error</span></span><br><span class="line">log.Error(<span class="string">"[upload] parse ipa icon failed, err: "</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">app.Size = size</span><br><span class="line">app.Icon = icon</span><br><span class="line"><span class="keyword">return</span> app, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的报错：<strong>“zip: not a valid zip file”</strong> 定位是 <code>archive/zip</code> 库抛出的。</p><h4 id="源码阅读-archive-zip"><a href="#源码阅读-archive-zip" class="headerlink" title="源码阅读(archive/zip)"></a>源码阅读(<code>archive/zip</code>)</h4><p>通过查阅源码，发现该错误就是常量 <code>ErrFormat</code>，<code>NewReader</code> 方法调用了 <code>init</code> 方法，而 <code>init</code> 方法在循环读取文件头部 <code>readDirectoryHeader</code> 时会判断错误类型，如果是 <code>ErrFormat</code> 会将错误抛出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrFormat       = errors.New(<span class="string">"zip: not a valid zip file"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="params">(*Reader, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"zip: size cannot be negative"</span>)</span><br><span class="line">&#125;</span><br><span class="line">zr := <span class="built_in">new</span>(Reader)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> err = zr.init(r, size); err != <span class="literal">nil</span> &amp;&amp; err != ErrInsecurePath &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">init</span><span class="params">(rdr io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">end, baseOffset, err := readDirectoryEnd(rdr, size)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">r.r = rdr</span><br><span class="line">r.baseOffset = baseOffset</span><br><span class="line"><span class="comment">// Since the number of directory records is not validated, it is not</span></span><br><span class="line"><span class="comment">// safe to preallocate r.File without first checking that the specified</span></span><br><span class="line"><span class="comment">// number of files is reasonable, since a malformed archive may</span></span><br><span class="line"><span class="comment">// indicate it contains up to 1 &lt;&lt; 128 - 1 files. Since each file has a</span></span><br><span class="line"><span class="comment">// header which will be _at least_ 30 bytes we can safely preallocate</span></span><br><span class="line"><span class="comment">// if (data size / 30) &gt;= end.directoryRecords.</span></span><br><span class="line"><span class="keyword">if</span> end.directorySize &lt; <span class="keyword">uint64</span>(size) &amp;&amp; (<span class="keyword">uint64</span>(size)-end.directorySize)/<span class="number">30</span> &gt;= end.directoryRecords &#123;</span><br><span class="line">r.File = <span class="built_in">make</span>([]*File, <span class="number">0</span>, end.directoryRecords)</span><br><span class="line">&#125;</span><br><span class="line">r.Comment = end.comment</span><br><span class="line">rs := io.NewSectionReader(rdr, <span class="number">0</span>, size)</span><br><span class="line"><span class="keyword">if</span> _, err = rs.Seek(r.baseOffset+<span class="keyword">int64</span>(end.directoryOffset), io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">buf := bufio.NewReader(rs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The count of files inside a zip is truncated to fit in a uint16.</span></span><br><span class="line"><span class="comment">// Gloss over this by reading headers until we encounter</span></span><br><span class="line"><span class="comment">// a bad one, and then only report an ErrFormat or UnexpectedEOF if</span></span><br><span class="line"><span class="comment">// the file count modulo 65536 is incorrect.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">f := &amp;File&#123;zip: r, zipr: rdr&#125;</span><br><span class="line">err = readDirectoryHeader(f, buf)</span><br><span class="line"><span class="keyword">if</span> err == ErrFormat || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.headerOffset += r.baseOffset</span><br><span class="line">r.File = <span class="built_in">append</span>(r.File, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint16</span>(<span class="built_in">len</span>(r.File)) != <span class="keyword">uint16</span>(end.directoryRecords) &#123; <span class="comment">// only compare 16 bits here</span></span><br><span class="line"><span class="comment">// Return the readDirectoryHeader error if we read</span></span><br><span class="line"><span class="comment">// the wrong number of directory entries.</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> zipinsecurepath.Value() == <span class="string">"0"</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line"><span class="keyword">if</span> f.Name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Zip permits an empty file name field.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The zip specification states that names must use forward slashes,</span></span><br><span class="line"><span class="comment">// so consider any backslashes in the name insecure.</span></span><br><span class="line"><span class="keyword">if</span> !filepath.IsLocal(f.Name) || strings.Contains(f.Name, <span class="string">`\`</span>) &#123;</span><br><span class="line">zipinsecurepath.IncNonDefault()</span><br><span class="line"><span class="keyword">return</span> ErrInsecurePath</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-本地复现"><a href="#4-本地复现" class="headerlink" title="4. 本地复现"></a>4. 本地复现</h4><p>本地复现该问题的时候发现解析正常，但是打成镜像容器部署会报错，通过对比我发现本地使用的go的版本是 <a href="https://go.dev/doc/go1.21" target="_blank" rel="noopener">go1.21</a> ，而镜像使用的构建镜像是 <a href="https://go.dev/doc/go1.16" target="_blank" rel="noopener">go1.16</a> 。挨个查阅 golang 的 <a href="https://go.dev/doc/devel/release" target="_blank" rel="noopener">release</a> 最终定位到是 <a href="https://go.dev/doc/go1.19" target="_blank" rel="noopener">go1.19</a> 的新特性导致的差异。<br><img src="/2024/02/18/golang/golang_archive_zip/zip.png" alt><br><a href="https://github.com/golang/go/blob/go1.19/src/archive/zip/reader.go" target="_blank" rel="noopener">相关改动代码</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The count of files inside a zip is truncated to fit in a uint16.</span></span><br><span class="line"><span class="comment">// Gloss over this by reading headers until we encounter</span></span><br><span class="line"><span class="comment">// a bad one, and then only report an ErrFormat or UnexpectedEOF if</span></span><br><span class="line"><span class="comment">// the file count modulo 65536 is incorrect.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    f := &amp;File&#123;zip: z, zipr: r&#125;</span><br><span class="line">    err = readDirectoryHeader(f, buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For compatibility with other zip programs,</span></span><br><span class="line">    <span class="comment">// if we have a non-zero base offset and can't read</span></span><br><span class="line">    <span class="comment">// the first directory header, try again with a zero</span></span><br><span class="line">    <span class="comment">// base offset.</span></span><br><span class="line">    <span class="keyword">if</span> err == ErrFormat &amp;&amp; z.baseOffset != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(z.File) == <span class="number">0</span> &#123;</span><br><span class="line">        z.baseOffset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> _, err = rs.Seek(<span class="keyword">int64</span>(end.directoryOffset), io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        buf.Reset(rs)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == ErrFormat || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    f.headerOffset += z.baseOffset</span><br><span class="line">    z.File = <span class="built_in">append</span>(z.File, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增逻辑解读：如果在读取第一个目录头时遇到 <code>ErrFormat</code> 错误，并且基偏移量不为零，则尝试使用零基偏移量重新读取目录头。如果重新读取目录头仍然失败，则返回错误。</p><blockquote><p>NOTE: 不同操作系统或 ZIP 工具创建的 ZIP 文件时，可能会遇到不同的实现和约定。这可能导致基偏移量的计算方式不同，从而导致错误的值。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>升级golang构建的基础镜像，从<code>1.16</code> -&gt; <code>1.22</code>，重新构建新的服务镜像更新服务，这样基本满足了用户的需求。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># builder</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.22</span> AS builder</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /src/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /src &amp;&amp; go mod tidy</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /src &amp;&amp; go build -ldflags <span class="string">'-linkmode "external" --extldflags "-static"'</span> main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.14</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"blazehu"</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /ipapk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /src/main /ipapk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh /docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> /docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://go.dev/doc/go1.19" target="_blank" rel="noopener">https://go.dev/doc/go1.19</a></li><li><a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">https://docs.bkci.net/services/client-experience</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年给开发商做了一个&lt;a href=&quot;https://docs.bkci.net/services/client-experience&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端版本体验&lt;/a&gt;，近期开发商反馈当上传的ipa文件比较大超过4G的时候上传失败。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blazehu.github.io/categories/Golang/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="archive/zip" scheme="https://blazehu.github.io/tags/archive-zip/"/>
    
    <category term="ipapk" scheme="https://blazehu.github.io/tags/ipapk/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffers 学习笔记</title>
    <link href="https://blazehu.github.io/2023/11/21/golang/golang_pb/"/>
    <id>https://blazehu.github.io/2023/11/21/golang/golang_pb/</id>
    <published>2023-11-20T16:00:00.000Z</published>
    <updated>2023-11-27T08:11:16.056Z</updated>
    
    <content type="html"><![CDATA[<p>Protocol Buffers 是一种跨语言、跨平台的序列化方法，可实现结构化数据的高效编码和解码。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Protocol Buffers 是一种数据序列化格式，类似于 JSON，但体积更小、速度更快，并支持本地语言绑定。它允许用户定义数据结构，并自动生成源代码，以便在各种数据流和编程语言中轻松读写结构化数据。</p><h3 id="Protocol-Buffers-解决了什么问题？"><a href="#Protocol-Buffers-解决了什么问题？" class="headerlink" title="Protocol Buffers 解决了什么问题？"></a>Protocol Buffers 解决了什么问题？</h3><p>Protocol Buffers 为最大几兆字节的类型化、结构化数据包提供一种序列化格式。该格式适用于短暂的网络传输和长期数据存储。它支持在不影响现有数据或更新代码的情况下扩展新信息，广泛应用于谷歌的服务器间通信和数据存储。它还能保持向后兼容性，支持添加新字段和删除现有字段。</p><h3 id="使用-Protocol-Buffers-有什么好处？"><a href="#使用-Protocol-Buffers-有什么好处？" class="headerlink" title="使用 Protocol Buffers 有什么好处？"></a>使用 Protocol Buffers 有什么好处？</h3><p>Protocol Buffers 非常适合需要以语言无关、平台无关、可扩展的方式序列化结构化、类似记录的类型化数据的任何场景。它们通常用于定义通信协议（与 gRPC 一起使用）以及数据存储。</p><h4 id="使用-Protocol-Buffers-的一些优点"><a href="#使用-Protocol-Buffers-的一些优点" class="headerlink" title="使用 Protocol Buffers 的一些优点"></a>使用 Protocol Buffers 的一些优点</h4><ul><li>紧凑的数据存储</li><li>快速解析</li><li>多种编程语言的支持</li><li>通过自动生成的类优化功能</li></ul><h4 id="跨语言兼容性"><a href="#跨语言兼容性" class="headerlink" title="跨语言兼容性"></a>跨语言兼容性</h4><p>同样的消息可以由任何支持的编程语言编写的代码读取。可以在一个平台上使用 Java 程序从一个软件系统捕获数据，根据 <code>.proto</code> 定义序列化它，然后在另一个平台上运行的单独的 Python 应用程序中从序列化数据中提取特定值。</p><p><strong>Protocol buffers 编译器 protoc 直接支持以下语言：</strong></p><ul><li><a href="https://protobuf.dev/reference/cpp/cpp-generated/#invocation" target="_blank" rel="noopener">C++</a></li><li><a href="https://protobuf.dev/reference/csharp/csharp-generated/#invocation" target="_blank" rel="noopener">C#</a></li><li><a href="https://protobuf.dev/reference/java/java-generated/#invocation" target="_blank" rel="noopener">Java</a></li><li><a href="https://protobuf.dev/reference/kotlin/kotlin-generated/#invocation" target="_blank" rel="noopener">Kotlin</a></li><li><a href="https://protobuf.dev/reference/objective-c/objective-c-generated/#invocation" target="_blank" rel="noopener">Objective-C</a></li><li><a href="https://protobuf.dev/reference/php/php-generated/#invocation" target="_blank" rel="noopener">PHP</a></li><li><a href="https://protobuf.dev/reference/python/python-generated/#invocation" target="_blank" rel="noopener">Python</a></li><li><a href="https://protobuf.dev/reference/ruby/ruby-generated/#invocation" target="_blank" rel="noopener">Ruby</a></li></ul><p><strong>以下语言由 Google 支持，但项目源代码位于 GitHub 仓库。protoc 编译器为这些语言使用插件：</strong></p><ul><li><a href="https://github.com/google/protobuf.dart" target="_blank" rel="noopener">Dart</a></li><li><a href="https://github.com/protocolbuffers/protobuf-go" target="_blank" rel="noopener">Go</a></li></ul><p>其他语言不直接由 Google 支持，而是由其他 GitHub 项目支持。这些语言在协议缓冲区的<a href="https://github.com/protocolbuffers/protobuf/blob/main/docs/third_party.md" target="_blank" rel="noopener">第三方插件</a>中有介绍。</p><h4 id="跨项目支持"><a href="#跨项目支持" class="headerlink" title="跨项目支持"></a>跨项目支持</h4><p>可以通过在 <code>.proto</code> 文件中定义消息类型并将其放置在特定项目代码库之外来在项目之间使用 Protocol buffers。如果你正在定义消息类型或枚举，并预计你的团队之外的人员将广泛使用它们，那么可以将它们放在没有依赖关系的单独文件中。<br>谷歌内部广泛使用的一些 <code>proto</code> 定义示例包括 <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener">timestamp.proto</a> 和 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener">status.proto</a>。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://protobuf.dev/overview/" target="_blank" rel="noopener">https://protobuf.dev/overview/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Protocol Buffers 是一种跨语言、跨平台的序列化方法，可实现结构化数据的高效编码和解码。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://blazehu.github.io/categories/Golang/"/>
    
    
    <category term="grpc" scheme="https://blazehu.github.io/tags/grpc/"/>
    
    <category term="Protocol Buffers" scheme="https://blazehu.github.io/tags/Protocol-Buffers/"/>
    
  </entry>
  
  <entry>
    <title>Argo CD 源码解析之自动同步</title>
    <link href="https://blazehu.github.io/2023/10/25/cloudnative/argocd_webhook/"/>
    <id>https://blazehu.github.io/2023/10/25/cloudnative/argocd_webhook/</id>
    <published>2023-10-24T16:00:00.000Z</published>
    <updated>2023-11-03T06:25:55.881Z</updated>
    
    <content type="html"><![CDATA[<p>Argo CD 的自动同步功能通过监控 Git 仓库中的更改来自动部署和更新应用程序。这确保了 Kubernetes 集群中的应用程序始终与 Git 仓库中的配置保持一致。开发团队只需将应用程序的描述和配置存储在 Git 仓库中，Argo CD 会根据这些信息自动部署和更新应用程序。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>Argo CD 是一个开源的持续部署工具，专为 Kubernetes 应用程序设计。它遵循 GitOps 原则，将 Git 仓库作为应用程序部署和基础设施管理的“单一真实来源”。架构上 Argo CD 采用基于组件的架构设计，将不同可部署单元的职责分开，以提高系统的灵活性、可维护性和可扩展性。</p><p><img src="/2023/10/25/cloudnative/argocd_webhook/dependencies.png" alt="dependencies"></p><blockquote><p>有关架构的详细介绍可以阅读<a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/" target="_blank" rel="noopener">这篇文档</a>。</p></blockquote><p>通过阅读 Argo CD 官方文档我们可以知道 Argo CD 每三分钟轮询一次 Git 存储库，以检测清单的更改。为了消除轮询延迟，Argo CD API server 支持 <a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/#1-create-the-webhook-in-the-git-provider" target="_blank" rel="noopener">配置 Git Webhook</a>。</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><blockquote><p>本文的源码基于2.6.0版本</p></blockquote><h4 id="2-1-main-go-入口函数"><a href="#2-1-main-go-入口函数" class="headerlink" title="2.1 main.go 入口函数"></a>2.1 main.go 入口函数</h4><p>Argo CD 使用 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a> 来构建应用程序。通过 <code>cmd</code> 目录下的 <code>main.go</code> 入口函数，我们可以很轻易的找到每个组件。根据架构可知 API Server 是控制平面中的唯一入口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">command = apiserver.NewCommand()</span><br></pre></td></tr></table></figure><h4 id="2-2-argocd-server"><a href="#2-2-argocd-server" class="headerlink" title="2.2 argocd-server"></a>2.2 argocd-server</h4><p>阅读 <code>ArgoCDServer</code> 实例的 <code>Run</code> 方法，可以发现 <code>ArgoCDServer</code> 使用 <a href="https://github.com/soheilhy/cmux" target="_blank" rel="noopener"><code>cmux</code></a> 库在多路复用，在同一端口上处理标准 HTTP 和 gRPC 请求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">grpcS, appResourceTreeFn := a.newGRPCServer() </span><br><span class="line">grpcWebS := grpcweb.WrapServer(grpcS)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">httpS = a.newHTTPServer(ctx, a.ListenPort, grpcWebS, appResourceTreeFn, listeners.GatewayConn) </span><br><span class="line"></span><br><span class="line">tcpm := cmux.New(listeners.Main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !a.useTLS() &#123;</span><br><span class="line">    httpL = tcpm.Match(cmux.HTTP1Fast())</span><br><span class="line">    grpcL = tcpm.MatchWithWriters(cmux.HTTP2MatchHeaderFieldSendSettings(<span class="string">"content-type"</span>, <span class="string">"application/grpc"</span>))</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a.checkServeErr(<span class="string">"grpcS"</span>, grpcS.Serve(grpcL)) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a.checkServeErr(<span class="string">"httpS"</span>, httpS.Serve(httpL)) &#125;()</span><br></pre></td></tr></table></figure><p>我在官方文档上找到 Argo CD 中如何实现身份验证（authn）和授权（authz）的一张图，可以发现当我们通过 Web 页面或者 CLI 调用 apiserver 的时候首先经过 <code>cmux</code> 检查匹配，如果请求是 http1.x 将由 <code>http mux</code> 处理，如果是 http2 并且 <code>content-type: application/grpc</code> 则由 <code>grpc Server</code> 处理。</p><p><img src="/2023/10/25/cloudnative/argocd_webhook/apiserver.png" alt="apiserver"></p><blockquote><p>由于 Argo CD apiserver 绝大多数的 API 服务是通过 gRPC 实现的，所以这里引入了 gRPC Gateway 来将 gRPC 服务转换为 RESTful API。</p></blockquote><h5 id="2-2-1-ArgoCDWebhookHandler"><a href="#2-2-1-ArgoCDWebhookHandler" class="headerlink" title="2.2.1 ArgoCDWebhookHandler"></a>2.2.1 ArgoCDWebhookHandler</h5><p>从<a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/#1-create-the-webhook-in-the-git-provider" target="_blank" rel="noopener">配置 Git Webhook</a> 中找到 webhook events 的 endpoint 是 /api/webhook 。是走的 http1.x，我们查看 <code>ArgoCDServer</code> 实例的 <code>newHTTPServer</code> 方法，路径为 “/api/webhook” 的 HTTP 请求映射的是 <code>acdWebhookHandler.Handler</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)</span></span><br><span class="line">argoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)</span><br><span class="line">acdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), <span class="number">24</span>*time.Hour, <span class="number">3</span>*time.Minute), a.Cache, argoDB)</span><br><span class="line"></span><br><span class="line">mux.HandleFunc(<span class="string">"/api/webhook"</span>, acdWebhookHandler.Handler)</span><br></pre></td></tr></table></figure><p>继续往下看 <code>ArgoCDWebhookHandler</code> 的 <code>Handle</code> 方法的具体实现，根据请求的 Header 解析得到不同 Git 服务提供商的 Git 事件的数据，然后交给 <code>HandleEvent</code> 方法来处理，<code>HandleEvent</code> 经过一系列的校验检查后执行 <code>RefreshApp</code> 刷新应用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleEvent handles webhook events for repo push events</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *ArgoCDWebhookHandler)</span> <span class="title">HandleEvent</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-RefreshApp"><a href="#2-2-2-RefreshApp" class="headerlink" title="2.2.2 RefreshApp"></a>2.2.2 RefreshApp</h5><p>注释写的很清楚，<code>RefreshApp</code> 通过更新应用的注解，强制控制器处理它。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RefreshApp updates the refresh annotation of an application to coerce the controller to process it</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RefreshApp</span><span class="params">(appIf v1alpha1.ApplicationInterface, name <span class="keyword">string</span>, refreshType argoappv1.RefreshType)</span> <span class="params">(*argoappv1.Application, error)</span></span> &#123;</span><br><span class="line">metadata := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"metadata"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"annotations"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">argoappv1.AnnotationKeyRefresh: <span class="keyword">string</span>(refreshType),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">patch, err := json.Marshal(metadata)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error marshaling metadata: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> attempt := <span class="number">0</span>; attempt &lt; <span class="number">5</span>; attempt++ &#123;</span><br><span class="line">app, err := appIf.Patch(context.Background(), name, types.MergePatchType, patch, metav1.PatchOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !apierr.IsConflict(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error patching annotations in application %q: %w"</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Infof(<span class="string">"Requested app '%s' refresh"</span>, name)</span><br><span class="line"><span class="keyword">return</span> app, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-application-controller"><a href="#2-3-application-controller" class="headerlink" title="2.3 application-controller"></a>2.3 application-controller</h4><p>沿着之前的路径，从入口函数找到应用控制器的实现，appcontroller 中定义了默认的同步周期为180s。控制器通过 <code>newApplicationInformerAndLister</code> 创建 <code>ApplicationInformer</code> 监听应用的事件并加入到队列中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Default time in seconds for application resync period</span></span><br><span class="line">defaultAppResyncPeriod = <span class="number">180</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">resyncDuration = time.Duration(appResyncPeriod) * time.Second</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">appController, err = controller.NewApplicationController(</span><br><span class="line">    namespace,</span><br><span class="line">    settingsMgr,</span><br><span class="line">    kubeClient,</span><br><span class="line">    appClient,</span><br><span class="line">    repoClientset,</span><br><span class="line">    cache,</span><br><span class="line">    kubectl,</span><br><span class="line">    resyncDuration,</span><br><span class="line">    hardResyncDuration,</span><br><span class="line">    time.Duration(selfHealTimeoutSeconds)*time.Second,</span><br><span class="line">    metricsPort,</span><br><span class="line">    metricsCacheExpiration,</span><br><span class="line">    metricsAplicationLabels,</span><br><span class="line">    kubectlParallelismLimit,</span><br><span class="line">    persistResourceHealth,</span><br><span class="line">    clusterFilter,</span><br><span class="line">    applicationNamespaces)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="keyword">go</span> appController.Run(ctx, statusProcessors, operationProcessors)</span><br></pre></td></tr></table></figure><h5 id="2-3-1-newApplicationInformerAndLister"><a href="#2-3-1-newApplicationInformerAndLister" class="headerlink" title="2.3.1 newApplicationInformerAndLister"></a>2.3.1 newApplicationInformerAndLister</h5><p>上文中 <code>RefreshApp</code> 更新应用的注解将会产生一个 Update Event，将会走到 <code>requestAppRefresh</code> 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">informer.AddEventHandler(</span><br><span class="line">    cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                ctrl.appRefreshQueue.Add(key)</span><br><span class="line">                ctrl.appOperationQueue.Add(key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(<span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key, err := cache.MetaNamespaceKeyFunc(<span class="built_in">new</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> compareWith *CompareWith</span><br><span class="line">            oldApp, oldOK := old.(*appv1.Application)</span><br><span class="line">            newApp, newOK := <span class="built_in">new</span>.(*appv1.Application)</span><br><span class="line">            <span class="keyword">if</span> oldOK &amp;&amp; newOK &amp;&amp; automatedSyncEnabled(oldApp, newApp) &#123;</span><br><span class="line">                log.WithField(<span class="string">"application"</span>, newApp.QualifiedName()).Info(<span class="string">"Enabled automated sync"</span>)</span><br><span class="line">                compareWith = CompareWithLatest.Pointer()</span><br><span class="line">            &#125;</span><br><span class="line">            ctrl.requestAppRefresh(newApp.QualifiedName(), compareWith, <span class="literal">nil</span>)</span><br><span class="line">            ctrl.appOperationQueue.Add(key)</span><br><span class="line">        &#125;,</span><br><span class="line">        DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// IndexerInformer uses a delta queue, therefore for deletes we have to use this</span></span><br><span class="line">            <span class="comment">// key function.</span></span><br><span class="line">            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                ctrl.appRefreshQueue.Add(key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="2-3-2-requestAppRefresh"><a href="#2-3-2-requestAppRefresh" class="headerlink" title="2.3.2 requestAppRefresh"></a>2.3.2 requestAppRefresh</h5><p><code>compareWith</code> 是 <code>CompareWithLatest</code>， <code>after</code> 是 <code>nil</code>。requestAppRefresh 方法将会在 <code>appRefreshQueue</code> 和 <code>appOperationQueue</code> 队列中添加该更新事件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestAppRefresh adds a request for given app to the refresh queue. appName</span></span><br><span class="line"><span class="comment">// needs to be the qualified name of the application, i.e. &lt;namespace&gt;/&lt;name&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">requestAppRefresh</span><span class="params">(appName <span class="keyword">string</span>, compareWith *CompareWith, after *time.Duration)</span></span> &#123;</span><br><span class="line">key := ctrl.toAppKey(appName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> compareWith != <span class="literal">nil</span> &amp;&amp; after != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.appComparisonTypeRefreshQueue.AddAfter(fmt.Sprintf(<span class="string">"%s/%d"</span>, key, compareWith), *after)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> compareWith != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.refreshRequestedAppsMutex.Lock()</span><br><span class="line">ctrl.refreshRequestedApps[key] = compareWith.Max(ctrl.refreshRequestedApps[key])</span><br><span class="line">ctrl.refreshRequestedAppsMutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> after != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.appRefreshQueue.AddAfter(key, *after)</span><br><span class="line">ctrl.appOperationQueue.AddAfter(key, *after)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctrl.appRefreshQueue.Add(key)</span><br><span class="line">ctrl.appOperationQueue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-run"><a href="#2-3-3-run" class="headerlink" title="2.3.3 run"></a>2.3.3 run</h5><p>控制器使用两个单独的队列来处理应用的协调（<code>appRefreshQueue</code>）和同步（<code>appOperationQueue</code>），这两个队列分别通过 <code>processAppRefreshQueueItem</code> 和 <code>processAppOperationQueueItem</code> 来处理。</p><blockquote><p><code>statusProcessors</code> 和 <code>operationProcessors</code> 来控制启动协程的数量。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run starts the Application CRD controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, statusProcessors <span class="keyword">int</span>, operationProcessors <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appRefreshQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appComparisonTypeRefreshQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appOperationQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.projectRefreshQueue.ShutDown()</span><br><span class="line"></span><br><span class="line">ctrl.metricsServer.RegisterClustersInfoSource(ctx, ctrl.stateCache)</span><br><span class="line">ctrl.RegisterClusterSecretUpdater(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> ctrl.appInformer.Run(ctx.Done())</span><br><span class="line"><span class="keyword">go</span> ctrl.projInformer.Run(ctx.Done())</span><br><span class="line"></span><br><span class="line">errors.CheckError(ctrl.stateCache.Init())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), ctrl.appInformer.HasSynced, ctrl.projInformer.HasSynced) &#123;</span><br><span class="line">log.Error(<span class="string">"Timed out waiting for caches to sync"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errors.CheckError(ctrl.stateCache.Run(ctx)) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errors.CheckError(ctrl.metricsServer.ListenAndServe()) &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; statusProcessors; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppRefreshQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; operationProcessors; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppOperationQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppComparisonTypeQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processProjectQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-processAppRefreshQueueItem"><a href="#2-3-4-processAppRefreshQueueItem" class="headerlink" title="2.3.4 processAppRefreshQueueItem"></a>2.3.4 processAppRefreshQueueItem</h5><p>从 <code>appRefreshQueue</code> 获取到上文中更新注解的事件后调用 <code>needRefreshAppStatus</code>，<code>needRefresh, refreshType, comparisonLevel = true, RefreshTypeNormal, CompareWithLatestForceResolve</code>。然后通过 <code>CompareAppState</code> 使用指定的版本和提供的源来比较应用程序 git 状态与实时应用程序状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">appKey, shutdown := ctrl.appRefreshQueue.Get()</span><br><span class="line"></span><br><span class="line">obj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line">origApp, ok := obj.(*appv1.Application)</span><br><span class="line"></span><br><span class="line">needRefresh, refreshType, comparisonLevel := ctrl.needRefreshAppStatus(origApp, ctrl.statusRefreshTimeout, ctrl.statusHardRefreshTimeout)</span><br><span class="line"></span><br><span class="line">compareResult := ctrl.appStateManager.CompareAppState(app, project, revisions, sources,</span><br><span class="line">    refreshType == appv1.RefreshTypeHard,</span><br><span class="line">    comparisonLevel == CompareWithLatestForceResolve, localManifests, hasMultipleSources)</span><br></pre></td></tr></table></figure><blockquote><p>上文提到的三分钟定时轮训也是在 needRefreshAppStatus 中实现。</p></blockquote><p><code>CompareAppState</code> 方法中会调用 <code>appStateManager</code> 实例的 <code>getRepoObjs</code> 来获取 Git 仓库中渲染出的清单文件。<code>getRepoObjs</code> 通过 gRPC 调用 reposerver 的 <code>GenerateManifest</code> 方法获取渲染出的清单文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppStateManager defines methods which allow to compare application spec and actual application state.</span></span><br><span class="line"><span class="keyword">type</span> AppStateManager <span class="keyword">interface</span> &#123;</span><br><span class="line">CompareAppState(app *v1alpha1.Application, project *appv1.AppProject, revisions []<span class="keyword">string</span>, sources []v1alpha1.ApplicationSource, noCache <span class="keyword">bool</span>, noRevisionCache <span class="keyword">bool</span>, localObjects []<span class="keyword">string</span>, hasMultipleSources <span class="keyword">bool</span>) *comparisonResult</span><br><span class="line">SyncAppState(app *v1alpha1.Application, state *v1alpha1.OperationState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// repoClientset 初始化后层层传递至 `AppStateManager` 实例中</span></span><br><span class="line">repoClientset := apiclient.NewRepoServerClientset(repoServerAddress, repoServerTimeoutSeconds, tlsConfig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getRepoObjs 通过 gRPC 调用 reposerver 的 GenerateManifest 方法</span></span><br><span class="line">manifestInfo, err := repoClient.GenerateManifest(context.Background(), &amp;apiclient.ManifestRequest&#123;</span><br><span class="line">    Repo:               repo,</span><br><span class="line">    Repos:              permittedHelmRepos,</span><br><span class="line">    Revision:           revisions[i],</span><br><span class="line">    NoCache:            noCache,</span><br><span class="line">    NoRevisionCache:    noRevisionCache,</span><br><span class="line">    AppLabelKey:        appLabelKey,</span><br><span class="line">    AppName:            app.InstanceName(m.namespace),</span><br><span class="line">    Namespace:          app.Spec.Destination.Namespace,</span><br><span class="line">    ApplicationSource:  &amp;source,</span><br><span class="line">    Plugins:            tools,</span><br><span class="line">    KustomizeOptions:   kustomizeOptions,</span><br><span class="line">    KubeVersion:        serverVersion,</span><br><span class="line">    ApiVersions:        argo.APIResourcesToStrings(apiResources, <span class="literal">true</span>),</span><br><span class="line">    VerifySignature:    verifySignature,</span><br><span class="line">    HelmRepoCreds:      permittedHelmCredentials,</span><br><span class="line">    TrackingMethod:     <span class="keyword">string</span>(argo.GetTrackingMethod(m.settingsMgr)),</span><br><span class="line">    EnabledSourceTypes: enabledSourceTypes,</span><br><span class="line">    HelmOptions:        helmOptions,</span><br><span class="line">    HasMultipleSources: app.Spec.HasMultipleSources(),</span><br><span class="line">    RefSources:         refSources,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>得到 <code>compareResult</code> 后会调用 <code>autoSync</code> 方法，如果应用开启了自动同步，将会更新 <code>Application</code> 的 <code>Operation</code> ，来启动同步操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autoSync will initiate a sync operation for an application configured with automated sync</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">autoSync</span><span class="params">(app *appv1.Application, syncStatus *appv1.SyncStatus, resources []appv1.ResourceStatus)</span> *<span class="title">appv1</span>.<span class="title">ApplicationCondition</span></span></span><br></pre></td></tr></table></figure><p><code>processAppRefreshQueueItem</code> 最后将会调用 <code>persistAppStatus</code> 方法用于持久化，通过调用 k8s api 更新 applicaition 的 status。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// persistAppStatus persists updates to application status. If no changes were made, it is a no-op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">persistAppStatus</span><span class="params">(orig *appv1.Application, newStatus *appv1.ApplicationStatus)</span></span> </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 2.3.5 processAppOperationQueueItem</span></span><br><span class="line"><span class="string">跟 `</span>processAppRefreshQueueItem<span class="string">` 类似，从 `</span>appOperationQueue<span class="string">` 队列中拿到待执行同步操作的应用实例，判断该应用的 `</span>Operation<span class="string">` 字段是否为空，如果不为空则执行 `</span>processRequestedAppOperation<span class="string">`。`</span>processRequestedAppOperation<span class="string">` 也会进行一些状态校验，比如是否正在同步中等，最终应用下资源的同步将由 `</span>appStateManager<span class="string">` 实例的 `</span>SyncAppState<span class="string">` 实现。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">processRequestedAppOperation</span><span class="params">(app *appv1.Application)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> err := argo.ValidateDestination(context.Background(), &amp;app.Spec.Destination, ctrl.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">state.Phase = synccommon.OperationFailed</span><br><span class="line">state.Message = err.Error()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctrl.appStateManager.SyncAppState(app, state)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *appStateManager)</span> <span class="title">SyncAppState</span><span class="params">(app *v1alpha1.Application, state *v1alpha1.OperationState)</span></span> &#123;</span><br><span class="line"><span class="comment">// Sync requests might be requested with ambiguous revisions (e.g. master, HEAD, v1.2.3).</span></span><br><span class="line"><span class="comment">// This can change meaning when resuming operations (e.g a hook sync). After calculating a</span></span><br><span class="line"><span class="comment">// concrete git commit SHA, the SHA is remembered in the status.operationState.syncResult field.</span></span><br><span class="line"><span class="comment">// This ensures that when resuming an operation, we sync to the same revision that we initially</span></span><br><span class="line"><span class="comment">// started with.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    syncCtx, cleanup, err := sync.NewSyncContext(</span><br><span class="line">compareResult.syncStatus.Revision,</span><br><span class="line">reconciliationResult,</span><br><span class="line">restConfig,</span><br><span class="line">rawConfig,</span><br><span class="line">m.kubectl,</span><br><span class="line">app.Spec.Destination.Namespace,</span><br><span class="line">openAPISchema,</span><br><span class="line">opts...,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">state.Phase = common.OperationError</span><br><span class="line">state.Message = fmt.Sprintf(<span class="string">"failed to initialize sync context: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> cleanup()</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> state.Phase == common.OperationTerminating &#123;</span><br><span class="line">syncCtx.Terminate()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">syncCtx.Sync()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/argoproj/argo-cd/blob/6e2f2c9d1e2339b3361f3a057747fcfe30e36f44/controller/sync.go#L296" target="_blank" rel="noopener"><code>syncCtx</code></a> 我们这里看接口定义大致了解即可，具体实现这里就不再展开了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyncContext defines an interface that allows to execute sync operation step or terminate it.</span></span><br><span class="line"><span class="keyword">type</span> SyncContext <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Terminate terminates sync operation. The method is asynchronous: it starts deletion is related K8S resources</span></span><br><span class="line"><span class="comment">// such as in-flight resource hooks, updates operation status, and exists without waiting for resource completion.</span></span><br><span class="line">Terminate()</span><br><span class="line"><span class="comment">// Executes next synchronization step and updates operation status.</span></span><br><span class="line">Sync()</span><br><span class="line"><span class="comment">// Returns current sync operation state and information about resources synchronized so far.</span></span><br><span class="line">GetState() (common.OperationPhase, <span class="keyword">string</span>, []common.ResourceSyncResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <a href="https://github.com/argoproj/gitops-engine/blob/master/pkg/sync/sync_context.go" target="_blank" rel="noopener">SyncContext</a> 是由 <code>gitops-engine</code> 库实现。</p></blockquote><h3 id="3-源码流程图"><a href="#3-源码流程图" class="headerlink" title="3. 源码流程图"></a>3. 源码流程图</h3><p><img src="/2023/10/25/cloudnative/argocd_webhook/request.png" alt="request"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>自动同步是 Argo CD 的核心功能，了解其底层实现原理和源码有助于拓展技术视野，深入理解 Argo CD 的工作原理，并在遇到问题时提供解决方案。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/authz-authn/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/authz-authn/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Argo CD 的自动同步功能通过监控 Git 仓库中的更改来自动部署和更新应用程序。这确保了 Kubernetes 集群中的应用程序始终与 Git 仓库中的配置保持一致。开发团队只需将应用程序的描述和配置存储在 Git 仓库中，Argo CD 会根据这些信息自动部署和更新应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
  </entry>
  
  <entry>
    <title>AntV G6 实现 k8s 资源拓扑图展示</title>
    <link href="https://blazehu.github.io/2023/01/30/common/g6_tree_demo/"/>
    <id>https://blazehu.github.io/2023/01/30/common/g6_tree_demo/</id>
    <published>2023-01-29T16:00:00.000Z</published>
    <updated>2023-11-03T03:53:36.056Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AntV G6 实现类似 <code>argocd</code> 资源拓扑图的树图。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文主要记录总结如何使用 AntV G6 来展示 k8s 的资源拓扑图，下文简单实现一个 helm 部署 zookeeper 的图例，<a href="https://github.com/blazehu/g6-tree-demo" target="_blank" rel="noopener">代码地址</a> 。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里使用 vue2 来快速搭建一个页面，对 vue 熟悉的可以略过。 相关版本如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BLAZEHU-MB:Projects $ node --version</span><br><span class="line">v14.16.0</span><br><span class="line">BLAZEHU-MB:Projects $ vue --version</span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create g6-tree-demo</span><br></pre></td></tr></table></figure><p>官方快速上手文档：<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application" target="_blank" rel="noopener">https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application</a></p><h4 id="安装-amp-引用-G6"><a href="#安装-amp-引用-G6" class="headerlink" title="安装 &amp; 引用 G6"></a>安装 &amp; 引用 G6</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install --save @antv/g6</span><br></pre></td></tr></table></figure><p>官方快速上手文档：<a href="https://g6.antv.antgroup.com/manual/getting-started" target="_blank" rel="noopener">https://g6.antv.antgroup.com/manual/getting-started</a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h4><p>文件地址：common/index.js，参考官方 <a href="https://github.com/antvis/G6/blob/142e9eaeb8812d2b4770243bd3999166e076cdb3/packages/element/src/nodes/modelRect.ts" target="_blank" rel="noopener">modelRect</a> 内置节点源码。</p><h4 id="拓扑图实现逻辑"><a href="#拓扑图实现逻辑" class="headerlink" title="拓扑图实现逻辑"></a>拓扑图实现逻辑</h4><p>文件地址：components/DemoTree.vue，下面简单介绍：</p><ol><li>页面挂载后注册自定义元素 <code>执行 register 函数，后面简写为函数名</code>，初始化拓扑图 <code>initTree</code>。</li><li>初始化拓扑图首先准备数据 <code>initData</code>，然后创建拓扑图 <code>createTree</code>。</li><li>配置数据源，渲染 <code>data、render</code>。</li><li>更新数据使用 changeData 函数。</li></ol><blockquote><p>NOTE: id 如果不更新 changeData 页面刷新不完全，不能识别到node节点的变化。</p></blockquote><p>最终实现效果如下：<br><img src="/2023/01/30/common/g6_tree_demo/demo.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上文简单介绍了如何使用G6来绘制拓扑图，要实现类似 <code>argocd</code> 前端页面的效果我们还需要做节点折叠、节点菜单、节点标签展示等等，后续作者也在陆续完善。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://g6.antv.antgroup.com/manual/faq/performance-opt" target="_blank" rel="noopener">http://g6.antv.antgroup.com/manual/faq/performance-opt</a></li><li><a href="http://g6.antv.antgroup.com/zh/examples/scatter/node/#node" target="_blank" rel="noopener">http://g6.antv.antgroup.com/zh/examples/scatter/node/#node</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 AntV G6 实现类似 &lt;code&gt;argocd&lt;/code&gt; 资源拓扑图的树图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="g6" scheme="https://blazehu.github.io/tags/g6/"/>
    
  </entry>
  
  <entry>
    <title>Server-Sent Events (SSE)</title>
    <link href="https://blazehu.github.io/2022/10/30/cloudnative/argocd_sse/"/>
    <id>https://blazehu.github.io/2022/10/30/cloudnative/argocd_sse/</id>
    <published>2022-10-29T16:00:00.000Z</published>
    <updated>2023-11-03T06:35:39.442Z</updated>
    
    <content type="html"><![CDATA[<p>服务器发送事件 (SSE) 是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新，并描述了在建立初始客户端连接后服务器如何向客户端发起数据传输。</p><a id="more"></a><p><img src="/2022/10/30/cloudnative/argocd_sse/image.png" alt="image"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Server-sent_events</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;服务器发送事件 (SSE) 是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新，并描述了在建立初始客户端连接后服务器如何向客户端发起数据传输。&lt;/p&gt;</summary>
    
    
    
    
    <category term="g6" scheme="https://blazehu.github.io/tags/g6/"/>
    
  </entry>
  
  <entry>
    <title>服务上云后如何使用 perf 生成火焰图</title>
    <link href="https://blazehu.github.io/2022/09/14/cloudnative/perf_analyse/"/>
    <id>https://blazehu.github.io/2022/09/14/cloudnative/perf_analyse/</id>
    <published>2022-09-13T16:00:00.000Z</published>
    <updated>2022-09-16T13:02:48.201Z</updated>
    
    <content type="html"><![CDATA[<p>业务上云迁移至腾讯云 Serverless 集群后，使用<code>perf</code>生成服务器的火焰图。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>业务模块使用的基础镜像是<code>Ubuntu20.04</code>，上云前的做法是在机器上docker run的，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --cap-add CAP_SYS_ADMIN --privileged=true --pid=container:$&#123;targetContainerId&#125; --network=container:$&#123;targetContainerId&#125; $&#123;image&#125;:$&#123;imageTag&#125; -ti ...</span><br></pre></td></tr></table></figure><p>上云后通过在 Pod 中的容器之间共享进程命名空间的方式实现，在业务Pod中注入一个用于<code>perf</code>分析的容器。</p><h3 id="安装-perf"><a href="#安装-perf" class="headerlink" title="安装 perf"></a>安装 perf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install linux-tools-generic</span><br><span class="line">ln -s /usr/lib/linux-tools/5.4.0-125-generic/perf /usr/bin/perf</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>安装 linux-tools-generic 完成后，需要建立软链接，不然查看 <code>perf</code>版本，会提示如下报错信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf</span><br><span class="line">WARNING: perf not found for kernel 5.4.119-1</span><br><span class="line"></span><br><span class="line">  You may need to install the following packages for this specific kernel:</span><br><span class="line">    linux-tools-5.4.119-1-tlinux4-0009-public-eks</span><br><span class="line">    linux-cloud-tools-5.4.119-1-tlinux4-0009-public-eks</span><br><span class="line"></span><br><span class="line">  You may also want to install one of the following packages to keep up to date:</span><br><span class="line">    linux-tools-tlinux4-0009-public-eks</span><br><span class="line">    linux-cloud-tools-tlinux4-0009-public-eks</span><br></pre></td></tr></table></figure><blockquote><p>这里报错其实是因为<code>perf</code>已经内置在<code>linux-tools-generic</code>里面，所以我们安装后创建<code>perf</code>软链接即可（5.4.0-125-generic 版本目录根据实际情况替换即可）。</p></blockquote><h3 id="使用-perf-生成火焰图"><a href="#使用-perf-生成火焰图" class="headerlink" title="使用 perf 生成火焰图"></a>使用 perf 生成火焰图</h3><h4 id="pod-共享进程命名空间"><a href="#pod-共享进程命名空间" class="headerlink" title="pod 共享进程命名空间"></a>pod 共享进程命名空间</h4><p>使用 Pod <code>.spec</code> 中的 <code>shareProcessNamespace</code> 字段可以启用进程命名空间共享，官方例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  shareProcessNamespace: true</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    securityContext:</span><br><span class="line">      capabilities:</span><br><span class="line">        add:</span><br><span class="line">        - SYS_PTRACE</span><br><span class="line">      privileged: true</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>我们需要在 <code>perf</code> 容器中分析业务容器 <code>gamesvr</code>，这个操作需要 SYS_PTRACE 权能。所以我们需要为 <code>perf</code> Container 设置权能。通过安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。</p><p>这里列举部分能力：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CAP_SYS_MODULE: 允许插入和删除内核模块</span><br><span class="line">CAP_SYS_RAWIO:  允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备</span><br><span class="line">CAP_SYS_CHROOT: 允许使用chroot()系统调用</span><br><span class="line">CAP_SYS_PTRACE: 允许跟踪任何进程</span><br><span class="line">CAP_SYS_PACCT:  允许执行进程的BSD式审计</span><br></pre></td></tr></table></figure><p>我们使用 <code>perf</code>来分析业务进程，所以需要 CAP_SYS_PTRACE 权能。</p><blockquote><p>Linux Capabilities 的定义的形式为 CAP_XXX。但是你在 Container 字段使用时，需要将名称中的 CAP_ 部分去掉。例如，要添加 CAP_SYS_PTRACE，可在 capabilities 列表中添加 SYS_PTRACE。</p></blockquote><h4 id="perf-容器注入"><a href="#perf-容器注入" class="headerlink" title="perf 容器注入"></a>perf 容器注入</h4><p>我这里工作负载是使用的 deployment，通过 openkruise sidecarset 注入，这里就不赘述。注入完成后我们 exec 进入 perf 容器，执行 <code>ps -ef</code> 可以看到业务容器的进程 <code>gamesvr</code> 的进程ID是13。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">root@</span>game-server<span class="number">-6</span><span class="number">-6f</span>446dcxxx<span class="number">-5</span>j45b:~# ps -ef </span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /pause</span><br><span class="line">root          <span class="number">13</span>       <span class="number">0</span>  <span class="number">6</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">02</span>:<span class="number">37</span> /root/example/bin/gamesvr</span><br><span class="line">root          <span class="number">26</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> sleep <span class="number">9</span>d</span><br><span class="line">root         <span class="number">786</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">02</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /bin/bash</span><br><span class="line">root         <span class="number">855</span>     <span class="number">842</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">11</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps -ef</span><br></pre></td></tr></table></figure><h4 id="perf-分析"><a href="#perf-分析" class="headerlink" title="perf 分析"></a>perf 分析</h4><p>执行 <code>perf record -F 99 -g -m 1 -p ${targetContainerId} -- sleep 120</code>，targetContainerId 是业务进程ID。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf record -F 99 -g -m 1 -p 13 -- sleep 120</span><br><span class="line">[ perf record: Woken up 65 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.148 MB perf.data (524 samples) ]</span><br></pre></td></tr></table></figure><p>查看分析文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><p>生成火焰图，这里会用到<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">火焰图工具</a>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl &gt; demo.svg</span><br></pre></td></tr></table></figure><p>这里生成的 demo.svg 就是我们需要的火焰图（下面是一个例图）。开发可以通过火焰图来查看看服务的性能热点。</p><p><img src="/2022/09/14/cloudnative/perf_analyse/flame.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里协助开发使用 <code>perf</code> 生成火焰图的过程中遇到了2个问题，一是安装 <code>perf</code> 装不上报错，二是由于 <code>perf</code> 容器没有 SYS_PTRACE 权能导致生成的分析数据没有函数名称（只有地址信息）。通过协助排查问题加深了对 k8s Security Context的理解。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/</a></li><li><a href="https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html" target="_blank" rel="noopener">https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html</a></li><li><a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">https://github.com/brendangregg/FlameGraph</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;业务上云迁移至腾讯云 Serverless 集群后，使用&lt;code&gt;perf&lt;/code&gt;生成服务器的火焰图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="perf" scheme="https://blazehu.github.io/tags/perf/"/>
    
    <category term="ubuntu" scheme="https://blazehu.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04 安装 perf 报错</title>
    <link href="https://blazehu.github.io/2022/09/13/common/ubuntu_install_perf/"/>
    <id>https://blazehu.github.io/2022/09/13/common/ubuntu_install_perf/</id>
    <published>2022-09-12T16:00:00.000Z</published>
    <updated>2022-09-16T11:45:36.334Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>尝试安装<code>perf</code>生成服务器的火焰图，安装<code>perf</code>后报错，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install linux-tools-generic</span><br></pre></td></tr></table></figure><p>安装完成后查看<code>perf</code>版本，发现报错如下<br><img src="/2022/09/13/common/ubuntu_install_perf/perf_error_1.png" alt="perf_error_1.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实<code>perf</code>已经内置在<code>linux-tools-generic</code>里面，所以安装后创建<code>perf</code>软链接即可（5.4.0-125-generic 版本目录根据实际情况替换即可）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/lib/linux-tools/5.4.0-125-generic/perf /usr/bin/perf</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;尝试安装&lt;code&gt;perf&lt;/code&gt;生成服务器的火焰图，安装&lt;code&gt;perf&lt;/code&gt;后报错</summary>
      
    
    
    
    
    <category term="perf" scheme="https://blazehu.github.io/tags/perf/"/>
    
    <category term="ubuntu" scheme="https://blazehu.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾插件问题排查小记</title>
    <link href="https://blazehu.github.io/2022/08/21/common/ipapk_failed/"/>
    <id>https://blazehu.github.io/2022/08/21/common/ipapk_failed/</id>
    <published>2022-08-20T16:00:00.000Z</published>
    <updated>2024-02-19T08:33:09.679Z</updated>
    
    <content type="html"><![CDATA[<p>2021年给开发商做了一个<a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>，最近开发商反馈当上传的文件比较大时经常失败。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>用户报障说蓝盾插件使用经常失败。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="1-插件侧报错-OverflowError-string-longer-than-2147483647-bytes"><a href="#1-插件侧报错-OverflowError-string-longer-than-2147483647-bytes" class="headerlink" title="1. 插件侧报错: OverflowError: string longer than 2147483647 bytes"></a>1. 插件侧报错: OverflowError: string longer than 2147483647 bytes</h4><p>报错日志内容如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">202</span> : OverflowError: <span class="built_in">string</span> longer than <span class="number">2147483647</span> bytes</span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">362</span> : ##[error] </span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">362</span> : Fail to run the plugin because of error(Process exited with an error: <span class="number">1</span>)</span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">364</span> : ##[warning]No output</span><br></pre></td></tr></table></figure><p>日志报错分析：该插件是用来上传文件的，使用 <code>requests</code> 库来上传文件，这里报错信息是说明插件上传的文件太大。之前没有考虑到文件太大的情况。</p><h4 id="2-问题一修复后偶尔报错超时504"><a href="#2-问题一修复后偶尔报错超时504" class="headerlink" title="2. 问题一修复后偶尔报错超时504"></a>2. 问题一修复后偶尔报错超时504</h4><p><img src="/2022/08/21/common/ipapk_failed/img.png" alt="img.png"></p><p>日志报错分析：插件日志504，重试了3次。查看后端服务日志发现业务逻辑正常处理完毕，但是请求返回时 <code>write: broken pipe</code>。这里的报错可以基本判断是由于请求处理时间过长，当后端服务返回时 CLB 已经断开了连接。</p><h5 id="请求调用链路"><a href="#请求调用链路" class="headerlink" title="请求调用链路"></a>请求调用链路</h5><p>蓝盾插件 -&gt; 腾讯云CLB -&gt; 后端服务（CVM上跑的docker）</p><h5 id="腾讯云CLB监控"><a href="#腾讯云CLB监控" class="headerlink" title="腾讯云CLB监控"></a>腾讯云CLB监控</h5><p><img src="/2022/08/21/common/ipapk_failed/timeout.png" alt="timeout.png"></p><p>排查到这里可以确定问题根因：CLB 的超时导致的504。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-插件上传报错解决方案"><a href="#1-插件上传报错解决方案" class="headerlink" title="1. 插件上传报错解决方案"></a>1. 插件上传报错解决方案</h4><p>插件侧优化代码使用 <code>requests-toolbelt</code> 上传文件。同时修改 <a href="https://cloud.tencent.com/document/product/214/15171" target="_blank" rel="noopener">CLB个性化配置</a> 支持超过2G的大文件上传，不缓存客户端请求体。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">5120M</span>;</span><br><span class="line"><span class="attribute">proxy_request_buffering</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">900s</span>;</span><br></pre></td></tr></table></figure><h4 id="2-超时问题解决方案"><a href="#2-超时问题解决方案" class="headerlink" title="2. 超时问题解决方案"></a>2. 超时问题解决方案</h4><p>修改 <a href="https://cloud.tencent.com/document/product/214/15171" target="_blank" rel="noopener">CLB个性化配置</a> ，修改超时设置。这里主要修改 <code>proxy_read_timeout</code>。</p><blockquote><p>NOTE: proxy_read_timeout 是控制 CLB 至后端服务之间的超时时间。</p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">900s</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年给开发商做了一个&lt;a href=&quot;https://docs.bkci.net/services/client-experience&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端版本体验&lt;/a&gt;，最近开发商反馈当上传的文件比较大时经常失败。&lt;/p&gt;</summary>
    
    
    
    
    <category term="腾讯云" scheme="https://blazehu.github.io/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="ipapk" scheme="https://blazehu.github.io/tags/ipapk/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Webhook 开发之创建 TLS 证书</title>
    <link href="https://blazehu.github.io/2022/08/16/cloudnative/k8s_csr_tls/"/>
    <id>https://blazehu.github.io/2022/08/16/cloudnative/k8s_csr_tls/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2022-10-08T08:26:10.264Z</updated>
    
    <content type="html"><![CDATA[<p>在编写一个准入 Webhook 服务时，需要配置相关证书，k8s 提供了 api 用于对用户自主创建的证书进行认证签发。以下部分演示为 Webhook 服务创建 TLS 证书。</p><a id="more"></a><h3 id="创建-TLS-证书"><a href="#创建-TLS-证书" class="headerlink" title="创建 TLS 证书"></a>创建 TLS 证书</h3><h4 id="创建你的证书"><a href="#创建你的证书" class="headerlink" title="创建你的证书"></a>创建你的证书</h4><p>通过运行以下命令生成私钥:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | cfssl genkey - | cfssljson -bare server</span><br><span class="line">&#123;</span><br><span class="line">  "hosts": [</span><br><span class="line">    "my-svc.my-namespace.svc.cluster.local",</span><br><span class="line">    "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">    "192.0.2.24",</span><br><span class="line">    "10.0.34.2"</span><br><span class="line">  ],</span><br><span class="line">  "CN": "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "ecdsa",</span><br><span class="line">    "size": 256</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>此命令生成两个文件；它生成包含 PEM 编码 PKCS#10 证书请求的 <code>server.csr</code>， 以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p><h4 id="创建证书签名请求（CSR）"><a href="#创建证书签名请求（CSR）" class="headerlink" title="创建证书签名请求（CSR）"></a>创建证书签名请求（CSR）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: certificates.k8s.io/v1beta1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  request: $(cat server.csr | base64 | tr -d '\n')</span><br><span class="line">  usages:</span><br><span class="line">  - digital signature</span><br><span class="line">  - key encipherment</span><br><span class="line">  - server auth</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>你能看到的输出类似于：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certificatesigningrequest.certificates.k8s.io/example created</span><br></pre></td></tr></table></figure><blockquote><p>Warning: certificates.k8s.io/v1beta1 CertificateSigningRequest is deprecated in v1.19+, unavailable in v1.22+; use certificates.k8s.io/v1 CertificateSigningRequest</p></blockquote><p>CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE   SIGNERNAME                     REQUESTOR                 CONDITION</span><br><span class="line">example   17s   kubernetes.io/legacy-unknown   100015926370-1650441195   Pending</span><br></pre></td></tr></table></figure><h4 id="批准证书签名请求（CSR）"><a href="#批准证书签名请求（CSR）" class="headerlink" title="批准证书签名请求（CSR）"></a>批准证书签名请求（CSR）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl certificate approve example</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certificatesigningrequest.certificates.k8s.io/example approved</span><br></pre></td></tr></table></figure><p>你现在应该能看到如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE    SIGNERNAME                     REQUESTOR                 CONDITION</span><br><span class="line">example   5m4s   kubernetes.io/legacy-unknown   100015926370-1650441195   Approved,Issued</span><br></pre></td></tr></table></figure><h4 id="下载证书并使用它"><a href="#下载证书并使用它" class="headerlink" title="下载证书并使用它"></a>下载证书并使用它</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr example -o jsonpath='&#123;.status.certificate&#125;' | base64 --decode &gt; server.crt</span><br></pre></td></tr></table></figure><p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 作为你的服务的 https 认证了。</p><p>例如 <code>kubebuilder</code> 中使用 TLS 证书，将 <code>server.crt</code> 和 <code>server-key.pem</code> 放在 <code>cert</code> 目录中并修改名称为 <code>tls.crt</code> 和 <code>tls.key</code>，然后指定证书目录：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">Scheme:                 scheme,</span><br><span class="line">MetricsBindAddress:     metricsAddr,</span><br><span class="line">Port:                   <span class="number">9443</span>,</span><br><span class="line">HealthProbeBindAddress: probeAddr,</span><br><span class="line">LeaderElection:         enableLeaderElection,</span><br><span class="line">LeaderElectionID:       <span class="string">"27e1b0af.blazehu.com"</span>,</span><br><span class="line">CertDir:                <span class="string">"./cert/"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="从-v1beta1-迁移到-v1"><a href="#从-v1beta1-迁移到-v1" class="headerlink" title="从 v1beta1 迁移到 v1"></a>从 v1beta1 迁移到 v1</h3><p>上述例子使用 <code>certificates.k8s.io/v1beta1</code> API 版本的 <code>CertificateSigningRequest</code> 不在 v1.22 版本中继续提供。<a href="https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/" target="_blank" rel="noopener">官方迁移指南</a>点这里。 我们可以使用 <code>certificates.k8s.io/v1</code> API 版本，此 API 从 v1.19 版本开始可用。</p><ul><li><code>certificates.k8s.io/v1</code> 中需要额外注意的变更：<ul><li>对于请求证书的 API 客户端而言：<ul><li><code>spec.signerName</code> 现在变成必需字段（参阅 <a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers" target="_blank" rel="noopener">已知的 Kubernetes 签署者</a>）， 并且通过 <code>certificates.k8s.io/v1</code> API 不可以创建签署者为 <code>kubernetes.io/legacy-unknown</code> 的请求</li><li><code>spec.usages</code> 现在变成必需字段，其中不可以包含重复的字符串值， 并且只能包含已知的用法字符串</li></ul></li></ul></li></ul><h4 id="创建你的证书-1"><a href="#创建你的证书-1" class="headerlink" title="创建你的证书"></a>创建你的证书</h4><p>通过运行以下命令生成私钥:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | cfssl genkey - | cfssljson -bare server</span><br><span class="line">&#123;</span><br><span class="line">  "hosts": [</span><br><span class="line">    "my-svc.my-namespace.svc.cluster.local",</span><br><span class="line">    "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">    "192.0.2.24",</span><br><span class="line">    "10.0.34.2"</span><br><span class="line">  ],</span><br><span class="line">  "CN": "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "ecdsa",</span><br><span class="line">    "size": 256</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="创建证书签名请求（CSR）-1"><a href="#创建证书签名请求（CSR）-1" class="headerlink" title="创建证书签名请求（CSR）"></a>创建证书签名请求（CSR）</h4><p>这里 csr signerName 不能是 <code>kubernetes.io/legacy-unknown</code>，演示我们随便指定一个为 <code>example.com/serving</code>，v1beta1 版本默认是 <code>kubernetes.io/legacy-unknown</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: certificates.k8s.io/v1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  request: $(cat server.csr | base64 | tr -d '\n')</span><br><span class="line">  signerName: example.com/serving</span><br><span class="line">  usages:</span><br><span class="line">  - digital signature</span><br><span class="line">  - key encipherment</span><br><span class="line">  - server auth</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="批准证书签名请求（CSR）-1"><a href="#批准证书签名请求（CSR）-1" class="headerlink" title="批准证书签名请求（CSR）"></a>批准证书签名请求（CSR）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl certificate approve example</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certificatesigningrequest.certificates.k8s.io/example approved</span><br></pre></td></tr></table></figure><p>你现在应该能看到如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE   SIGNERNAME            REQUESTOR                 CONDITION</span><br><span class="line">example   11s   example.com/serving   100015926370-1650441195   Approved</span><br></pre></td></tr></table></figure><p>这里可以看到证书请求已被批准，但是没有自动签名，正在等待请求的签名者对其签名。</p><h4 id="签名证书签名请求（CSR）"><a href="#签名证书签名请求（CSR）" class="headerlink" title="签名证书签名请求（CSR）"></a>签名证书签名请求（CSR）</h4><p>我们扮演证书签署者的角色，颁发证书并将其上传到 API 服务器。</p><h5 id="创建证书颁发机构"><a href="#创建证书颁发机构" class="headerlink" title="创建证书颁发机构"></a>创建证书颁发机构</h5><p>通过运行以下命令创建签名证书:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca</span><br><span class="line">&#123;</span><br><span class="line">  "CN": "example.com/serving",</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "rsa",</span><br><span class="line">    "size": 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这会产生一个证书颁发机构密钥文件（<code>ca-key.pem</code>）和证书（<code>ca.pem</code>）。</p><h5 id="颁发证书"><a href="#颁发证书" class="headerlink" title="颁发证书"></a>颁发证书</h5><p>创建文件 <code>server-signing-config.json</code> 内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"signing"</span>: &#123;</span><br><span class="line">    <span class="attr">"default"</span>: &#123;</span><br><span class="line">      <span class="attr">"usages"</span>: [</span><br><span class="line">        <span class="string">"digital signature"</span>,</span><br><span class="line">        <span class="string">"key encipherment"</span>,</span><br><span class="line">        <span class="string">"server auth"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"expiry"</span>: <span class="string">"876000h"</span>,</span><br><span class="line">      <span class="attr">"ca_constraint"</span>: &#123;</span><br><span class="line">        <span class="attr">"is_ca"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>server-signing-config.json</code> 签名配置、证书颁发机构密钥文件和证书来签署证书请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr example -o jsonpath='&#123;.spec.request&#125;' | \</span><br><span class="line">  base64 --decode | \</span><br><span class="line">  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | \</span><br><span class="line">  cfssljson -bare ca-signed-server</span><br></pre></td></tr></table></figure><p>这会生成一个签名的服务证书文件，<code>ca-signed-server.pem</code>。</p><h5 id="上传签名证书"><a href="#上传签名证书" class="headerlink" title="上传签名证书"></a>上传签名证书</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr example -o json | \</span><br><span class="line">  jq '.status.certificate = "'$(base64 ca-signed-server.pem | tr -d '\n')'"' | \</span><br><span class="line">  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/example/status -f -</span><br></pre></td></tr></table></figure><p>批准 CSR 并上传签名证书后，你现在应该能看到如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE   SIGNERNAME            REQUESTOR                 CONDITION</span><br><span class="line">example   10m   example.com/serving   100015926370-1650441195   Approved,Issued</span><br></pre></td></tr></table></figure><p>这是你可以正常下载证书并使用它了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/#configuring-your-cluster-to-provide-signing" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/#configuring-your-cluster-to-provide-signing</a></li><li><a href="https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在编写一个准入 Webhook 服务时，需要配置相关证书，k8s 提供了 api 用于对用户自主创建的证书进行认证签发。以下部分演示为 Webhook 服务创建 TLS 证书。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Watching Resources</title>
    <link href="https://blazehu.github.io/2022/07/08/cloudnative/kubebuilder_watch_resource/"/>
    <id>https://blazehu.github.io/2022/07/08/cloudnative/kubebuilder_watch_resource/</id>
    <published>2022-07-07T16:00:00.000Z</published>
    <updated>2022-08-12T10:16:57.584Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发过程中，可能需要开发一个类似<code>Deployment</code>的资源逻辑，管理依赖资源是控制器的基础，如果不能观察它们的状态变化就不可能管理它们。这就意味着，我们需要 <code>reconciler</code> 能监控多个资源的变化。</p><a id="more"></a><blockquote><p>NOTE: <code>Deployment</code> 必须知道其管理的 <code>ReplicaSet</code> 何时更改，<code>ReplicaSet</code> 必须知道其管理的 <code>Pod</code> 何时被删除，或者从健康变为不健康等。</p></blockquote><p>控制器运行时库为管理和监视资源提供了多种方式。这包括从简单而明显的用例（例如查看由控制器创建和管理的资源）到更独特和更高级的用例。</p><ul><li>控制器创建和管理的资源 (Watching Operator Managed Resources)</li><li>外部管理的资源 (Watching Externally Managed Resources)</li></ul><br><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>以 <code>Tcaplus</code> 资源为例，<code>Tcaplus</code> 资源通过 <code>ConfigMap</code>（proto 文件）来创建表格。当 <code>ConfigMap</code> 发生变化时自动更新表格，下面例子不实际调用腾讯云API，只要验证接收到事件请求即可。</p><blockquote><p>NOTE: <code>TcaplusDB</code> 是腾讯出品的分布式NoSQL数据库。官方API文档：<a href="https://cloud.tencent.com/document/product/596/39648。" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/596/39648。</a></p></blockquote><br><h3 id="控制器创建和管理的资源"><a href="#控制器创建和管理的资源" class="headerlink" title="控制器创建和管理的资源"></a>控制器创建和管理的资源</h3><h4 id="资源定义-Defined-Tcaplus-Resources"><a href="#资源定义-Defined-Tcaplus-Resources" class="headerlink" title="资源定义 (Defined Tcaplus Resources)"></a>资源定义 (Defined Tcaplus Resources)</h4><p><strong>api/v1/tcaplus_types.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TcaplusSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Checksum          <span class="keyword">string</span>             <span class="string">`json:"checksum,omitempty"`</span></span><br><span class="line">ConfigMapTemplate ConfigMapTemplate  <span class="string">`json:"configMapTemplate,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigMapTemplate <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span>            <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">Data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"data,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制器逻辑-Manage-the-Owned-Resource"><a href="#控制器逻辑-Manage-the-Owned-Resource" class="headerlink" title="控制器逻辑 (Manage the Owned Resource)"></a>控制器逻辑 (Manage the Owned Resource)</h4><p><strong>controllers/tcaplus_controller.go</strong><br>当 <code>tcaplus</code> CR 创建时根据 <code>ConfigMapTemplate</code> 创建附属的 <code>ConfigMap</code> 资源并设置<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/" target="_blank" rel="noopener">属主关系</a>。</p><ul><li><code>Reconcile</code> 方法：根据模版创建 <code>ConfigMap</code> 并设置属主关系</li><li><code>SetupWithManager</code> 方法：<code>For</code> 方法之后调用 <code>Owns</code> 方法<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">Reconcile</span><span class="params">(ctx context.Context, req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> &#123;</span><br><span class="line">logger := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">"reconciling"</span>)</span><br><span class="line">tcaplus := &amp;examplev1.Tcaplus&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, tcaplus); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configMap := &amp;corev1.ConfigMap&#123;&#125;</span><br><span class="line">configMap.Name = tcaplus.Spec.ConfigMapTemplate.Name</span><br><span class="line">configMap.Namespace = tcaplus.Namespace</span><br><span class="line">configMap.Data = tcaplus.Spec.ConfigMapTemplate.Data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> err := controllerutil.SetControllerReference(tcaplus, configMap, r.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">"get configmap failed"</span>, <span class="string">"configmap"</span>, configMap.Name)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foundConfigMap := &amp;corev1.ConfigMap&#123;&#125;</span><br><span class="line">err := r.Get(ctx, types.NamespacedName&#123;Name: configMap.Name, Namespace: tcaplus.Namespace&#125;, foundConfigMap)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; errors.IsNotFound(err) &#123;</span><br><span class="line">logger.V(<span class="number">1</span>).Info(<span class="string">"creating configmap"</span>, <span class="string">"configmap"</span>, configMap.Name)</span><br><span class="line">err = r.Create(ctx, configMap)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupWithManager sets up the controller with the Manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">SetupWithManager</span><span class="params">(mgr ctrl.Manager)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;examplev1.Tcaplus&#123;&#125;).</span><br><span class="line">Owns(&amp;corev1.ConfigMap&#123;&#125;).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE：同一控制器创建的资源才可以设置属主关系，不然会提示：already owned by another controller。</p></blockquote></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>config/samples/example_v1_tcaplus.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.blazehu.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Tcaplus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">checksum:</span> <span class="string">"123"</span></span><br><span class="line">  <span class="attr">configMapTemplate:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"tcaplus-configmap-example"</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="attr">demo.proto:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">syntax</span> <span class="string">=</span> <span class="string">"proto3"</span><span class="string">;</span></span><br><span class="line">        <span class="string">package</span> <span class="string">example;</span></span><br><span class="line">        <span class="string">message</span> <span class="string">Example</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">uint32</span> <span class="string">a</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">          <span class="string">uint32</span> <span class="string">b</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">          <span class="string">uint32</span> <span class="string">c</span> <span class="string">=</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用上述配置文件创建 <code>tcaplus</code> 资源。创建结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BLAZEHU-MB2:samples $ k get tcaplus</span><br><span class="line">NAME             AGE</span><br><span class="line">tcaplus-sample   19m</span><br><span class="line">BLAZEHU-MB2:samples $ k get configmap</span><br><span class="line">NAME                        DATA   AGE</span><br><span class="line">tcaplus-configmap-example   1      19m</span><br></pre></td></tr></table></figure><p>可以查看 <code>tcaplus-configmap-example</code> 的属主关系：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">demo.proto:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">syntax</span> <span class="string">=</span> <span class="string">"proto3"</span><span class="string">;</span></span><br><span class="line">    <span class="string">package</span> <span class="string">example;</span></span><br><span class="line">    <span class="string">message</span> <span class="string">Example</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">a</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">b</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2022-07-07T09:02:43Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-configmap-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">example.blazehu.com/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Tcaplus</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tcaplus-sample</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">7c50f2e1-0e37-4aa0-bf49-c2d410d6153e</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"6837330713"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/configmaps/tcaplus-configmap-example</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">6c29f90b-0e51-4d9f-a6a8-cfb6906ed1b0</span></span><br></pre></td></tr></table></figure><p>手动修改 <code>tcaplus-sample</code> 和 <code>tcaplus-configmap-example</code> 后查看控制器日志发现能正常观察 <code>CR</code> 和 <code>ConfigMap</code> 的变化了。</p><h3 id="外部管理的资源"><a href="#外部管理的资源" class="headerlink" title="外部管理的资源"></a>外部管理的资源</h3><h4 id="资源定义-Defined-Tcaplus-Resources-1"><a href="#资源定义-Defined-Tcaplus-Resources-1" class="headerlink" title="资源定义 (Defined Tcaplus Resources)"></a>资源定义 (Defined Tcaplus Resources)</h4><p><strong>api/v1/tcaplus_types.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TcaplusSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Checksum     <span class="keyword">string</span>             <span class="string">`json:"checksum,omitempty"`</span></span><br><span class="line">ConfigMapRef ConfigMapReference <span class="string">`json:"configMapRef,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigMapReference <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制器逻辑-Manage-the-Owned-Resource-1"><a href="#控制器逻辑-Manage-the-Owned-Resource-1" class="headerlink" title="控制器逻辑 (Manage the Owned Resource)"></a>控制器逻辑 (Manage the Owned Resource)</h4><p><strong>controllers/tcaplus_controller.go</strong><br><code>For</code> 方法之后调用 <code>Watches</code> 方法就可以监听对应资源的事件，但是会监听集群里所有相关资源的事件，所以这里我们自定义事件处理方法来过滤出我们关注的资源的事件。</p><ul><li>通过 <code>EnqueueRequestsFromMapFunc</code> 创建一个事件处理方法，该方法通过 <code>FieldSelector</code> 在 <code>ConfigMap</code> 的事件中过滤出跟 <code>tcaplus CR</code> 相关联的事件。</li><li>使用 <code>FieldSelector</code> 时我们需要建立对应的索引，使用 <code>mgr.GetFieldIndexer().IndexField()</code> 创建。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ConfigMapField = <span class="string">".spec.configMapRef.name"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">findObjectsForConfigMap</span><span class="params">(configMap client.Object)</span> []<span class="title">reconcile</span>.<span class="title">Request</span></span> &#123;</span><br><span class="line">attachedTcaplusList := &amp;examplev1.TcaplusList&#123;&#125;</span><br><span class="line">listOps := &amp;client.ListOptions&#123;</span><br><span class="line">FieldSelector: fields.OneTermEqualSelector(ConfigMapField, configMap.GetName()),</span><br><span class="line">Namespace:     configMap.GetNamespace(),</span><br><span class="line">&#125;</span><br><span class="line">err := r.List(context.TODO(), attachedTcaplusList, listOps)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []reconcile.Request&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests := <span class="built_in">make</span>([]reconcile.Request, <span class="built_in">len</span>(attachedTcaplusList.Items))</span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> attachedTcaplusList.Items &#123;</span><br><span class="line">requests[i] = reconcile.Request&#123;</span><br><span class="line">NamespacedName: types.NamespacedName&#123;</span><br><span class="line">Name:      item.GetName(),</span><br><span class="line">Namespace: item.GetNamespace(),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> requests</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupWithManager sets up the controller with the Manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">SetupWithManager</span><span class="params">(mgr ctrl.Manager)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := mgr.GetFieldIndexer().IndexField(context.Background(), &amp;examplev1.Tcaplus&#123;&#125;, ConfigMapField, <span class="function"><span class="keyword">func</span><span class="params">(rawObj client.Object)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">tcaplus := rawObj.(*examplev1.Tcaplus)</span><br><span class="line"><span class="keyword">if</span> tcaplus.Spec.ConfigMapRef.Name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;tcaplus.Spec.ConfigMapRef.Name&#125;</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;examplev1.Tcaplus&#123;&#125;).</span><br><span class="line">Watches(</span><br><span class="line">&amp;source.Kind&#123;Type: &amp;corev1.ConfigMap&#123;&#125;&#125;,</span><br><span class="line">handler.EnqueueRequestsFromMapFunc(r.findObjectsForConfigMap),</span><br><span class="line">builder.WithPredicates(predicate.ResourceVersionChangedPredicate&#123;&#125;),</span><br><span class="line">).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面 <code>ConfigMap</code> 监听使用默认的 <code>Predicates</code> 过滤器 <code>ResourceVersionChangedPredicate</code>，查看源码定义就是说当 resource version 变化时事件会入队。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ResourceVersionChangedPredicate implements a default update predicate function on resource version change.</span></span><br><span class="line"><span class="keyword">type</span> ResourceVersionChangedPredicate <span class="keyword">struct</span> &#123;</span><br><span class="line">Funcs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 我们也可以自己定一个变更过滤器 <code>Predicate</code>。也可以通过 <code>WithEventFilter</code> 来针对监听的所有资源过滤。</p></blockquote></li></ul><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><strong>config/samples/example_v1_tcaplus.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-configmap-example</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">demo.proto:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">syntax</span> <span class="string">=</span> <span class="string">"proto3"</span><span class="string">;</span></span><br><span class="line">    <span class="string">package</span> <span class="string">example;</span></span><br><span class="line">    <span class="string">message</span> <span class="string">Example</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">a</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">b</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">c</span> <span class="string">=</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.blazehu.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Tcaplus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">checksum:</span> <span class="string">"123"</span></span><br><span class="line">  <span class="attr">configMapRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"tcaplus-configmap-example"</span></span><br></pre></td></tr></table></figure><p>使用上述配置创建完毕后，手动修改 <code>tcaplus-sample</code> 和 <code>tcaplus-configmap-example</code> 查看控制器日志发现同样能正常观察 <code>CR</code> 和 <code>ConfigMap</code> 的变化。</p><blockquote><p>NOTE: 查看 <code>tcaplus-configmap-example</code> 可以看到没有和 <code>tcaplus</code> 的属主关系。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>EventHandler</code> 可以在 <code>watch</code> 特定资源时设置该资源的事件监听规则。</li><li><code>WithEventFilter</code> 配置变更过滤器，可以针对 <code>watch</code> 的所有资源，统一地设置事件监听规则。</li><li><code>Owns</code> 源码分析可以发现 <code>Owns</code> 相当于调用 <code>Watches(&amp;source.Kind{Type: &lt;ForType-forInput&gt;}, &amp;handler.EnqueueRequestForOwner{OwnerType: apiType, IsController: true})</code>。</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.kubebuilder.io/reference/watching-resources.html" target="_blank" rel="noopener">https://www.kubebuilder.io/reference/watching-resources.html</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/</a></li><li><a href="https://segmentfault.com/a/1190000020359577" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020359577</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在开发过程中，可能需要开发一个类似&lt;code&gt;Deployment&lt;/code&gt;的资源逻辑，管理依赖资源是控制器的基础，如果不能观察它们的状态变化就不可能管理它们。这就意味着，我们需要 &lt;code&gt;reconciler&lt;/code&gt; 能监控多个资源的变化。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Admission Webhooks</title>
    <link href="https://blazehu.github.io/2022/04/12/cloudnative/kubebuilder_admission_webhooks/"/>
    <id>https://blazehu.github.io/2022/04/12/cloudnative/kubebuilder_admission_webhooks/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-08-16T09:19:14.743Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="1-什么是准入控制"><a href="#1-什么是准入控制" class="headerlink" title="1. 什么是准入控制?"></a>1. 什么是准入控制?</h3><p>准入控制（Admission Controller）是 Kubernetes API Server 用于拦截请求的一种手段。Admission 可以做到对请求的资源对象进行校验，修改。service mesh 最近很火的项目 Istio 天生支持 Kubernetes，利用的就是 Admission 对服务实例自动注入 sidecar。</p><h3 id="2-什么是准入-Webhook？"><a href="#2-什么是准入-Webhook？" class="headerlink" title="2. 什么是准入 Webhook？"></a>2. 什么是准入 Webhook？</h3><p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。 可以定义两种类型的准入 webhook，即 验证性质的准入 Webhook 和 修改性质的准入 Webhook。修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API 服务器的对象以执行自定义的设置默认值操作。</p><p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后， 验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p><blockquote><p>说明： 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。 则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。</p></blockquote><p><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/webhook1.jpeg" alt></p><h3 id="3-尝试准入-Webhook"><a href="#3-尝试准入-Webhook" class="headerlink" title="3. 尝试准入 Webhook"></a>3. 尝试准入 Webhook</h3><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><ul><li>确保 Kubernetes 集群版本至少为 v1.16（以便使用 admissionregistration.k8s.io/v1 API） 或者 v1.9 （以便使 admissionregistration.k8s.io/v1beta1 API）。</li><li>确保启用 <code>MutatingAdmissionWebhook</code> 和 <code>ValidatingAdmissionWebhook</code> 控制器。 <a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use" target="_blank" rel="noopener">这里</a>是一组推荐的 admission 控制器，通常可以启用。</li><li>确保启用了 admissionregistration.k8s.io/v1beta1 API。</li></ul><h3 id="4-配置准入-Webhook"><a href="#4-配置准入-Webhook" class="headerlink" title="4. 配置准入 Webhook"></a>4. 配置准入 Webhook</h3><p>你可以通过 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io" target="_blank" rel="noopener">ValidatingWebhookConfiguration</a> 或者 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io" target="_blank" rel="noopener">MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。详细配置可以参阅 <a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#webhook-configuration" target="_blank" rel="noopener">Webhook配置</a> 部分。</p><h3 id="5-认证和信任"><a href="#5-认证和信任" class="headerlink" title="5. 认证和信任"></a>5. 认证和信任</h3><p>默认情况下，apiserver不会向webhooks进行身份验证。但是，如果您想对客户端进行身份验证，可以将apiserver配置为使用基本身份验证、承载令牌或证书对Webhook进行身份验证。你可以在<a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#authenticate-apiservers" target="_blank" rel="noopener">这里</a>找到详细的步骤。</p><h3 id="6-编写一个准入-Webhook-服务器"><a href="#6-编写一个准入-Webhook-服务器" class="headerlink" title="6. 编写一个准入 Webhook 服务器"></a>6. 编写一个准入 Webhook 服务器</h3><p>Webhook Admission 属于同步调用，需要用户部署自己的 webhook server，创建自定义的配置资源对象： ValidatingWebhookConfiguration 或 MutatingWebhookConfiguration。下面使用 kubebuilder 开发一个简单的 demo。</p><h4 id="6-1-创建项目"><a href="#6-1-创建项目" class="headerlink" title="6.1 创建项目"></a>6.1 创建项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubebuilder init --domain blazehu.com --owner <span class="string">"blazehu"</span> --repo blazehu.com/kubegame</span><br></pre></td></tr></table></figure><blockquote><p>提示： 这里通过 kubebuilder v3 创建的话，在 config 目录下会缺少 certmanager、webhook 目录以及 default/manager_webhook_patch.yml 和 webhookcainjection_patch.yaml 文件。可以通过从v2生成拷贝过来进行修改。</p></blockquote><h4 id="6-2-创建控制器"><a href="#6-2-创建控制器" class="headerlink" title="6.2 创建控制器"></a>6.2 创建控制器</h4><p>这里只需要创建一个控制器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubebuilder create api --group svc --version v1 --kind App</span><br></pre></td></tr></table></figure><h4 id="6-3-创建-webhook"><a href="#6-3-创建-webhook" class="headerlink" title="6.3 创建 webhook"></a>6.3 创建 webhook</h4><h5 id="Implement-Your-Handler"><a href="#Implement-Your-Handler" class="headerlink" title="Implement Your Handler"></a>Implement Your Handler</h5><p>新增 mutatingwebhook.go &amp; validatingwebhook.go 文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutatingwebhook.go</span></span><br><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line">corev1 <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/client"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/webhook/admission"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +kubebuilder:webhook:admissionReviewVersions=v1,sideEffects=None,path=/mutate-v1-svc,mutating=true,failurePolicy=fail,groups="",resources=services,verbs=create;update,versions=v1,name=msvc.kb.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameAnnotator annotates Pods</span></span><br><span class="line"><span class="keyword">type</span> KubeGameAnnotator <span class="keyword">struct</span> &#123;</span><br><span class="line">Client  client.Client</span><br><span class="line">decoder *admission.Decoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle adds an annotation to every incoming pods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *KubeGameAnnotator)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, req admission.Request)</span> <span class="title">admission</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">pod := &amp;corev1.Pod&#123;&#125;</span><br><span class="line"></span><br><span class="line">err := a.decoder.Decode(req, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pod.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">pod.Annotations = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pod.Annotations[<span class="string">"example-mutating-admission-webhook"</span>] = <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">marshaledPod, err := json.Marshal(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusInternalServerError, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> admission.PatchResponseFromRaw(req.Object.Raw, marshaledPod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameAnnotator implements admission.DecoderInjector.</span></span><br><span class="line"><span class="comment">// A decoder will be automatically injected.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InjectDecoder injects the decoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *KubeGameAnnotator)</span> <span class="title">InjectDecoder</span><span class="params">(d *admission.Decoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">a.decoder = d</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// validatingwebhook.go</span></span><br><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">corev1 <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/client"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/webhook/admission"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +kubebuilder:webhook:admissionReviewVersions=v1,sideEffects=None,path=/validate-v1-svc,mutating=false,failurePolicy=fail,groups="",resources=services,verbs=create;update,versions=v1,name=vsvc.kb.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameValidator validates Pods</span></span><br><span class="line"><span class="keyword">type</span> KubeGameValidator <span class="keyword">struct</span> &#123;</span><br><span class="line">Client  client.Client</span><br><span class="line">decoder *admission.Decoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle admits a pod if a specific annotation exists.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *KubeGameValidator)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, req admission.Request)</span> <span class="title">admission</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">pod := &amp;corev1.Pod&#123;&#125;</span><br><span class="line"></span><br><span class="line">err := v.decoder.Decode(req, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key := <span class="string">"example-mutating-admission-webhook"</span></span><br><span class="line">anno, found := pod.Annotations[key]</span><br><span class="line"><span class="keyword">if</span> !found &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Denied(fmt.Sprintf(<span class="string">"missing annotation %s"</span>, key))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> anno != <span class="string">"foo"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Denied(fmt.Sprintf(<span class="string">"annotation %s did not have value %q"</span>, key, <span class="string">"foo"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> admission.Allowed(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameValidator implements admission.DecoderInjector.</span></span><br><span class="line"><span class="comment">// A decoder will be automatically injected.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InjectDecoder injects the decoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *KubeGameValidator)</span> <span class="title">InjectDecoder</span><span class="params">(d *admission.Decoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">v.decoder = d</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：因为上述逻辑需要services权限，所以我们在控制器里需要添加如下内容 <code>//+kubebuilder:rbac:groups=&quot;&quot;,resources=services,verbs=get;list;watch;create;update;patch;delete</code> 用于生成 rbac manifests。</p></blockquote><h5 id="Register-Your-Handler"><a href="#Register-Your-Handler" class="headerlink" title="Register Your Handler"></a>Register Your Handler</h5><p>修改 main.go ，注册我们的 webhook handler</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">setupLog.Info(<span class="string">"setting up webhook server"</span>)</span><br><span class="line">hookServer := mgr.GetWebhookServer()</span><br><span class="line"></span><br><span class="line">setupLog.Info(<span class="string">"registering webhooks to the webhook server"</span>)</span><br><span class="line">hookServer.Register(<span class="string">"/mutate-v1-svc"</span>, &amp;webhook.Admission&#123;Handler: &amp;controllers.KubeGameAnnotator&#123;Client: mgr.GetClient()&#125;&#125;)</span><br><span class="line">hookServer.Register(<span class="string">"/validate-v1-svc"</span>, &amp;webhook.Admission&#123;Handler: &amp;controllers.KubeGameValidator&#123;Client: mgr.GetClient()&#125;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>提示： 这里注册的<code>path</code>（例如 validate-v1-sv）路径需要和 validatingwebhook.go 、mutatingwebhook.go 文件里的 CRD validation 匹配，不然 <code>kustomize</code> 生成出来的 webhook yaml 文件不对。</p></blockquote><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><p>make run 会报如下错误，是因为没有证书导致，需要配置证书，可以<a href="http://blazehu.com/2022/08/16/cloudnative/k8s_csr_tls/" target="_blank" rel="noopener">手动签发证书</a>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.646924212701068e+09ERRORsetupproblem running manager&#123;<span class="string">"error"</span>: <span class="string">"open /var/folders/67/375276sx6hv0nln1whwm5syh0000gq/T/k8s-webhook-server/serving-certs/tls.crt: no such file or directory"</span>&#125;</span><br></pre></td></tr></table></figure><p>我本地指定证书目录：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">Scheme:                 scheme,</span><br><span class="line">MetricsBindAddress:     metricsAddr,</span><br><span class="line">Port:                   <span class="number">9443</span>,</span><br><span class="line">HealthProbeBindAddress: probeAddr,</span><br><span class="line">LeaderElection:         enableLeaderElection,</span><br><span class="line">LeaderElectionID:       <span class="string">"27e1b0af.blazehu.com"</span>,</span><br><span class="line">CertDir:                <span class="string">"./cert/"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新启动发现恢复正常<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/run1.png" alt></p><blockquote><p>提示： run <code>controller-gen rbac:roleName=manager-role crd webhook paths=./... output:crd:artifacts:config=config/crd/bases -w</code> to see all available markers, or <code>controller-gen rbac:roleName=manager-role crd webhook paths=./... output:crd:artifacts:config=config/crd/bases -h</code> for usage</p></blockquote><h3 id="7-部署至集群"><a href="#7-部署至集群" class="headerlink" title="7. 部署至集群"></a>7. 部署至集群</h3><h4 id="7-1-部署-cert-manager"><a href="#7-1-部署-cert-manager" class="headerlink" title="7.1 部署 cert manager"></a>7.1 部署 cert manager</h4><p>建议使用 <a href="https://github.com/cert-manager/cert-manager" target="_blank" rel="noopener">certmanager</a> 为 webhook 服务器提供证书。其他解决方案也有效，只要它们将证书放在所需的位置。安装文档点<a href="https://cert-manager.io/docs/installation/" target="_blank" rel="noopener">这里</a><br>通过如下方式注入 <code>caBundle</code> :</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This patch add annotation to admission webhook config and</span></span><br><span class="line"><span class="comment"># the variables $(CERTIFICATE_NAMESPACE) and $(CERTIFICATE_NAME) will be substituted by kustomize.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mutating-webhook-configuration</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">cert-manager.io/inject-ca-from:</span> <span class="string">$(CERTIFICATE_NAMESPACE)/$(CERTIFICATE_NAME)</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ValidatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">validating-webhook-configuration</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">cert-manager.io/inject-ca-from:</span> <span class="string">$(CERTIFICATE_NAMESPACE)/$(CERTIFICATE_NAME)</span></span><br></pre></td></tr></table></figure><h4 id="7-2-构建镜像"><a href="#7-2-构建镜像" class="headerlink" title="7.2 构建镜像"></a>7.2 构建镜像</h4><ul><li>镜像替换：default/manager_auth_proxy_patch.yaml 文件中的 gcr.io/kubebuilder/kube-rbac-proxy:v0.8.0 （网络慢）</li><li>Dockerfile 去掉 <code>go mod download</code>，直接使用本地 vendor 构建 （网络慢）</li><li>Dockerfile 去掉 <code>COPY api/ api/</code>， 因为没有创建 Resource</li><li>去掉 main.go 文件中配置的证书路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make docker-build IMG=xxxx</span><br><span class="line">make docker-push IMG=xxxx</span><br></pre></td></tr></table></figure><h4 id="7-3-修改模版，然后部署"><a href="#7-3-修改模版，然后部署" class="headerlink" title="7.3 修改模版，然后部署"></a>7.3 修改模版，然后部署</h4><ul><li>修改 config/default/kustomization.yaml ， 将 webhook、certmanager 相关的注释去掉。</li><li>修改 config/crd/kustomization.yaml ，将 webhook、certmanager 相关的注释去掉。</li><li>修改 config/default/kustomization.yaml ， 将 crd 相关的给注释掉。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make deploy IMG=xxxx</span><br></pre></td></tr></table></figure><p>部署成功：<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/deploy.png" alt></p><p>查看控制器日志：<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/logs.png" alt></p><h4 id="7-4-测试"><a href="#7-4-测试" class="headerlink" title="7.4 测试"></a>7.4 测试</h4><p>简单创建一个 service，webhook 会注入一个注解，并进行验证。下图可以看到成功注入。<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/test2.png" alt><br>控制日志：<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/test1.png" alt></p><blockquote><p>说明：查看 MutatingWebhookConfiguration 配置可以看到 caBundle 被注入其中了。</p></blockquote><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>总结下 webhook Admission 的优势：</p><ul><li>webhook 可动态扩展 Admission 能力，满足自定义客户的需求。</li><li>不需要重启 API Server，可通过创建 webhook configuration 热加载 webhook admission。</li></ul><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers</a></li><li><a href="https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/</a></li><li><a href="https://book.kubebuilder.io/reference/admission-webhook.html" target="_blank" rel="noopener">https://book.kubebuilder.io/reference/admission-webhook.html</a></li><li><a href="https://github.com/kubernetes-sigs/controller-runtime/tree/master/examples/builtins" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/controller-runtime/tree/master/examples/builtins</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h3 id=&quot;1-什么是准入控制&quot;&gt;&lt;a href=&quot;#1-什么是准入控制&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是准入控制?&quot;&gt;&lt;/a&gt;1. 什么是准入控制?&lt;/h3&gt;&lt;p&gt;准入控制（Admission Contro</summary>
      
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Best Practices</title>
    <link href="https://blazehu.github.io/2022/04/10/cloudnative/kubebuilder/"/>
    <id>https://blazehu.github.io/2022/04/10/cloudnative/kubebuilder/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2022-08-10T08:58:53.590Z</updated>
    
    <content type="html"><![CDATA[<p>Kubebuilder is a framework for building Kubernetes APIs using custom resource definitions (CRDs).</p><a id="more"></a><blockquote><p>Note: kubebuilder can save us a lot of work and make developing CRDs and adminsion webhooks incredibly easy.</p></blockquote><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># download kubebuilder and install locally.</span></span><br><span class="line">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><br><h3 id="Create-a-Project"><a href="#Create-a-Project" class="headerlink" title="Create a Project"></a>Create a Project</h3><hr><p>Create a directory, and then run the init command inside of it to initialize a new project. Follows an example.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ mkdir ~/Project/workspace-go/example</span><br><span class="line">[blazehu@MacBook ~]$ <span class="built_in">cd</span> ~/Project/workspace-go/example</span><br><span class="line">[blazehu@MacBook ~]$ kubebuilder init --domain blazehu.com --owner <span class="string">"blazehu"</span> --repo blazehu.com/example</span><br><span class="line">Writing kustomize manifests <span class="keyword">for</span> you to edit...</span><br><span class="line">Writing scaffold <span class="keyword">for</span> you to edit...</span><br><span class="line">Get controller runtime:</span><br><span class="line">$ go get sigs.k8s.io/controller-runtime@v0.10.0</span><br><span class="line">Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">Next: define a resource with:</span><br><span class="line">$ kubebuilder create api</span><br></pre></td></tr></table></figure><blockquote><p>If your project is initialized within GOPATH, the implicitly called go mod init will interpolate the module path for you. Otherwise –repo=<module path>must be set.</module></p></blockquote><br><h3 id="Adding-a-new-API"><a href="#Adding-a-new-API" class="headerlink" title="Adding a new API"></a>Adding a new API</h3><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubebuilder create api --group cos --version v1 --kind Bucket</span><br><span class="line">Create Resource [y/n]</span><br><span class="line">y</span><br><span class="line">Create Controller [y/n]</span><br><span class="line">y</span><br><span class="line">Writing kustomize manifests <span class="keyword">for</span> you to edit...</span><br><span class="line">Writing scaffold <span class="keyword">for</span> you to edit...</span><br><span class="line">api/v1/bucket_types.go</span><br><span class="line">controllers/bucket_controller.go</span><br><span class="line">Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">Running make:</span><br><span class="line">$ make generate</span><br><span class="line">go: creating new go.mod: module tmp</span><br><span class="line">Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.7.0</span><br><span class="line">go get: added sigs.k8s.io/controller-tools v0.7.0</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen object:headerFile=<span class="string">"hack/boilerplate.go.txt"</span> paths=<span class="string">"./..."</span></span><br><span class="line">Next: implement your new API and generate the manifests (e.g. CRDs,CRs) with:</span><br><span class="line">$ make manifests</span><br></pre></td></tr></table></figure><br><h3 id="Designing-an-API"><a href="#Designing-an-API" class="headerlink" title="Designing an API"></a>Designing an API</h3><hr><p><strong>api/v1/bucket_types.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BucketSpec defines the desired state of Bucket</span></span><br><span class="line"><span class="keyword">type</span> BucketSpec <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span></span><br><span class="line"><span class="comment">// Important: Run "make" to regenerate code after modifying this file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo is an example field of Bucket. Edit bucket_types.go to remove/update</span></span><br><span class="line">Name   <span class="keyword">string</span> <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">Region <span class="keyword">string</span> <span class="string">`json:"region,omitempty"`</span></span><br><span class="line">ACL    <span class="keyword">string</span> <span class="string">`json:"acl,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Implementing-a-controller"><a href="#Implementing-a-controller" class="headerlink" title="Implementing a controller"></a>Implementing a controller</h3><hr><p><strong>controllers/cos.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/tencentyun/cos-go-sdk-v5"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CosStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">client          *cos.Client</span><br><span class="line">accessKeyId     <span class="keyword">string</span></span><br><span class="line">accessKeySecret <span class="keyword">string</span></span><br><span class="line">bucket          <span class="keyword">string</span></span><br><span class="line">region          <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCosStorage endpoint: https://cloud.tencent.com/document/product/436/6224</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCosStorage</span><span class="params">(region, bucketName <span class="keyword">string</span>)</span> *<span class="title">CosStorage</span></span> &#123;</span><br><span class="line">url, _ := url.Parse(fmt.Sprintf(<span class="string">"https://%s.cos.%s.myqcloud.com"</span>, bucketName, region))</span><br><span class="line">accessKeyId := <span class="string">""</span></span><br><span class="line">accessKeySecret := <span class="string">""</span></span><br><span class="line">b := &amp;cos.BaseURL&#123;BucketURL: url&#125;</span><br><span class="line">client := cos.NewClient(b, &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;cos.AuthorizationTransport&#123;</span><br><span class="line">SecretID:  accessKeyId,</span><br><span class="line">SecretKey: accessKeySecret,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> &amp;CosStorage&#123;</span><br><span class="line">client:          client,</span><br><span class="line">accessKeyId:     accessKeyId,</span><br><span class="line">accessKeySecret: accessKeySecret,</span><br><span class="line">region:          region,</span><br><span class="line">bucket:          bucketName,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosStorage)</span> <span class="title">Put</span><span class="params">(acl <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opt := &amp;cos.BucketPutOptions&#123;</span><br><span class="line">XCosACL: acl,</span><br><span class="line">&#125;</span><br><span class="line">_, err := c.client.Bucket.Put(context.Background(), opt)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosStorage)</span> <span class="title">Delete</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := c.client.Bucket.Delete(context.Background())</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>controllers/bucket_controller.go</strong></p><blockquote><p>tips: Finalizers allow controllers to implement asynchronous pre-delete hooks. Let’s say you create an external resource (such as a storage bucket) for each object of your API type, and you want to delete the associated external resource on object’s deletion from Kubernetes, you can use a finalizer to do that.</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright 2022 blazehu.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"k8s.io/apimachinery/pkg/runtime"</span></span><br><span class="line">ctrl <span class="string">"sigs.k8s.io/controller-runtime"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/client"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/log"</span></span><br><span class="line"></span><br><span class="line">cosv1 <span class="string">"blazehu.com/example/api/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// BucketReconciler reconciles a Bucket object</span></span><br><span class="line"><span class="keyword">type</span> BucketReconciler <span class="keyword">struct</span> &#123;</span><br><span class="line">client.Client</span><br><span class="line">Scheme *runtime.Scheme</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">bucketFinalizerName = <span class="string">"bucket.cos.blazehu.com/finalizer"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=cos.blazehu.com,resources=buckets,verbs=get;list;watch;create;update;patch;delete</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=cos.blazehu.com,resources=buckets/status,verbs=get;update;patch</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=cos.blazehu.com,resources=buckets/finalizers,verbs=update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span></span><br><span class="line"><span class="comment">// move the current state of the cluster closer to the desired state.</span></span><br><span class="line"><span class="comment">// TODO(user): Modify the Reconcile function to compare the state specified by</span></span><br><span class="line"><span class="comment">// the Bucket object against the actual cluster state, and then</span></span><br><span class="line"><span class="comment">// perform operations to make the cluster state reflect the state specified by</span></span><br><span class="line"><span class="comment">// the user.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For more details, check Reconcile and its Result here:</span></span><br><span class="line"><span class="comment">// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.10.0/pkg/reconcile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">Reconcile</span><span class="params">(ctx context.Context, req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> &#123;</span><br><span class="line">logger := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">bucket := &amp;cosv1.Bucket&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examine DeletionTimestamp to determine if object is under deletion</span></span><br><span class="line"><span class="keyword">if</span> bucket.ObjectMeta.DeletionTimestamp.IsZero() &#123;</span><br><span class="line"><span class="comment">// The object is not being deleted, so if it does not have our finalizer,</span></span><br><span class="line"><span class="comment">// then lets add the finalizer and update the object. This is equivalent</span></span><br><span class="line"><span class="comment">// registering our finalizer.</span></span><br><span class="line"><span class="keyword">if</span> !controllerutil.ContainsFinalizer(bucket, bucketFinalizerName) &#123;</span><br><span class="line">controllerutil.AddFinalizer(bucket, bucketFinalizerName)</span><br><span class="line"><span class="keyword">if</span> err := r.Update(ctx, bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.updateExternalResources(bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">"unable to create Bucket"</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"create Bucket succeed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// The object is being deleted</span></span><br><span class="line"><span class="keyword">if</span> controllerutil.ContainsFinalizer(bucket, bucketFinalizerName) &#123;</span><br><span class="line"><span class="comment">// our finalizer is present, so lets handle any external dependency</span></span><br><span class="line"><span class="keyword">if</span> err := r.deleteExternalResources(bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// if fail to delete the external dependency here, return with error</span></span><br><span class="line"><span class="comment">// so that it can be retried</span></span><br><span class="line">logger.Error(err, <span class="string">"unable to delete Bucket"</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove our finalizer from the list and update it.</span></span><br><span class="line">controllerutil.RemoveFinalizer(bucket, bucketFinalizerName)</span><br><span class="line"><span class="keyword">if</span> err := r.Update(ctx, bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"delete Bucket succeed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop reconciliation as the item is being deleted</span></span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket reconcile logic</span></span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">updateExternalResources</span><span class="params">(bucket *cosv1.Bucket)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cosClient := NewCosStorage(bucket.Spec.Region, bucket.Spec.Name)</span><br><span class="line"><span class="keyword">return</span> cosClient.Put(bucket.Spec.ACL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">deleteExternalResources</span><span class="params">(bucket *cosv1.Bucket)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cosClient := NewCosStorage(bucket.Spec.Region, bucket.Spec.Name)</span><br><span class="line"><span class="keyword">return</span> cosClient.Delete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupWithManager sets up the controller with the Manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">SetupWithManager</span><span class="params">(mgr ctrl.Manager)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;cosv1.Bucket&#123;&#125;).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Test-It-Out"><a href="#Test-It-Out" class="headerlink" title="Test It Out"></a>Test It Out</h3><hr><ol><li><p>Install the CRDs into the cluster (<code>make install</code>)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ make install</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen rbac:roleName=manager-role crd webhook paths=<span class="string">"./..."</span> output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/kustomize build config/crd | kubectl apply -f -</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/buckets.cos.blazehu.com created</span><br></pre></td></tr></table></figure></li><li><p>Run your controller (this will run in the foreground, so switch to a new terminal if you want to leave it running) (<code>make run</code>)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ make run</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen rbac:roleName=manager-role crd webhook paths=<span class="string">"./..."</span> output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen object:headerFile=<span class="string">"hack/boilerplate.go.txt"</span> paths=<span class="string">"./..."</span></span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go run ./main.go</span><br><span class="line">2022-01-27T22:05:30.207+0800INFOcontroller-runtime.metricsmetrics server is starting to listen&#123;<span class="string">"addr"</span>: <span class="string">":8080"</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.207+0800INFOsetupstarting manager</span><br><span class="line">2022-01-27T22:05:30.208+0800INFOstarting metrics server&#123;<span class="string">"path"</span>: <span class="string">"/metrics"</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.208+0800INFOcontroller.bucketStarting EventSource&#123;<span class="string">"reconciler group"</span>: <span class="string">"cos.blazehu.com"</span>, <span class="string">"reconciler kind"</span>: <span class="string">"Bucket"</span>, <span class="string">"source"</span>: <span class="string">"kind source: /, Kind="</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.208+0800INFOcontroller.bucketStarting Controller&#123;<span class="string">"reconciler group"</span>: <span class="string">"cos.blazehu.com"</span>, <span class="string">"reconciler kind"</span>: <span class="string">"Bucket"</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.309+0800INFOcontroller.bucketStarting workers&#123;<span class="string">"reconciler group"</span>: <span class="string">"cos.blazehu.com"</span>, <span class="string">"reconciler kind"</span>: <span class="string">"Bucket"</span>, <span class="string">"worker count"</span>: 1&#125;</span><br></pre></td></tr></table></figure></li><li><p>Create Custom Resources (create bucket.cos.blazehu.com/bucket-sample) (<code>cos_v1_bucket.yaml</code>)</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">cos.blazehu.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Bucket</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bucket-sample</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blazehu</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># TODO(user): Add fields here</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-1251762279</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-shanghai</span></span><br><span class="line">  <span class="attr">acl:</span> <span class="string">private</span></span><br></pre></td></tr></table></figure><p><code>kubectl apply -f cos_v1_bucket.yaml</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl apply -f cos_v1_bucket.yaml</span><br><span class="line">bucket.cos.blazehu.com/bucket-sample created</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get bucket.cos.blazehu.com  -n blazehu</span><br><span class="line">NAME            AGE</span><br><span class="line">bucket-sample   17s</span><br></pre></td></tr></table></figure><p>Tencent cloud console view found that the bucket was created normally.<br><img src="/2022/04/10/cloudnative/kubebuilder/crd_example1.png" alt></p></li><li><p>Delete Instances of Custom Resources (delete bucket.cos.blazehu.com/bucket-sample)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl delete -f cos_v1_bucket.yaml</span><br><span class="line">bucket.cos.blazehu.com <span class="string">"bucket-sample"</span> deleted</span><br></pre></td></tr></table></figure><p>Tencent Cloud Console view found that the bucket has been deleted.</p><br></li></ol><h3 id="Run-It-On-the-Cluster"><a href="#Run-It-On-the-Cluster" class="headerlink" title="Run It On the Cluster"></a>Run It On the Cluster</h3><hr><p>Deploy the controller to the cluster with image specified by IMG</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make docker-build docker-push IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br><span class="line">make deploy IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br></pre></td></tr></table></figure><br><h3 id="Uninstall-CRDs"><a href="#Uninstall-CRDs" class="headerlink" title="Uninstall CRDs"></a>Uninstall CRDs</h3><hr><p>To delete your CRDs from the cluster, run <code>make uninstall</code><br><br></p><h3 id="Undeploy-controller"><a href="#Undeploy-controller" class="headerlink" title="Undeploy controller"></a>Undeploy controller</h3><hr><p>UnDeploy the controller to the cluster, run <code>make undeploy</code><br><br></p><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubebuilder</a></li><li><a href="https://book.kubebuilder.io/introduction.html" target="_blank" rel="noopener">https://book.kubebuilder.io/introduction.html</a></li><li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/operator/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubebuilder is a framework for building Kubernetes APIs using custom resource definitions (CRDs).&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>FluxCD GitOps Toolkit components</title>
    <link href="https://blazehu.github.io/2022/04/01/cloudnative/fluxcd/"/>
    <id>https://blazehu.github.io/2022/04/01/cloudnative/fluxcd/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-07-26T05:53:16.615Z</updated>
    
    <content type="html"><![CDATA[<p>Flux is a tool for keeping Kubernetes clusters in sync with sources of configuration (like Git repositories), and automating updates to configuration when there is new code to deploy.</p><a id="more"></a><br><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><hr><h4 id="Install-CLI"><a href="#Install-CLI" class="headerlink" title="Install CLI"></a>Install CLI</h4><p><a href="https://fluxcd.io/docs/installation/#install-the-flux-cli" target="_blank" rel="noopener">FluxCLI安装文档</a></p><h4 id="Check-your-Kubernetes-cluster"><a href="#Check-your-Kubernetes-cluster" class="headerlink" title="Check your Kubernetes cluster"></a>Check your Kubernetes cluster</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flux check --pre</span><br></pre></td></tr></table></figure><h4 id="Dev-install"><a href="#Dev-install" class="headerlink" title="Dev install"></a>Dev install</h4><p>For testing purposes you can install Flux without storing its manifests in a Git repository:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flux install</span><br></pre></td></tr></table></figure><p>Or using kubectl:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/fluxcd/flux2/releases/latest/download/install.yaml</span><br></pre></td></tr></table></figure><br><h3 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h3><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── apps                         <span class="comment"># 应用相关信息</span></span><br><span class="line">│   └── exmaple</span><br><span class="line">├── clusters                     <span class="comment"># 集群相关配置</span></span><br><span class="line">│   ├── gitrepo.yaml             <span class="comment"># gitrepository    (CR)</span></span><br><span class="line">│   ├── terraform.yaml           <span class="comment"># terraform        (CR)</span></span><br><span class="line">│   ├── helm.yaml                <span class="comment"># helmrelease      (CR)</span></span><br><span class="line">│   └── notification.yaml        <span class="comment"># alert &amp; provider (CR)</span></span><br><span class="line">└── infrastructure               <span class="comment"># iac 相关配置（主要是 terraform hcl 配置）              </span></span><br><span class="line">    ├── main.tf</span><br><span class="line">    ├── provider.tf</span><br><span class="line">    └── variable.tf</span><br></pre></td></tr></table></figure><h4 id="Source-Controller"><a href="#Source-Controller" class="headerlink" title="Source Controller"></a>Source Controller</h4><p>The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller.<br><img src="https://fluxcd.io/img/source-controller.png" alt="enter image description here"></p><p><code>gitrepo.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">source.toolkit.fluxcd.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">secretRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https-credentials</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/blazehu/gitops_example.git</span></span><br><span class="line">  <span class="attr">ref:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">https-credentials</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>secret 主要是做 git 仓库的认证</li><li>interval 是拉取 git 提交的间隔，每隔一分钟会查看 git 仓库是否会有新的提交</li></ul></blockquote><h4 id="TF-Controller"><a href="#TF-Controller" class="headerlink" title="TF Controller"></a>TF Controller</h4><p>TF-controller is an experimental controller for <a href="https://fluxcd.io/" target="_blank" rel="noopener">Flux</a> to reconcile Terraform resources in the GitOps way. With the power of Flux together with Terraform, TF-controller allows you to GitOps-ify infrastructure, and application resources, in the Kubernetes and Terraform universe, at your own pace.</p><p><code>tf config</code></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">infrastructure</span><br><span class="line">├── main.tf</span><br><span class="line">├── provider.tf</span><br><span class="line">└── <span class="keyword">variable</span>.tf</span><br></pre></td></tr></table></figure><p><code>provider.tf</code></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    tencentcloud = &#123;</span><br><span class="line">      <span class="keyword">source</span>  = <span class="string">"tencentcloudstack/tencentcloud"</span></span><br><span class="line">      version = <span class="string">"1.60.5"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider <span class="string">"tencentcloud"</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.tf</code></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">resource <span class="string">"tencentcloud_clb_instance"</span> <span class="string">"example"</span> &#123;</span><br><span class="line">  target_region_info_region    = var.region</span><br><span class="line">  target_region_info_vpc_id    = var.vpc</span><br><span class="line">  vpc_id                       = var.vpc</span><br><span class="line">  clb_name                     = var.clb_name</span><br><span class="line">  network_type                 = <span class="string">"OPEN"</span></span><br><span class="line">  project_id                   = <span class="number">0</span></span><br><span class="line">  security_groups              = [tencentcloud_security_group.sg1.id]</span><br><span class="line">  internet_bandwidth_max_out   = <span class="string">"10"</span></span><br><span class="line">  internet_charge_type         = <span class="string">"TRAFFIC_POSTPAID_BY_HOUR"</span></span><br><span class="line">  load_balancer_pass_to_target = <span class="string">"true"</span></span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    ignore_changes = [</span><br><span class="line">      tags,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"tencentcloud_security_group"</span> <span class="string">"sg1"</span> &#123;</span><br><span class="line">  description = <span class="string">"默认安全组"</span></span><br><span class="line">  name        = <span class="string">"example-sg1"</span></span><br><span class="line">  project_id  = <span class="string">"0"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"tencentcloud_security_group_lite_rule"</span> <span class="string">"sglr1"</span> &#123;</span><br><span class="line">  egress            = [<span class="string">"ACCEPT#0.0.0.0/0#ALL#ALL"</span>]</span><br><span class="line">  ingress           = [<span class="string">"ACCEPT#0.0.0.0/0#80,443#TCP"</span>, <span class="string">"DROP#0.0.0.0/0#ALL#ALL"</span>]</span><br><span class="line">  security_group_id = tencentcloud_security_group.sg1.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output <span class="string">"clb_vip"</span> &#123;</span><br><span class="line">  value = tencentcloud_clb_instance.example.clb_vips[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>terraform.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">infra.contrib.fluxcd.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Terraform</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tf-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">approvePlan:</span> <span class="string">"auto"</span></span><br><span class="line">  <span class="attr">destroyResourcesOnDeletion:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./infrastructure</span></span><br><span class="line">  <span class="attr">sourceRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line">  <span class="attr">varsFrom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tf-secret</span></span><br><span class="line">  <span class="attr">writeOutputsToSecret:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tf-output</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tf-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">secret_id:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">secret_key:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>writeOutputsToSecret 输出相关信息至 secret 便于其他资源引用</li><li>varsFrom 敏感信息通过该方式在 terraform 中引用</li></ul></blockquote><h4 id="Helm-Controller"><a href="#Helm-Controller" class="headerlink" title="Helm Controller"></a>Helm Controller</h4><p>The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests.<br><img src="https://fluxcd.io/img/helm-controller.png" alt="enter image description here"></p><p><code>helm.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">helm.toolkit.fluxcd.io/v2beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HelmRelease</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">targetNamespace:</span> <span class="string">blazehu</span></span><br><span class="line">  <span class="attr">releaseName:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">chart:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">chart:</span> <span class="string">apps/exmaple</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">"&gt;=0.0.1"</span></span><br><span class="line">      <span class="attr">valuesFile:</span> <span class="string">./apps/exmaple/values.yaml</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">      <span class="attr">sourceRef:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line">  <span class="attr">upgrade:</span></span><br><span class="line">    <span class="attr">remediation:</span></span><br><span class="line">      <span class="attr">remediateLastFailure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">valuesFrom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">tf-output</span></span><br><span class="line">      <span class="attr">valuesKey:</span> <span class="string">clb_vip</span></span><br><span class="line">      <span class="attr">targetPath:</span> <span class="string">clb.serviceVIP</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>version: a SemVer range (i.e. &gt;=4.0.0 &lt;5.0.0) to automatically upgrade your releases when a new chart version is available in the release’s referenced HelmRepository.</li><li>charts: The name or path the Helm chart is available at in the SourceRef.</li><li>valuesFile: Alternative list of values files to use as the chart values.</li><li>releaseName: Defaults to a composition of ‘[TargetNamespace-]Name’.</li><li>targetNamespace: TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease.</li></ul></blockquote><h4 id="Notification-Controller"><a href="#Notification-Controller" class="headerlink" title="Notification Controller"></a>Notification Controller</h4><p>The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events.<br><img src="https://fluxcd.io/img/notification-controller.png" alt="enter image description here"></p><p><code>notification.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">notification.toolkit.fluxcd.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Alert</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-alert</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">providerRef:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">generic</span> </span><br><span class="line">  <span class="attr">eventSeverity:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">eventSources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">HelmRelease</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">blazehu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">notification.toolkit.fluxcd.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Provider</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">generic</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">generic</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK</span></span><br></pre></td></tr></table></figure><br><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://fluxcd.io/docs/components/" target="_blank" rel="noopener">https://fluxcd.io/docs/components/</a></li><li><a href="https://weaveworks.github.io/tf-controller/" target="_blank" rel="noopener">https://weaveworks.github.io/tf-controller/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flux is a tool for keeping Kubernetes clusters in sync with sources of configuration (like Git repositories), and automating updates to configuration when there is new code to deploy.&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
    <category term="fluxcd" scheme="https://blazehu.github.io/tags/fluxcd/"/>
    
  </entry>
  
  <entry>
    <title>Terraform Controller Practices</title>
    <link href="https://blazehu.github.io/2022/03/11/cloudnative/terraform-controller/"/>
    <id>https://blazehu.github.io/2022/03/11/cloudnative/terraform-controller/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-07-26T05:56:25.595Z</updated>
    
    <content type="html"><![CDATA[<p>Terraform Controller is a Kubernetes Controller for Terraform.</p><a id="more"></a><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><hr><p><img src="/2022/03/11/cloudnative/terraform-controller/t1.png" alt></p><h3 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h3><hr><p>Github: <a href="https://github.com/oam-dev/terraform-controller" target="_blank" rel="noopener">https://github.com/oam-dev/terraform-controller</a></p><h3 id="Standalone-Terraform-Controller"><a href="#Standalone-Terraform-Controller" class="headerlink" title="Standalone Terraform Controller"></a>Standalone Terraform Controller</h3><hr><h4 id="Install-Kubernetes-Terraform-Controller-Chart"><a href="#Install-Kubernetes-Terraform-Controller-Chart" class="headerlink" title="Install Kubernetes Terraform Controller Chart"></a>Install Kubernetes Terraform Controller Chart</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm repo add kubevela-addons https://charts.kubevela.net/addons</span><br><span class="line"><span class="string">"kubevela-addons"</span> has been added to your repositories</span><br><span class="line"></span><br><span class="line">$ helm upgrade --install terraform-controller -n terraform --create-namespace kubevela-addons/terraform-controller</span><br><span class="line">Release <span class="string">"terraform-controller"</span> does not exist. Installing it now.</span><br><span class="line">NAME: terraform-controller</span><br><span class="line">LAST DEPLOYED: Fri Mar 11 15:08:57 2022</span><br><span class="line">NAMESPACE: terraform</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl get all -n terraform</span><br><span class="line">NAME                                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/terraform-controller-557d4b8869-nv28x   1/1     Running   0          22s</span><br><span class="line"></span><br><span class="line">NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/terraform-controller   1/1     1            1           22s</span><br><span class="line"></span><br><span class="line">NAME                                              DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/terraform-controller-557d4b8869   1         1         1       22s</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get crd | grep terraform</span><br><span class="line">configurations.terraform.core.oam.dev            2022-03-11T07:08:27Z</span><br><span class="line">providers.terraform.core.oam.dev                 2022-03-11T07:08:27Z</span><br></pre></td></tr></table></figure><h3 id="Authenticate-Cloud-Provider-and-Create-a-Cloud-Resource"><a href="#Authenticate-Cloud-Provider-and-Create-a-Cloud-Resource" class="headerlink" title="Authenticate Cloud Provider and Create a Cloud Resource"></a>Authenticate Cloud Provider and Create a Cloud Resource</h3><hr><p>下面验证腾讯云的 cos bucket 创建和销毁，准备以下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── provider.yaml                      <span class="comment"># provider 描述文件</span></span><br><span class="line">├── configuration_hcl_example.yaml     <span class="comment"># cos bucket 描述文件</span></span><br><span class="line">└── tencent-credentials.conf           <span class="comment"># 腾讯云相关 secret 信息（secretid &amp; secretkey）</span></span><br></pre></td></tr></table></figure><p>provider.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">terraform.core.oam.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Provider</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tencent</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">tencent</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-nanjing</span></span><br><span class="line">  <span class="attr">credentials:</span></span><br><span class="line">    <span class="attr">source:</span> <span class="string">Secret</span></span><br><span class="line">    <span class="attr">secretRef:</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">vela-system</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">tencent-account-creds</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">credentials</span></span><br></pre></td></tr></table></figure><p>configuration_hcl_example.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">terraform.core.oam.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Configuration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tencent-cos-hcl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hcl:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">terraform</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">required_providers</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">tencentcloud</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">source</span>  <span class="string">=</span> <span class="string">"tencentcloudstack/tencentcloud"</span></span><br><span class="line">          <span class="string">version</span> <span class="string">=</span> <span class="string">"1.60.5"</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">resource</span> <span class="string">"tencentcloud_cos_bucket"</span> <span class="string">"mycos"</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">bucket</span> <span class="string">=</span> <span class="string">"blazehu-test-125834470x"</span></span><br><span class="line">      <span class="string">acl</span>    <span class="string">=</span> <span class="string">"private"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="attr">providerRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tencent</span></span><br></pre></td></tr></table></figure><p>tencent-credentials.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secretID: </span><br><span class="line">secretKey:</span><br></pre></td></tr></table></figure><h4 id="create-secret"><a href="#create-secret" class="headerlink" title="create secret"></a>create secret</h4><p>通过 tencent-credentials.conf 文件创建 secret ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic tencent-account-creds -n vela-system --from-file=credentials=tencent-credentials.conf</span><br></pre></td></tr></table></figure><h4 id="create-provider"><a href="#create-provider" class="headerlink" title="create provider"></a>create provider</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl apply -f provider.yaml</span><br><span class="line">provider.terraform.core.oam.dev/tencent created</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get provider.terraform.core.oam.dev</span><br><span class="line">NAME      STATE   AGE</span><br><span class="line">tencent   ready   3m41s</span><br></pre></td></tr></table></figure><h4 id="create-configuration"><a href="#create-configuration" class="headerlink" title="create configuration"></a>create configuration</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl apply -f configuration_hcl_example.yaml</span><br><span class="line">configuration.terraform.core.oam.dev/tencent-cos-hcl created</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get configuration.terraform.core.oam.dev</span><br><span class="line">NAME              STATE                     AGE</span><br><span class="line">tencent-cos-hcl   ProvisioningAndChecking   13s</span><br></pre></td></tr></table></figure><p>terraform-controller 会拉起 Job 跑 terraform 命令来创建，源码：<br><img src="/2022/03/11/cloudnative/terraform-controller/scr1.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ k get job</span><br><span class="line">NAME                    COMPLETIONS   DURATION   AGE</span><br><span class="line">tencent-cos-hcl-apply   0/1           3s         3s</span><br><span class="line">[blazehu@MacBook ~]$ k get po</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">tencent-cos-hcl-apply-fhpsg   1/1     Running   0          7s</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">[blazehu@MacBook ~]$ k get configuration.terraform.core.oam.dev</span><br><span class="line">NAME              STATE       AGE</span><br><span class="line">tencent-cos-hcl   Available   4m16s</span><br></pre></td></tr></table></figure><p>腾讯云控制台可以观测到 cos bucket 成功创建。</p><blockquote><p>tip: 执行成功后 state 相关内容写入了 secret 里。</p></blockquote><h4 id="delete-configuration"><a href="#delete-configuration" class="headerlink" title="delete configuration"></a>delete configuration</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ k delete -f configuration_hcl_example.yaml</span><br><span class="line">configuration.terraform.core.oam.dev <span class="string">"tencent-cos-hcl"</span> deleted</span><br><span class="line"></span><br><span class="line">[blazehu@MacBook ~]$ k get job</span><br><span class="line">NAME                      COMPLETIONS   DURATION   AGE</span><br><span class="line">tencent-cos-hcl-apply     1/1           2m55s      5m11s</span><br><span class="line">tencent-cos-hcl-destroy   0/1           7s         7s</span><br><span class="line">[blazehu@MacBook ~]$ k get pod</span><br><span class="line">NAME                            READY   STATUS      RESTARTS   AGE</span><br><span class="line">tencent-cos-hcl-apply-qnfnx     0/1     Completed   3          3m30s</span><br><span class="line">tencent-cos-hcl-destroy-vt5b2   0/1     Completed   0          10s</span><br></pre></td></tr></table></figure><p>腾讯云控制台可以观测到 cos bucket 已经被回收处理。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>因为每一个新的操作都是启动一个新的 Pod 去执行 <code>terraform init...</code>，由于网络问题， Initializing provider plugins 经常失败，于是这里使用 cache ，构建一个新的 job 镜像然后更新 release。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> oamdev/docker-terraform:<span class="number">1.1</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"blazehu"</span></span></span><br><span class="line"><span class="keyword">ENV</span> TF_PLUGIN_CACHE_DIR /.terraform.d/plugin-cache</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> registry.terraform.io /.terraform.d/plugin-cache/registry.terraform.io</span></span><br></pre></td></tr></table></figure><p>upgrade release</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ helm upgrade --install terraform-controller -n terraform --create-namespace kubevela-addons/terraform-controller --<span class="built_in">set</span> terraformImage=docker-terraform:2.0</span><br></pre></td></tr></table></figure><blockquote><p>tips: 也可以是用 sidecar 注入 pod 来使用 cache （<a href="https://openkruise.io/zh/docs/user-manuals/sidecarset/" target="_blank" rel="noopener">openkruise</a>）</p></blockquote><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://developer.aliyun.com/article/724349" target="_blank" rel="noopener">https://developer.aliyun.com/article/724349</a></li><li><a href="https://github.com/oam-dev/terraform-controller/blob/master/getting-started.md" target="_blank" rel="noopener">https://github.com/oam-dev/terraform-controller/blob/master/getting-started.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Terraform Controller is a Kubernetes Controller for Terraform.&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
  </entry>
  
  <entry>
    <title>Terraform Plugin Development</title>
    <link href="https://blazehu.github.io/2021/12/29/cloudnative/terraform-plugins/"/>
    <id>https://blazehu.github.io/2021/12/29/cloudnative/terraform-plugins/</id>
    <published>2021-12-28T16:00:00.000Z</published>
    <updated>2022-08-10T08:48:14.714Z</updated>
    
    <content type="html"><![CDATA[<p>Terraform is an open source resource orchestration tool based on Golang, which allows users to manage and configure any infrastructure, the infrastructure of public and private cloud services, and external services.</p><a id="more"></a><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>Terraform is logically split into two main parts:</p><ul><li><strong>Terraform Core</strong>: This is the Terraform binary that communicates with plugins to manage infrastructure resources. It provides a common interface that allows you to leverage many different cloud providers, databases, services, and in-house solutions.</li><li><strong>Terraform Plugins</strong>: These are executable binaries written in Go that communicate with Terraform Core over an RPC interface. Each plugin exposes an implementation for a specific service, such as the <a href="https://registry.terraform.io/providers/hashicorp/aws/latest" target="_blank" rel="noopener">AWS provider</a> or the <a href="https://registry.terraform.io/providers/hashicorp/cloudinit/latest/docs" target="_blank" rel="noopener">cloud-init provider</a>. Terraform currently supports one type of Plugin called <a href="https://www.terraform.io/language/providers" target="_blank" rel="noopener">providers</a>.<br></li></ul><p><img src="/2021/12/29/cloudnative/terraform-plugins/terraform-plugin-overview.png" alt></p><h3 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h3><p>Clone these template repositories on GitHub: <a href="https://github.com/hashicorp/terraform-provider-scaffolding" target="_blank" rel="noopener">terraform-provider-scaffolding (SDKv2)</a></p><p>Steps:</p><ol><li>clone the <a href="https://github.com/hashicorp/terraform-provider-scaffolding" target="_blank" rel="noopener">terraform-provider-scaffolding (SDKv2)</a>.</li><li>explore development environment, modify <code>GNUmakefile</code>.</li><li>define the provider、data_source、resource schema.</li><li>write code for cos bucket CRUD (<code>internal/provider</code> dir) and acceptance tests.</li><li>test the provider.</li><li>generate the provider documentation.</li></ol><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Terraform &gt;= 0.13.x</li><li>Go &gt;= 1.15</li></ul><h4 id="Building-The-Provider"><a href="#Building-The-Provider" class="headerlink" title="Building The Provider"></a>Building The Provider</h4><p>To compile the provider, run <code>go install</code>. This will build the provider and put the provider binary in the <code>$GOPATH/bin</code> directory.</p><h4 id="Generate-the-Provider-Documentation"><a href="#Generate-the-Provider-Documentation" class="headerlink" title="Generate the Provider Documentation"></a>Generate the Provider Documentation</h4><p>To generate or update documentation, run <code>go generate</code>.</p><h4 id="Acceptance-tests"><a href="#Acceptance-tests" class="headerlink" title="Acceptance tests"></a>Acceptance tests</h4><p>In order to run the full suite of Acceptance tests, run <code>make testacc</code>.</p><blockquote><p>Note: Acceptance tests create real resources, and often cost money to run.</p></blockquote><h4 id="Directory-Structure"><a href="#Directory-Structure" class="headerlink" title="Directory Structure"></a>Directory Structure</h4><p>Take <code>cos bucket</code> as an example, modify the directory structure as follows.</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">terraform-provider-cos</span></span><br><span class="line">├── <span class="selector-tag">README</span><span class="selector-class">.md</span>     </span><br><span class="line">├── <span class="selector-tag">GNUmakefile</span></span><br><span class="line">├── <span class="selector-tag">CHANGELOG</span><span class="selector-class">.md</span>                                变更日志</span><br><span class="line">├── <span class="selector-tag">LICENSE</span>                                     授权信息   </span><br><span class="line">├── <span class="selector-tag">main</span><span class="selector-class">.go</span>                                     程序入口文件</span><br><span class="line">├── <span class="selector-tag">docs</span>                                        文档目录</span><br><span class="line">├── <span class="selector-tag">examples</span>                                    示例配置文件目录</span><br><span class="line">├── <span class="selector-tag">internal</span>                                    <span class="selector-tag">Provider</span>核心目录</span><br><span class="line">│   └── <span class="selector-tag">provider</span></span><br><span class="line">│       ├── <span class="selector-tag">data_source_cos_bucket</span><span class="selector-class">.go</span>           <span class="selector-tag">bucket</span>查询</span><br><span class="line">│       ├── <span class="selector-tag">data_source_cos_bucket_test</span><span class="selector-class">.go</span></span><br><span class="line">│       ├── <span class="selector-tag">provider</span><span class="selector-class">.go</span>                         <span class="selector-tag">Provider</span>核心文件</span><br><span class="line">│       ├── <span class="selector-tag">provider_test</span><span class="selector-class">.go</span> </span><br><span class="line">│       ├── <span class="selector-tag">resource_cos_bucket</span><span class="selector-class">.go</span>              <span class="selector-tag">bucket</span>资源管理</span><br><span class="line">│       ├── <span class="selector-tag">resource_cos_bucket_test</span><span class="selector-class">.go</span></span><br><span class="line">│       └── <span class="selector-tag">service_cos_bucket</span><span class="selector-class">.go</span>               封装的<span class="selector-tag">bucket</span>相关<span class="selector-tag">Service</span></span><br><span class="line">├── <span class="selector-tag">go</span><span class="selector-class">.mod</span></span><br><span class="line">├── <span class="selector-tag">go</span><span class="selector-class">.sum</span></span><br><span class="line">├── <span class="selector-tag">terraform-registry-manifest</span><span class="selector-class">.json</span></span><br><span class="line">└── <span class="selector-tag">tools</span></span><br><span class="line">    └── <span class="selector-tag">tools</span><span class="selector-class">.go</span></span><br></pre></td></tr></table></figure><p>The structure is mainly divided into five parts:</p><ul><li><code>main.go</code>, plugin entry.</li><li><code>provider.go</code>, attributes used to describe plugins, such as: configured key, supported resource list, callback - configuration.</li><li><code>data_source_*.go</code>, read calls, mainly query interfaces.</li><li><code>resource_*.go</code>, write calls, including resource addition, deletion, modification and query interfaces.</li><li><code>service_*.go</code>, public methods divided by resource categories.</li></ul><h4 id="Explore-your-development-environment"><a href="#Explore-your-development-environment" class="headerlink" title="Explore your development environment"></a>Explore your development environment</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEST?=$<span class="variable">$(go list ./... | grep -v 'vendor')</span></span><br><span class="line">HOSTNAME=blazehu.com</span><br><span class="line">NAMESPACE=edu</span><br><span class="line">NAME=cos</span><br><span class="line">BINARY=terraform-provider-$&#123;NAME&#125;_v$&#123;VERSION&#125;</span><br><span class="line">OS_ARCH=darwin_amd64</span><br><span class="line">VERSION=0.1</span><br><span class="line"><span class="comment">#BINARY=terraform-provider-$&#123;NAME&#125;_v$&#123;VERSION&#125;.exe</span></span><br><span class="line"><span class="comment">#OS_ARCH=windows_amd64</span></span><br><span class="line"><span class="section">default: testacc</span></span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">go build -o $&#123;BINARY&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">go test -i <span class="variable">$(TEST)</span> || exit 1</span><br><span class="line">echo <span class="variable">$(TEST)</span> | xargs -t -n4 go test <span class="variable">$(TESTARGS)</span> -timeout=30s -parallel=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run acceptance tests</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: testacc</span></span><br><span class="line"><span class="section">testacc:</span></span><br><span class="line">TF_ACC=1 go test ./... -v <span class="variable">$(TESTARGS)</span> -timeout 120m</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: install</span></span><br><span class="line"><span class="section">install: build # Build manager binary.</span></span><br><span class="line">mkdir -p ~/.terraform.d/plugins/$&#123;HOSTNAME&#125;/$&#123;NAMESPACE&#125;/$&#123;NAME&#125;/$&#123;VERSION&#125;/$&#123;OS_ARCH&#125;</span><br><span class="line">mv $&#123;BINARY&#125; ~/.terraform.d/plugins/$&#123;HOSTNAME&#125;/$&#123;NAMESPACE&#125;/$&#123;NAME&#125;/$&#123;VERSION&#125;/$&#123;OS_ARCH&#125;</span><br></pre></td></tr></table></figure><h4 id="Define-provider-schema"><a href="#Define-provider-schema" class="headerlink" title="Define provider schema"></a>Define provider schema</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(version <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span> *<span class="title">schema</span>.<span class="title">Provider</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> *<span class="title">schema</span>.<span class="title">Provider</span></span> &#123;</span><br><span class="line">p := &amp;schema.Provider&#123;</span><br><span class="line">DataSourcesMap: <span class="keyword">map</span>[<span class="keyword">string</span>]*schema.Resource&#123;</span><br><span class="line"><span class="string">"cos_bucket_data_source"</span>: dataSourceCosBucket(),</span><br><span class="line">&#125;,</span><br><span class="line">ResourcesMap: <span class="keyword">map</span>[<span class="keyword">string</span>]*schema.Resource&#123;</span><br><span class="line"><span class="string">"cos_bucket_resource"</span>: resourceCosBucket(),</span><br><span class="line">&#125;,</span><br><span class="line">Schema: <span class="keyword">map</span>[<span class="keyword">string</span>]*schema.Schema&#123;</span><br><span class="line"><span class="string">"secret_id"</span>: &amp;schema.Schema&#123;</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Required:    <span class="literal">true</span>,</span><br><span class="line">Sensitive:   <span class="literal">true</span>,</span><br><span class="line">DefaultFunc: schema.EnvDefaultFunc(<span class="string">"SECRET_ID"</span>, <span class="literal">nil</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"secret_key"</span>: &amp;schema.Schema&#123;</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Required:    <span class="literal">true</span>,</span><br><span class="line">Sensitive:   <span class="literal">true</span>,</span><br><span class="line">DefaultFunc: schema.EnvDefaultFunc(<span class="string">"SECRET_KEY"</span>, <span class="literal">nil</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"region"</span>: &amp;schema.Schema&#123;</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Required:    <span class="literal">true</span>,</span><br><span class="line">Sensitive:   <span class="literal">true</span>,</span><br><span class="line">DefaultFunc: schema.EnvDefaultFunc(<span class="string">"REGION"</span>, <span class="literal">nil</span>),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">ConfigureContextFunc: providerConfigure,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">providerConfigure</span><span class="params">(ctx context.Context, d *schema.ResourceData)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, diag.Diagnostics)</span></span> &#123;</span><br><span class="line">region := d.Get(<span class="string">"region"</span>).(<span class="keyword">string</span>)</span><br><span class="line">secretId := d.Get(<span class="string">"secret_id"</span>).(<span class="keyword">string</span>)</span><br><span class="line">secretKey := d.Get(<span class="string">"secret_key"</span>).(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warning or errors can be collected in a slice type</span></span><br><span class="line"><span class="keyword">var</span> diags diag.Diagnostics</span><br><span class="line"></span><br><span class="line">c := &amp;CosClient&#123;</span><br><span class="line">Region:    region,</span><br><span class="line">SecretId:  secretId,</span><br><span class="line">SecretKey: secretKey,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c, diags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Define-bucket-data-resource-schema"><a href="#Define-bucket-data-resource-schema" class="headerlink" title="Define bucket data resource schema"></a>Define bucket data resource schema</h4><p><code>resource_cos_bucket.go</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resourceCosBucket</span><span class="params">()</span> *<span class="title">schema</span>.<span class="title">Resource</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;schema.Resource&#123;</span><br><span class="line"><span class="comment">// This description is used by the documentation generator and the language server.</span></span><br><span class="line">Description: <span class="string">"Sample resource in the Terraform provider cos."</span>,</span><br><span class="line"></span><br><span class="line">CreateContext: resourceCosBucketCreate,</span><br><span class="line">ReadContext:   resourceCosBucketRead,</span><br><span class="line">UpdateContext: resourceCosBucketUpdate,</span><br><span class="line">DeleteContext: resourceCosBucketDelete,</span><br><span class="line"></span><br><span class="line">Schema: <span class="keyword">map</span>[<span class="keyword">string</span>]*schema.Schema&#123;</span><br><span class="line"><span class="string">"name"</span>: &#123;</span><br><span class="line"><span class="comment">// This description is used by the documentation generator and the language server.</span></span><br><span class="line">Description: <span class="string">"cos bucket name."</span>,</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Required:    <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"acl"</span>: &#123;</span><br><span class="line">Description: <span class="string">"cos bucket acl."</span>,</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Default:     <span class="string">"private"</span>,</span><br><span class="line">Optional:    <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"update_at"</span>: &#123;</span><br><span class="line">Description: <span class="string">"cos bucket create time"</span>,</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Computed:    <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data_source_cos_bucket.go</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataSourceCosBucket</span><span class="params">()</span> *<span class="title">schema</span>.<span class="title">Resource</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;schema.Resource&#123;</span><br><span class="line"><span class="comment">// This description is used by the documentation generator and the language server.</span></span><br><span class="line">Description: <span class="string">"Sample data source in the Terraform provider cos."</span>,</span><br><span class="line"></span><br><span class="line">ReadContext: dataSourceCosBucketRead,</span><br><span class="line"></span><br><span class="line">Schema: <span class="keyword">map</span>[<span class="keyword">string</span>]*schema.Schema&#123;</span><br><span class="line"><span class="string">"name"</span>: &#123;</span><br><span class="line"><span class="comment">// This description is used by the documentation generator and the language server.</span></span><br><span class="line">Description: <span class="string">"cos bucket name."</span>,</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Required:    <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"owner"</span>: &#123;</span><br><span class="line"><span class="comment">// This description is used by the documentation generator and the language server.</span></span><br><span class="line">Description: <span class="string">"cos bucket owner."</span>,</span><br><span class="line">Type:        schema.TypeString,</span><br><span class="line">Computed:    <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implement-Complex-Read"><a href="#Implement-Complex-Read" class="headerlink" title="Implement Complex Read"></a>Implement Complex Read</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataSourceCosBucketRead</span><span class="params">(ctx context.Context, d *schema.ResourceData, meta <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">diag</span>.<span class="title">Diagnostics</span></span> &#123;</span><br><span class="line"><span class="comment">// use the meta value to retrieve your client from the provider configure method</span></span><br><span class="line">client := meta.(*CosClient)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> diags diag.Diagnostics</span><br><span class="line"></span><br><span class="line">name := d.Get(<span class="string">"name"</span>).(<span class="keyword">string</span>)</span><br><span class="line">owner, err := client.GetACLOwner(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> diag.Errorf(fmt.Sprintf(<span class="string">"get cos bucket owner failed. msg: %s"</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">d.SetId(name)</span><br><span class="line"><span class="keyword">if</span> err = d.Set(<span class="string">"owner"</span>, owner); err != <span class="literal">nil</span> &#123;</span><br><span class="line">tflog.Error(ctx, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> diags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implement-Create"><a href="#Implement-Create" class="headerlink" title="Implement Create"></a>Implement Create</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resourceCosBucketCreate</span><span class="params">(ctx context.Context, d *schema.ResourceData, meta <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">diag</span>.<span class="title">Diagnostics</span></span> &#123;</span><br><span class="line"><span class="comment">// use the meta value to retrieve your client from the provider configure method</span></span><br><span class="line">client := meta.(*CosClient)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> diags diag.Diagnostics</span><br><span class="line"></span><br><span class="line">name := d.Get(<span class="string">"name"</span>).(<span class="keyword">string</span>)</span><br><span class="line">acl := d.Get(<span class="string">"acl"</span>).(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := client.Put(name, acl); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> diag.Errorf(fmt.Sprintf(<span class="string">"created cos bucket failed. msg: %s"</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">d.SetId(name)</span><br><span class="line"><span class="keyword">if</span> err := d.Set(<span class="string">"update_at"</span>, time.Now().Format(time.RFC3339)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">tflog.Error(ctx, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tflog.Info(ctx, fmt.Sprintf(<span class="string">"created a cos bucket, name: %s, region: %s"</span>, name, client.Region))</span><br><span class="line"><span class="comment">// write logs using the tflog package</span></span><br><span class="line"><span class="comment">// see https://pkg.go.dev/github.com/hashicorp/terraform-plugin-log/tflog</span></span><br><span class="line"><span class="comment">// for more information</span></span><br><span class="line"><span class="keyword">return</span> diags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implement-Update"><a href="#Implement-Update" class="headerlink" title="Implement Update"></a>Implement Update</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resourceCosBucketUpdate</span><span class="params">(ctx context.Context, d *schema.ResourceData, meta <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">diag</span>.<span class="title">Diagnostics</span></span> &#123;</span><br><span class="line"><span class="comment">// use the meta value to retrieve your client from the provider configure method</span></span><br><span class="line">client := meta.(*CosClient)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> diags diag.Diagnostics</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.HasChange(<span class="string">"acl"</span>) &#123;</span><br><span class="line">name := d.Get(<span class="string">"name"</span>).(<span class="keyword">string</span>)</span><br><span class="line">acl := d.Get(<span class="string">"acl"</span>).(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := client.PutACL(name, acl); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> diag.Errorf(fmt.Sprintf(<span class="string">"update cos bucket acl failed. msg: %s"</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := d.Set(<span class="string">"update_at"</span>, time.Now().Format(time.RFC3339)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">tflog.Error(ctx, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> diags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implement-Delete"><a href="#Implement-Delete" class="headerlink" title="Implement Delete"></a>Implement Delete</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resourceCosBucketDelete</span><span class="params">(ctx context.Context, d *schema.ResourceData, meta <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">diag</span>.<span class="title">Diagnostics</span></span> &#123;</span><br><span class="line"><span class="comment">// use the meta value to retrieve your client from the provider configure method</span></span><br><span class="line">client := meta.(*CosClient)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> diags diag.Diagnostics</span><br><span class="line"></span><br><span class="line">name := d.Get(<span class="string">"name"</span>).(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> err := client.Delete(name); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> diag.Errorf(fmt.Sprintf(<span class="string">"delete cos bucket failed. msg: %s"</span>, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">d.SetId(<span class="string">""</span>)</span><br><span class="line">tflog.Info(ctx, fmt.Sprintf(<span class="string">"delete a cos bucket, name: %s"</span>, name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> diags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Implement-Cos-Bucket-Service"><a href="#Implement-Cos-Bucket-Service" class="headerlink" title="Implement Cos Bucket Service"></a>Implement Cos Bucket Service</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/tencentyun/cos-go-sdk-v5"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CosClient <span class="keyword">struct</span> &#123;</span><br><span class="line">SecretId  <span class="keyword">string</span></span><br><span class="line">SecretKey <span class="keyword">string</span></span><br><span class="line">Region    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosClient)</span> <span class="title">client</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">cos</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">url, _ := url.Parse(fmt.Sprintf(<span class="string">"https://%s.cos.%s.myqcloud.com"</span>, name, c.Region))</span><br><span class="line">b := &amp;cos.BaseURL&#123;BucketURL: url&#125;</span><br><span class="line"><span class="keyword">return</span> cos.NewClient(b, &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;cos.AuthorizationTransport&#123;</span><br><span class="line">SecretID:  c.SecretId,</span><br><span class="line">SecretKey: c.SecretKey,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosClient)</span> <span class="title">Put</span><span class="params">(name, acl <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opt := &amp;cos.BucketPutOptions&#123;</span><br><span class="line">XCosACL: acl,</span><br><span class="line">&#125;</span><br><span class="line">_, err := c.client(name).Bucket.Put(context.Background(), opt)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosClient)</span> <span class="title">GetACLOwner</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">acl, _, err := c.client(name).Bucket.GetACL(context.Background())</span><br><span class="line"><span class="keyword">return</span> acl.Owner.DisplayName, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosClient)</span> <span class="title">PutACL</span><span class="params">(name, acl <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opt := &amp;cos.BucketPutACLOptions&#123;</span><br><span class="line">Header: &amp;cos.ACLHeaderOptions&#123;</span><br><span class="line"><span class="comment">//private，public-read，public-read-write</span></span><br><span class="line">XCosACL: acl,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">_, err := c.client(name).Bucket.PutACL(context.Background(), opt)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosClient)</span> <span class="title">Delete</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := c.client(name).Bucket.Delete(context.Background())</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Test-the-provider"><a href="#Test-the-provider" class="headerlink" title="Test the provider"></a>Test the provider</h4><ol><li><code>make install</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ make install</span><br><span class="line">go build -o terraform-provider-cos_v0.1</span><br><span class="line">mkdir -p ~/.terraform.d/plugins/blazehu.com/edu/cos/0.1/darwin_amd64</span><br><span class="line">mv terraform-provider-cos_v0.1 ~/.terraform.d/plugins/blazehu.com/edu/cos/0.1/darwin_amd64</span><br></pre></td></tr></table></figure></li><li>write <code>demo.tf</code><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    cos = &#123;</span><br><span class="line">      <span class="keyword">source</span>  = <span class="string">"blazehu.com/edu/cos"</span></span><br><span class="line">      version = <span class="string">"0.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider <span class="string">"cos"</span> &#123;</span><br><span class="line">  region = <span class="string">"ap-shanghai"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"cos_bucket_resource"</span> <span class="string">"demo"</span> &#123;</span><br><span class="line">  name = <span class="string">"terraform-1251762279"</span></span><br><span class="line">  acl  = <span class="string">"private"</span></span><br><span class="line"><span class="comment">  # acl = "public-read-write"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data <span class="string">"cos_bucket_data_source"</span> <span class="string">"test"</span> &#123;</span><br><span class="line">  name = cos_bucket_resource.demo.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>run <code>terraform init</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Initializing the backend...</span><br><span class="line"></span><br><span class="line">Initializing provider plugins...</span><br><span class="line">- Finding blazehu.com/edu/cos versions matching <span class="string">"0.1.0"</span>...</span><br><span class="line">- Installing blazehu.com/edu/cos v0.1.0...</span><br><span class="line">- Installed blazehu.com/edu/cos v0.1.0 (unauthenticated)</span><br><span class="line"></span><br><span class="line">Terraform has created a lock file .terraform.lock.hcl to record the provider</span><br><span class="line">selections it made above. Include this file <span class="keyword">in</span> your version control repository</span><br><span class="line">so that Terraform can guarantee to make the same selections by default when</span><br><span class="line">you run <span class="string">"terraform init"</span> <span class="keyword">in</span> the future.</span><br><span class="line"></span><br><span class="line">Terraform has been successfully initialized!</span><br></pre></td></tr></table></figure></li><li>run <code>terraform apply -auto-approve</code>, create a cos bucket<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"> &lt;= <span class="built_in">read</span> (data resources)</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># data.cos_bucket_data_source.test will be read during apply</span></span><br><span class="line">  <span class="comment"># (config refers to values not yet known)</span></span><br><span class="line"> &lt;= data <span class="string">"cos_bucket_data_source"</span> <span class="string">"test"</span>  &#123;</span><br><span class="line">      + id    = (known after apply)</span><br><span class="line">      + name  = (known after apply)</span><br><span class="line">      + owner = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># cos_bucket_resource.demo will be created</span></span><br><span class="line">  + resource <span class="string">"cos_bucket_resource"</span> <span class="string">"demo"</span> &#123;</span><br><span class="line">      + acl       = <span class="string">"public-read-write"</span></span><br><span class="line">      + id        = (known after apply)</span><br><span class="line">      + name      = <span class="string">"terraform-1251762279"</span></span><br><span class="line">      + update_at = (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line">cos_bucket_resource.demo: Creating...</span><br><span class="line">cos_bucket_resource.demo: Creation complete after 1s [id=terraform-1251762279]</span><br><span class="line">data.cos_bucket_data_source.test: Reading...</span><br><span class="line">data.cos_bucket_data_source.test: Read complete after 0s [id=terraform-1251762279]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure></li><li>change acl to <code>public-read-write</code>, run <code>terraform apply -auto-approve</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cos_bucket_resource.demo: Refreshing state... [id=terraform-1251762279]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  ~ update <span class="keyword">in</span>-place</span><br><span class="line"> &lt;= <span class="built_in">read</span> (data resources)</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># data.cos_bucket_data_source.test will be read during apply</span></span><br><span class="line">  <span class="comment"># (config refers to values not yet known)</span></span><br><span class="line"> &lt;= data <span class="string">"cos_bucket_data_source"</span> <span class="string">"test"</span>  &#123;</span><br><span class="line">      ~ id    = <span class="string">"terraform-1251762279"</span> -&gt; (known after apply)</span><br><span class="line">        name  = <span class="string">"terraform-1251762279"</span></span><br><span class="line">      ~ owner = <span class="string">"qcs::cam::uin/794369159:uin/794369159"</span> -&gt; (known after apply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># cos_bucket_resource.demo will be updated in-place</span></span><br><span class="line">  ~ resource <span class="string">"cos_bucket_resource"</span> <span class="string">"demo"</span> &#123;</span><br><span class="line">      ~ acl       = <span class="string">"public-read-write"</span> -&gt; <span class="string">"private"</span></span><br><span class="line">        id        = <span class="string">"terraform-1251762279"</span></span><br><span class="line">        name      = <span class="string">"terraform-1251762279"</span></span><br><span class="line">        <span class="comment"># (1 unchanged attribute hidden)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 0 to add, 1 to change, 0 to destroy.</span><br><span class="line">cos_bucket_resource.demo: Modifying... [id=terraform-1251762279]</span><br><span class="line">cos_bucket_resource.demo: Modifications complete after 1s [id=terraform-1251762279]</span><br><span class="line">data.cos_bucket_data_source.test: Reading... [id=terraform-1251762279]</span><br><span class="line">data.cos_bucket_data_source.test: Read complete after 0s [id=terraform-1251762279]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 0 added, 1 changed, 0 destroyed.</span><br></pre></td></tr></table></figure></li><li>verify if no changes, run <code>terraform apply -auto-approve</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cos_bucket_resource.demo: Refreshing state... [id=terraform-1251762279]</span><br><span class="line"></span><br><span class="line">No changes. Your infrastructure matches the configuration.</span><br><span class="line"></span><br><span class="line">Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 0 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure></li><li>destroy the resources, run <code>terraform destroy -auto-approve</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cos_bucket_resource.demo: Refreshing state... [id=terraform-1251762279]</span><br><span class="line"></span><br><span class="line">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</span><br><span class="line">  - destroy</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># cos_bucket_resource.demo will be destroyed</span></span><br><span class="line">  - resource <span class="string">"cos_bucket_resource"</span> <span class="string">"demo"</span> &#123;</span><br><span class="line">      - acl       = <span class="string">"private"</span> -&gt; null</span><br><span class="line">      - id        = <span class="string">"terraform-1251762279"</span> -&gt; null</span><br><span class="line">      - name      = <span class="string">"terraform-1251762279"</span> -&gt; null</span><br><span class="line">      - update_at = <span class="string">"2022-01-29T11:28:31+08:00"</span> -&gt; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Plan: 0 to add, 0 to change, 1 to destroy.</span><br><span class="line">cos_bucket_resource.demo: Destroying... [id=terraform-1251762279]</span><br><span class="line">cos_bucket_resource.demo: Destruction complete after 1s</span><br><span class="line"></span><br><span class="line">Destroy complete! Resources: 1 destroyed.</span><br></pre></td></tr></table></figure><blockquote><p>Tip: You can also retrieve detailed Terraform and provider logs by setting the environment variable TF_LOG. Please include a detailed logs with any bug reports so the author can identify and address the bug. To learn more about log levels and how to interpret a crash log, refer to the <a href="https://www.terraform.io/internals/debugging" target="_blank" rel="noopener">Debugging Terraform Documentation</a>.</p></blockquote></li></ol><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://www.terraform.io/plugin" target="_blank" rel="noopener">https://www.terraform.io/plugin</a></li><li><a href="https://learn.hashicorp.com/collections/terraform/providers" target="_blank" rel="noopener">https://learn.hashicorp.com/collections/terraform/providers</a></li><li><a href="https://cloud.tencent.com/developer/article/1067230" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1067230</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Terraform is an open source resource orchestration tool based on Golang, which allows users to manage and configure any infrastructure, the infrastructure of public and private cloud services, and external services.&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
  </entry>
  
  <entry>
    <title>Terraform Best Practices</title>
    <link href="https://blazehu.github.io/2021/12/05/cloudnative/terraform/"/>
    <id>https://blazehu.github.io/2021/12/05/cloudnative/terraform/</id>
    <published>2021-12-04T16:00:00.000Z</published>
    <updated>2022-08-10T08:46:48.231Z</updated>
    
    <content type="html"><![CDATA[<p>Terraform是一种开源工具，用于安全高效地预览，配置和管理云基础架构和资源。</p><a id="more"></a><h3 id="一、安装-Terraform"><a href="#一、安装-Terraform" class="headerlink" title="一、安装 Terraform"></a>一、安装 Terraform</h3><h4 id="1、下载-Terraform"><a href="#1、下载-Terraform" class="headerlink" title="1、下载 Terraform"></a>1、下载 Terraform</h4><p>官方提供了最新版本的Terraform <a href="https://www.terraform.io/downloads.html" target="_blank" rel="noopener">可用下载</a></p><p>输入下载及安装命令行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># download terraform</span></span><br><span class="line">wget https://releases.hashicorp.com/terraform/1.0.10/terraform_1.0.10_linux_amd64.zip --no-check-certificate</span><br><span class="line"> </span><br><span class="line"><span class="comment"># unzip terraform</span></span><br><span class="line">unzip terraform_1.0.10_linux_amd64.zip</span><br></pre></td></tr></table></figure><h4 id="2、-配置环境变量"><a href="#2、-配置环境变量" class="headerlink" title="2、 配置环境变量"></a>2、 配置环境变量</h4><p>添加Terraform的环境变量，或者直接放在 <code>/usr/local/bin/</code> 目录下</p><p><img src="/2021/12/05/cloudnative/terraform/version.png" alt></p><h3 id="二、使用-Terraform-管理腾讯云"><a href="#二、使用-Terraform-管理腾讯云" class="headerlink" title="二、使用 Terraform 管理腾讯云"></a>二、使用 Terraform 管理腾讯云</h3><p>下面是Terraform管理腾讯云资源的具体方法：</p><h4 id="1、-Terraform工作流程"><a href="#1、-Terraform工作流程" class="headerlink" title="1、 Terraform工作流程"></a>1、 Terraform工作流程</h4><p><img src="/2021/12/05/cloudnative/terraform/terraform1.png" alt></p><p>1、 一次性配置 provider 文件以支持Tencent Cloud的 OpenAPI.<br>2、使用Terraform配置语法生成 .tf 资源文件.<br>3、使用CLI实现腾讯云资源的管理.</p><p>Terraform会将整个资源部署情况更新在 *.tf.state 文件中，让用户在前端控制台和后端平台都清晰的把控自己的云资源。</p><h4 id="2、-配置腾讯云-provider-文件"><a href="#2、-配置腾讯云-provider-文件" class="headerlink" title="2、 配置腾讯云 provider 文件"></a>2、 配置腾讯云 provider 文件</h4><p>官方文档：<a href="https://registry.terraform.io/providers/tencentcloudstack/tencentcloud/latest/docs" target="_blank" rel="noopener">TencentCloud Provider</a></p><p>登录腾讯云，在访问管理中选择API秘钥管理，获得Secret_Id和Secret_Key</p><p><img src="/2021/12/05/cloudnative/terraform/capi.png" alt></p><p>在新目录下创建 provider.tf 文件，填入秘钥和区域信息</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$ vim provider.tf</span><br><span class="line"> </span><br><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    tencentcloud = &#123;</span><br><span class="line">      <span class="keyword">source</span>  = <span class="string">"tencentcloudstack/tencentcloud"</span></span><br><span class="line">      version = <span class="string">"1.60.5"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">provider <span class="string">"tencentcloud"</span> &#123;</span><br><span class="line">  secret_id  = <span class="string">"*******"</span></span><br><span class="line">  secret_key = <span class="string">"*******"</span></span><br><span class="line">  region     = <span class="string">"*******"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存该文件，执行 <code>terraform init</code> 初始化Terraform。</p><p>此步骤，Terraform会自动检测 provider.tf 文件中的 provider 字段，发送请求到Terraform官方GitHub下载最新版本腾讯云资源的模块和插件，初始化成功时当前脚本的版本信息也会显示出来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initialize</span></span><br><span class="line">$ terraform init</span><br></pre></td></tr></table></figure><p><img src="/2021/12/05/cloudnative/terraform/init.png" alt></p><p>当腾讯云脚本有新的版本发布时，可以通过<strong> terraform init -upgrade </strong>指令更新脚本，获取最新的应用。</p><p>同时，可以通过 <code>terraform plan</code> 预览将要完成的操作，准备好创建资源后，可以通过 <code>terraform apply</code> 进行资源部署，更多有关Terraform CLI 的信息请<a href="(https://www.terraform.io/cli)">点击这里</a>。</p><blockquote><p>tips: NOTES 将秘钥直接填入到.tf文件中是十分不安全的，在多用户共同管理资源时，不建议把腾讯云API 的秘钥直接写到源代码里，以免一不小心更新到公开的版本中，造成安全风险。</p></blockquote><p>腾讯云提供了另一种更为安全可靠的方式，把秘钥信息放在环境变量中配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Configure the secret key in the environment path</span></span><br><span class="line">$ <span class="built_in">export</span> TENCENTCLOUD_SECRET_ID=<span class="string">"your_accessid"</span></span><br><span class="line">$ <span class="built_in">export</span> TENCENTCLOUD_SECRET_KEY=<span class="string">"your_accesskey"</span></span><br><span class="line">$ <span class="built_in">export</span> TENCENTCLOUD_REGION=<span class="string">"ap-shanghai"</span></span><br></pre></td></tr></table></figure><p>这样在 provider.tf 文件中就可以省略掉相关信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim provider.tf</span><br><span class="line"></span><br><span class="line">provider <span class="string">"tencentcloud"</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="3、-部署腾讯云资源"><a href="#3、-部署腾讯云资源" class="headerlink" title="3、 部署腾讯云资源"></a>3、 部署腾讯云资源</h4><p>下面提供一个创建腾讯云对象存储（COS）存储桶的实际用例。</p><p>创建实例资源文件</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">resource <span class="string">"tencentcloud_cos_bucket"</span> <span class="string">"mycos"</span> &#123;</span><br><span class="line">  bucket = <span class="string">"mycos-1251762279"</span></span><br><span class="line">  acl    = <span class="string">"private"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"tencentcloud_cos_bucket_object"</span> <span class="string">"myobject"</span> &#123;</span><br><span class="line">  bucket  = tencentcloud_cos_bucket.mycos.bucket</span><br><span class="line">  key     = <span class="string">"new_object_key"</span></span><br><span class="line">  content = <span class="string">"the content that you want to upload."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，上传文件至存储桶没有直接填写具体参数信息，而是引用<strong> “tencentcloud_cos_bucket.mycos.bucket” </strong>。</p><p>执行<strong> terraform plan </strong>查看部署计划，一共有2个资源计划创建</p><p><img src="/2021/12/05/cloudnative/terraform/plan.png" alt></p><p>这里参数前面的+ 代表新添加的资源，当销毁资源时，参数前面对应的符号会变为- ；更改一些参数需要重新部署资源时，该资源前面的符号为-/+；在旧参数和新参数内容之间有→ 符号标识</p><p>执行<strong> terraform apply </strong>进行资源创建</p><p><img src="/2021/12/05/cloudnative/terraform/apply1.png" alt><br><img src="/2021/12/05/cloudnative/terraform/apply2.png" alt></p><p>回到控制台，可以看到刚刚部署的资源已经生效</p><p><img src="/2021/12/05/cloudnative/terraform/apply3.png" alt></p><p>执行<strong> terraform destroy </strong>进行资源销毁（控制台中也同步了销毁操作）</p><p><img src="/2021/12/05/cloudnative/terraform/destroy1.png" alt><br><img src="/2021/12/05/cloudnative/terraform/destroy2.png" alt></p><h3 id="三、使用-Terraform-管理-Helm"><a href="#三、使用-Terraform-管理-Helm" class="headerlink" title="三、使用 Terraform 管理 Helm"></a>三、使用 Terraform 管理 Helm</h3><p>下面是Terraform管理 Helm 的具体方法：</p><h4 id="1、-配置-Helm-provider-文件"><a href="#1、-配置-Helm-provider-文件" class="headerlink" title="1、 配置 Helm provider 文件"></a>1、 配置 Helm provider 文件</h4><p>官方文档：<a href="https://registry.terraform.io/providers/hashicorp/helm/latest/docs" target="_blank" rel="noopener">Helm Provider</a></p><p>修改 provider.tf 文件并初始化</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    tencentcloud = &#123;</span><br><span class="line">      <span class="keyword">source</span>  = <span class="string">"tencentcloudstack/tencentcloud"</span></span><br><span class="line">      version = <span class="string">"1.60.5"</span></span><br><span class="line">    &#125;</span><br><span class="line">    helm = &#123;</span><br><span class="line">      <span class="keyword">source</span>  = <span class="string">"hashicorp/helm"</span></span><br><span class="line">      version = <span class="string">"2.4.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider <span class="string">"tencentcloud"</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">provider <span class="string">"helm"</span> &#123;</span><br><span class="line">  kubernetes &#123;</span><br><span class="line">    config_path = <span class="string">"/etc/rancher/k3s/k3s.yaml"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/05/cloudnative/terraform/helm_init.png" alt></p><h4 id="2、-部署-Helm-Chart"><a href="#2、-部署-Helm-Chart" class="headerlink" title="2、 部署 Helm Chart"></a>2、 部署 Helm Chart</h4><p>这里提供一个 Mysql Chart 的简单用例</p><p><a href="https://helm.sh/docs/intro/quickstart/" target="_blank" rel="noopener">Helm 官方文档</a><br><a href="https://artifacthub.io/" target="_blank" rel="noopener">Artifact Hub</a></p><p><strong>Helm Chart仓库</strong><br><img src="/2021/12/05/cloudnative/terraform/helm_chart.png" alt></p><p><strong>创建实例资源文件</strong></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">resource <span class="string">"helm_release"</span> <span class="string">"mysql"</span> &#123;</span><br><span class="line">  name      = <span class="string">"mysql-terraform"</span></span><br><span class="line">  chart     = <span class="string">"mysql"</span></span><br><span class="line">  version   = <span class="string">"8.8.14"</span></span><br><span class="line">  <span class="keyword">namespace</span> = <span class="string">"blazehu"</span></span><br><span class="line"></span><br><span class="line">  repository = <span class="string">"https://charts.bitnami.com/bitnami"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> &#123;</span><br><span class="line">    name  = <span class="string">"auth.rootPassword"</span></span><br><span class="line">    value = <span class="string">"123456!@#"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到通过 <code>set</code> 重新设置了 <code>mysql</code> 的 <code>root</code> 密码</p><p>执行<strong> terraform plan </strong>查看部署计划，一共有3个资源计划创建</p><p><img src="/2021/12/05/cloudnative/terraform/helm_mysql.png" alt><br><img src="/2021/12/05/cloudnative/terraform/helm_mysql2.png" alt></p><p>执行<strong> terraform apply </strong>进行资源创建</p><p><img src="/2021/12/05/cloudnative/terraform/helm_apply.png" alt></p><p>控制台，可以看到 Helm Chart 部署完成，且相关资源都正常启动</p><p><img src="/2021/12/05/cloudnative/terraform/helm_apply2.png" alt></p><p>反复执行<strong> terraform apply </strong>进行资源更新，可以看到资源没有变更</p><p><img src="/2021/12/05/cloudnative/terraform/helm_update.png" alt></p><blockquote><p>tips：可以通过 ignore_changes 忽略部分变更的更新动作</p></blockquote><p>执行<strong> terraform destroy </strong>进行资源销毁（控制台中也同步了销毁操作）</p><p><img src="/2021/12/05/cloudnative/terraform/helm_destroy.png" alt></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.terraform.io/intro" target="_blank" rel="noopener">https://www.terraform.io/intro</a></li><li><a href="https://cloud.tencent.com/developer/inventory/2539" target="_blank" rel="noopener">https://cloud.tencent.com/developer/inventory/2539</a></li><li><a href="https://cloud.tencent.com/developer/article/1560534" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1560534</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Terraform是一种开源工具，用于安全高效地预览，配置和管理云基础架构和资源。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
  </entry>
  
  <entry>
    <title>TIC Best Practices</title>
    <link href="https://blazehu.github.io/2021/12/04/cloudnative/terraform_tic/"/>
    <id>https://blazehu.github.io/2021/12/04/cloudnative/terraform_tic/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2022-08-12T06:28:34.465Z</updated>
    
    <content type="html"><![CDATA[<p>TIC 是腾讯云推出的 IaC 开放平台，融合多种业内优秀的开源技术，通过 IaC 的方式解决您在云基础设施管理中面临的效率、成本和安全问题。</p><a id="more"></a><blockquote><p>TIC 提供了资源编排、配置管理和合规检查三大功能模块，支持 HCL（Terraform）格式语法编写，同时提供丰富的基于腾讯云最佳实践的公共模板，有效降低您的学习、使用难度。</p></blockquote><h3 id="操作指南"><a href="#操作指南" class="headerlink" title="操作指南"></a>操作指南</h3><p><a href="https://cloud.tencent.com/document/product/1213" target="_blank" rel="noopener">产品文档</a>非常详细了，以下就不赘述，下面提供一个创建腾讯云对象存储（COS）存储桶的实际用例。</p><h3 id="控制台部署腾讯云资源"><a href="#控制台部署腾讯云资源" class="headerlink" title="控制台部署腾讯云资源"></a>控制台部署腾讯云资源</h3><h4 id="新建资源栈"><a href="#新建资源栈" class="headerlink" title="新建资源栈"></a>新建资源栈</h4><p><img src="/2021/12/04/cloudnative/terraform_tic/tic1.png" alt></p><h4 id="创建-cos-资源描述文件"><a href="#创建-cos-资源描述文件" class="headerlink" title="创建 cos 资源描述文件"></a>创建 cos 资源描述文件</h4><p>创建 <code>cos.tf</code> 文件<br><img src="/2021/12/04/cloudnative/terraform_tic/tic2.png" alt></p><p>文件内容如下：</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">resource <span class="string">"tencentcloud_cos_bucket"</span> <span class="string">"demo"</span> &#123;</span><br><span class="line">  bucket = <span class="string">"demo-1251762279"</span></span><br><span class="line">  acl    = <span class="string">"private"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="预览结果-terraform-plan"><a href="#预览结果-terraform-plan" class="headerlink" title="预览结果 (terraform plan)"></a>预览结果 (terraform plan)</h4><p><img src="/2021/12/04/cloudnative/terraform_tic/tic3.png" alt></p><h4 id="发布-terraform-apply"><a href="#发布-terraform-apply" class="headerlink" title="发布 (terraform apply)"></a>发布 (terraform apply)</h4><p><img src="/2021/12/04/cloudnative/terraform_tic/tic4.png" alt></p><p><img src="/2021/12/04/cloudnative/terraform_tic/tic5.png" alt></p><p><strong>回到控制台，可以看到刚刚部署的资源已经生效</strong></p><p><img src="/2021/12/04/cloudnative/terraform_tic/tic6.png" alt></p><p><strong>销毁资源，控制台对应的资源也会销毁</strong></p><p><img src="/2021/12/04/cloudnative/terraform_tic/tic7.png" alt></p><h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><h4 id="使用-API-Explorer-生成代码"><a href="#使用-API-Explorer-生成代码" class="headerlink" title="使用 API Explorer 生成代码"></a>使用 API Explorer 生成代码</h4><p><a href="https://console.cloud.tencent.com/api/explorer?Product=tic&Version=2020-11-17&Action=PlanStack&SignVersion=" target="_blank" rel="noopener">调试地址</a></p><p><img src="/2021/12/04/cloudnative/terraform_tic/tic_api.png" alt></p><h4 id="Golang-Example"><a href="#Golang-Example" class="headerlink" title="Golang Example"></a>Golang Example</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"</span></span><br><span class="line"><span class="string">"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/errors"</span></span><br><span class="line"><span class="string">"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/profile"</span></span><br><span class="line">tic <span class="string">"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/tic/v20201117"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describeStacks</span><span class="params">(client *tic.Client)</span> []*<span class="title">tic</span>.<span class="title">StackInfo</span></span> &#123;</span><br><span class="line">request := tic.NewDescribeStacksRequest()</span><br><span class="line">response, err := client.DescribeStacks(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response.Response.Stacks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createStack</span><span class="params">(client *tic.Client, name, region, templateUrl <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">request := tic.NewCreateStackRequest()</span><br><span class="line">request.StackName = common.StringPtr(name)</span><br><span class="line">request.StackRegion = common.StringPtr(region)</span><br><span class="line">request.TemplateUrl = common.StringPtr(templateUrl)</span><br><span class="line"></span><br><span class="line">response, err := client.CreateStack(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response.Response.StackId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteStack</span><span class="params">(client *tic.Client, stackId <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">request := tic.NewDeleteStackRequest()</span><br><span class="line">request.StackId = common.StringPtr(stackId)</span><br><span class="line"></span><br><span class="line">_, err := client.DeleteStack(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describeStackVersions</span><span class="params">(client *tic.Client)</span> []*<span class="title">tic</span>.<span class="title">VersionInfo</span></span> &#123;</span><br><span class="line">request := tic.NewDescribeStackVersionsRequest()</span><br><span class="line"></span><br><span class="line">response, err := client.DescribeStackVersions(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response.Response.Versions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">planStack</span><span class="params">(client *tic.Client, stackId, versionId <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">request := tic.NewPlanStackRequest()</span><br><span class="line">request.StackId = common.StringPtr(stackId)</span><br><span class="line">request.VersionId = common.StringPtr(versionId)</span><br><span class="line"></span><br><span class="line">response, err := client.PlanStack(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, response.ToJsonString())</span><br><span class="line"><span class="keyword">return</span> response.Response.EventId</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applyStack</span><span class="params">(client *tic.Client, stackId, versionId <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">request := tic.NewApplyStackRequest()</span><br><span class="line">request.StackId = common.StringPtr(stackId)</span><br><span class="line">request.VersionId = common.StringPtr(versionId)</span><br><span class="line"></span><br><span class="line">response, err := client.ApplyStack(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, response.ToJsonString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describeStackEvent</span><span class="params">(client *tic.Client, eventId <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">request := tic.NewDescribeStackEventRequest()</span><br><span class="line">request.EventId = common.StringPtr(eventId)</span><br><span class="line"></span><br><span class="line">response, err := client.DescribeStackEvent(request)</span><br><span class="line"><span class="keyword">if</span> _, ok := err.(*errors.TencentCloudSDKError); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"An API error has returned: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *response.Response.Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">credential := common.NewCredential(</span><br><span class="line"><span class="string">"SecretId"</span>,</span><br><span class="line"><span class="string">"SecretKey"</span>,</span><br><span class="line">)</span><br><span class="line">cpf := profile.NewClientProfile()</span><br><span class="line">cpf.HttpProfile.Endpoint = <span class="string">"tic.tencentcloudapi.com"</span></span><br><span class="line">client, _ := tic.NewClient(credential, <span class="string">""</span>, cpf)</span><br><span class="line">region := <span class="string">"ap-shanghai"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取资源栈列表</span></span><br><span class="line">stacks := describeStacks(client)</span><br><span class="line"><span class="keyword">for</span> _, stack := <span class="keyword">range</span> stacks &#123;</span><br><span class="line"><span class="comment">//删除资源栈</span></span><br><span class="line">deleteStack(client, *stack.StackId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建资源栈</span></span><br><span class="line">createStack(client, <span class="string">"demo"</span>, region, <span class="string">""</span>)</span><br><span class="line"><span class="comment">//获取版本列表</span></span><br><span class="line">versions := describeStackVersions(client)</span><br><span class="line"><span class="keyword">for</span> _, version := <span class="keyword">range</span> versions &#123;</span><br><span class="line">fmt.Println(*version.StackId, *version.VersionId, *version.VersionName)</span><br><span class="line"><span class="comment">//执行Plan事件</span></span><br><span class="line">planStack(client, *version.StackId, *version.VersionId)</span><br><span class="line"><span class="comment">//等待事件完成</span></span><br><span class="line">time.Sleep(time.Second * <span class="number">30</span>)</span><br><span class="line"><span class="comment">//执行Apply事件</span></span><br><span class="line">applyStack(client, *version.StackId, *version.VersionId)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="templateUrl-⽬前仅限-COS-URL"><a href="#templateUrl-⽬前仅限-COS-URL" class="headerlink" title="templateUrl (⽬前仅限 COS URL)"></a>templateUrl (⽬前仅限 COS URL)</h5><p><strong>这里需要注意的是 templateUrl 参数 <span style="color:red">（模板 URL，⽬前仅限 COS URL, ⽂件为zip压缩格式）</span>，压缩为 zip 文件上传 cos。<strong></strong></strong></p><p><img src="/2021/12/04/cloudnative/terraform_tic/tic8.png" alt></p><p><img src="/2021/12/04/cloudnative/terraform_tic/tic9.png" alt></p><h5 id="API-调用执行"><a href="#API-调用执行" class="headerlink" title="API 调用执行"></a>API 调用执行</h5><p><img src="/2021/12/04/cloudnative/terraform_tic/tic10.png" alt></p><p>回到控制台，可以看到刚刚调用生效<br><img src="/2021/12/04/cloudnative/terraform_tic/tic11.png" alt></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://cloud.tencent.com/document/product/1213" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/1213</a></li><li><a href="https://cloud.tencent.com/document/api/1213/50586" target="_blank" rel="noopener">https://cloud.tencent.com/document/api/1213/50586</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;TIC 是腾讯云推出的 IaC 开放平台，融合多种业内优秀的开源技术，通过 IaC 的方式解决您在云基础设施管理中面临的效率、成本和安全问题。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
  </entry>
  
  <entry>
    <title>Helm3 简介</title>
    <link href="https://blazehu.github.io/2021/12/03/cloudnative/helm3/"/>
    <id>https://blazehu.github.io/2021/12/03/cloudnative/helm3/</id>
    <published>2021-12-02T16:00:00.000Z</published>
    <updated>2022-07-26T05:54:51.354Z</updated>
    
    <content type="html"><![CDATA[<p>Helm is the best way to find, share, and use software built for Kubernetes.</p><a id="more"></a><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>想成功和正确地使用Helm，需要以下前置条件。</p><ol><li>一个 Kubernetes 集群</li><li>确定你安装版本的安全配置</li><li>安装和配置Helm。</li></ol><h3 id="三大概念"><a href="#三大概念" class="headerlink" title="三大概念"></a>三大概念</h3><p>Chart 代表着 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Homebrew formula，Apt dpkg，或 Yum RPM 在Kubernetes 中的等价物。</p><p>Repository（仓库） 是用来存放和共享 charts 的地方。它就像 Perl 的 CPAN 档案库网络 或是 Fedora 的 软件包仓库，只不过它是供 Kubernetes 包所使用的。</p><p>Release 是运行在 Kubernetes 集群中的 chart 的实例。一个 chart 通常可以在同一个集群中安装多次。每一次安装都会创建一个新的 release。以 MySQL chart为例，如果你想在你的集群中运行两个数据库，你可以安装该chart两次。每一个数据库都会拥有它自己的 release 和 release name。</p><p>在了解了上述这些概念以后，我们就可以这样来解释 Helm：</p><p>Helm 安装 charts 到 Kubernetes 集群中，每次安装都会创建一个新的 release。你可以在 Helm 的 chart repositories 中寻找新的 chart。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我这里直接下载二进制文件，解压后移动到 /usr/local/bin/</p><p><img src="/2021/12/03/cloudnative/helm3/version.png" alt></p><p><a href="https://helm.sh/zh/docs/intro/install/" target="_blank" rel="noopener">安装指南</a><br><a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener">下载地址</a></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br></pre></td></tr></table></figure><p><img src="/2021/12/03/cloudnative/helm3/repo.png" alt></p><h4 id="查看可以安装的charts列表"><a href="#查看可以安装的charts列表" class="headerlink" title="查看可以安装的charts列表"></a>查看可以安装的charts列表</h4><p><code>helm search hub</code> 从 <a href="https://artifacthub.io/" target="_blank" rel="noopener">Artifact Hub</a> 中查找并列出 <code>helm charts</code>。 <a href="https://artifacthub.io/" target="_blank" rel="noopener">Artifact Hub</a> 中存放了大量不同的仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm search repo bitnami</span><br></pre></td></tr></table></figure><p><img src="/2021/12/03/cloudnative/helm3/search.png" alt></p><h3 id="安装Chart示例"><a href="#安装Chart示例" class="headerlink" title="安装Chart示例"></a>安装Chart示例</h3><p>由于我是用的<code>k3s</code> ，而<strong> helm v3 </strong>版本不再需要 Tiller，而是直接访问ApiServer来与k8s交互，通过环境变量<code>KUBECONFIG</code>来读取存有ApiServer的地址与token的配置文件地址，默认地址为<code>~/.kube/config</code> ，所以需要配置环境变量<code>export KUBECONFIG=/etc/rancher/k3s/k3s.yaml</code></p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/rancher/k3s/k3s.yaml</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace blazehu</span><br><span class="line">helm install bitnami/mysql --generate-name -n blazehu</span><br></pre></td></tr></table></figure><p><img src="/2021/12/03/cloudnative/helm3/mysql.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm show chart bitnami/mysql   获取关于该chart的基本信息</span><br><span class="line">helm show all bitnami/mysql     获取关于该chart的所有信息</span><br></pre></td></tr></table></figure><h4 id="查看发布的版本"><a href="#查看发布的版本" class="headerlink" title="查看发布的版本"></a>查看发布的版本</h4><p><img src="/2021/12/03/cloudnative/helm3/helm_list.png" alt></p><h4 id="卸载一个版本"><a href="#卸载一个版本" class="headerlink" title="卸载一个版本"></a>卸载一个版本</h4><p>该命令会从Kubernetes卸载 <strong>mysql-1638628962</strong>， 它将删除和该版本相关的所有相关资源（<code>service</code>、<code>deployment</code>、 <code>pod</code>等等）甚至版本历史。</p><p><img src="/2021/12/03/cloudnative/helm3/helm_uninstall.png" alt></p><p><code>helm uninstall</code> 的时候提供 <code>--keep-history</code> 选项， Helm将会保存版本历史。 可以通过命令查看该版本的信息。</p><p><img src="/2021/12/03/cloudnative/helm3/helm_uninstall2.png" alt></p><h4 id="访问-mysql"><a href="#访问-mysql" class="headerlink" title="访问 mysql"></a>访问 mysql</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROOT_PASSWORD=$(kubectl get secret --namespace blazehu mysql-1638633054 -o jsonpath=<span class="string">"&#123;.data.mysql-root-password&#125;"</span> | base64 --decode)</span><br><span class="line">kubectl get svc -n blazehu</span><br><span class="line">mysql -h<span class="variable">$&#123;HOST&#125;</span> -uroot -p<span class="variable">$&#123;ROOT_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/12/03/cloudnative/helm3/mysql_client.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Helm is the best way to find, share, and use software built for Kubernetes.&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="helm" scheme="https://blazehu.github.io/tags/helm/"/>
    
  </entry>
  
  <entry>
    <title>查询外网出口IP</title>
    <link href="https://blazehu.github.io/2021/12/02/common/ip/"/>
    <id>https://blazehu.github.io/2021/12/02/common/ip/</id>
    <published>2021-12-01T16:00:00.000Z</published>
    <updated>2022-07-26T05:43:43.630Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ifconfig.me</span><br><span class="line"></span><br><span class="line">curl icanhazip.com</span><br><span class="line"></span><br><span class="line">curl ipinfo.io/ip</span><br><span class="line"></span><br><span class="line">curl ipecho.net/plain</span><br><span class="line"></span><br><span class="line">curl www.trackip.net/i</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl ifconfig.me&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL 主从同步</title>
    <link href="https://blazehu.github.io/2020/03/24/pgsql/pgsql_master_slave/"/>
    <id>https://blazehu.github.io/2020/03/24/pgsql/pgsql_master_slave/</id>
    <published>2020-03-23T16:00:00.000Z</published>
    <updated>2022-07-26T05:54:00.781Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 9.0 引入了主备流复制机制，流复制每次传输单位是 WAL 日志的 record。通过流复制备库不断的从主库同步相应的数据，并在备库 apply 每个 WAL record 。</p><a id="more"></a><blockquote><p>NOTES: PostgreSQL 9.0 之前提供的方法是主库写完一个 WAL 日志文件后，才把 WAL 日志文件传送到备库，这样的方式会导致主备延迟特别大。同时 PostgreSQL 9.0 之后提供了 Hot Standby ，备库在应用 WAL record 的同时也能够提供只读服务，大大提升了用户体验。</p></blockquote><h3 id="配置主库"><a href="#配置主库" class="headerlink" title="配置主库"></a>配置主库</h3><p>pgsql 通过容器部署，这里使用 <code>docker-compose</code><br>主库： 192.168.0.1<br>从库： 192.168.0.2</p><h4 id="启动主库"><a href="#启动主库" class="headerlink" title="启动主库"></a>启动主库</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pgsql:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">postgres:9.6</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">pgsql</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=postgres</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/var/lib/postgresql/data:/var/lib/postgresql/data</span></span><br></pre></td></tr></table></figure><h4 id="新建归档日志目录"><a href="#新建归档日志目录" class="headerlink" title="新建归档日志目录"></a>新建归档日志目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ti pgsql bash</span><br><span class="line"></span><br><span class="line">mkdir -p /var/lib/postgresql/data/pg_archive</span><br></pre></td></tr></table></figure><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> replica login <span class="keyword">replication</span> encrypted <span class="keyword">password</span> <span class="string">'replica'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否创建成功</span></span><br><span class="line">\du</span><br></pre></td></tr></table></figure><h4 id="修改-pg-hba-conf-文件-从库ip"><a href="#修改-pg-hba-conf-文件-从库ip" class="headerlink" title="修改 pg_hba.conf 文件 (从库ip)"></a>修改 pg_hba.conf 文件 (从库ip)</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">host replication replica 192.168.0.2/32 trust</span><br></pre></td></tr></table></figure><h4 id="修改-postgresql-conf"><a href="#修改-postgresql-conf" class="headerlink" title="修改 postgresql.conf"></a>修改 postgresql.conf</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">listen_addresses</span> = <span class="string">'*'</span>     <span class="comment"># 监听所有 IP</span></span><br><span class="line"><span class="attr">wal_level</span> = hot_standby    <span class="comment"># 开启热备</span></span><br><span class="line"><span class="attr">max_wal_senders</span> = <span class="number">32</span>       <span class="comment"># 这个设置了可以最多有几个流复制连接，差不多有几个从，就设置几个</span></span><br><span class="line"><span class="attr">wal_keep_segments</span> = <span class="number">64</span>     <span class="comment"># 设置流复制保留的最多的 xlog 数目，一份是 16M，注意机器磁盘 16M * 64 = 1G</span></span><br><span class="line"><span class="attr">wal_sender_timeout</span> = <span class="number">60</span>    <span class="comment"># 设置流复制主机发送数据的超时时间</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">500</span>      <span class="comment"># 这个设置要注意下，从库的 max_connections 必须要大于主库的</span></span><br><span class="line"><span class="attr">archive_mode</span> = <span class="literal">on</span>          <span class="comment"># 允许归档</span></span><br><span class="line">                           <span class="comment"># 用该命令来归档logfile segment</span></span><br><span class="line"><span class="attr">archive_command</span> = <span class="string">'cp %p /var/lib/postgresql/data/pg_archive/%f'</span></span><br></pre></td></tr></table></figure><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart pgsql</span><br></pre></td></tr></table></figure><h3 id="配置从库"><a href="#配置从库" class="headerlink" title="配置从库"></a>配置从库</h3><h4 id="启动从库"><a href="#启动从库" class="headerlink" title="启动从库"></a>启动从库</h4><p>拷贝 <code>docker-compose</code> 文件, 并拉起容器</p><h4 id="拷贝主服务器数据"><a href="#拷贝主服务器数据" class="headerlink" title="拷贝主服务器数据"></a>拷贝主服务器数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清除从库数据</span></span><br><span class="line">rm -rf /var/lib/postgresql/data/*  </span><br><span class="line"></span><br><span class="line">pg_basebackup -h 192.168.0.1 -U replica -D /var/lib/postgresql/data -X stream -P</span><br><span class="line"></span><br><span class="line">mkdir -p /var/lib/postgresql/data/pg_archive</span><br></pre></td></tr></table></figure><h4 id="添加-recovery-conf-文件"><a href="#添加-recovery-conf-文件" class="headerlink" title="添加 recovery.conf 文件"></a>添加 recovery.conf 文件</h4><p>recovery.conf</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">standby_mode</span> = <span class="literal">on</span>    </span><br><span class="line"><span class="attr">primary_conninfo</span> = <span class="string">'host=192.168.0.1 port=5432 user=replica password=replica'</span> </span><br><span class="line"><span class="attr">recovery_target_timeline</span> = <span class="string">'latest'</span></span><br></pre></td></tr></table></figure><h4 id="修改-postgresql-conf-1"><a href="#修改-postgresql-conf-1" class="headerlink" title="修改 postgresql.conf"></a>修改 postgresql.conf</h4><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">wal_level</span> = hot_standby</span><br><span class="line"><span class="attr">hot_standby_feedback</span> = <span class="literal">on</span>             <span class="comment"># 如果有错误的数据复制，是否向主进行反馈</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">1000</span>                <span class="comment"># 一般查多于写的应用从库的最大连接数要比较大</span></span><br><span class="line"><span class="attr">hot_standby</span> = <span class="literal">on</span>                      <span class="comment"># 说明这台机器不仅仅是用于数据归档，也用于数据查询</span></span><br><span class="line"><span class="attr">max_standby_streaming_delay</span> = <span class="number">30</span>s     <span class="comment"># 数据流备份的最大延迟时间</span></span><br><span class="line"><span class="attr">wal_receiver_status_interval</span> = <span class="number">10</span>s    <span class="comment"># 多久向主报告一次从的状态，当然从每次数据复制都会向主报告状态，这里只是设置最长的间隔时间</span></span><br></pre></td></tr></table></figure><h4 id="重启从库"><a href="#重启从库" class="headerlink" title="重启从库"></a>重启从库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart pgsql-slave</span><br></pre></td></tr></table></figure><h3 id="验证主从"><a href="#验证主从" class="headerlink" title="验证主从"></a>验证主从</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> client_addr, sync_state <span class="keyword">from</span> pg_stat_replication;</span><br><span class="line"></span><br><span class="line">ps -ef 查看进程是否存在</span><br></pre></td></tr></table></figure><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/lib/postgresql/9.6/bin/pg_ctl -D /var/lib/postgresql/data status</span><br><span class="line"></span><br><span class="line">pg_controldata /var/lib/postgresql/data</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.runoob.com/postgresql/postgresql-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/postgresql/postgresql-tutorial.html</a></li><li><a href="http://mysql.taobao.org/monthly/2015/10/04/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/10/04/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;PostgreSQL 9.0 引入了主备流复制机制，流复制每次传输单位是 WAL 日志的 record。通过流复制备库不断的从主库同步相应的数据，并在备库 apply 每个 WAL record 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pgsql" scheme="https://blazehu.github.io/tags/pgsql/"/>
    
  </entry>
  
</feed>
