<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小千世界</title>
  
  
  <link href="https://blazehu.github.io/atom.xml" rel="self"/>
  
  <link href="https://blazehu.github.io/"/>
  <updated>2025-07-02T15:50:59.807Z</updated>
  <id>https://blazehu.github.io/</id>
  
  <author>
    <name>BlazeHu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蓝盾从单机到Dind的实践（一）</title>
    <link href="https://blazehu.github.io/2025/06/27/devops/landun_dind/"/>
    <id>https://blazehu.github.io/2025/06/27/devops/landun_dind/</id>
    <published>2025-06-26T16:00:00.000Z</published>
    <updated>2025-07-02T15:50:59.807Z</updated>
    
    <content type="html"><![CDATA[<p>传统的单机构建环境在项目变大、任务变多时，容易出问题，比如容易崩溃、资源不够用、任务排队，以及成本和资源利用的矛盾。本文会介绍用容器化技术Docker-in-Docker（DinD）来解决这些问题，打造一个灵活、高效的CI/CD系统。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>当前构建环境因依赖单台机器，面临诸多挑战：</p><ul><li>单点故障风险，硬件或网络故障易致构建流程中断；</li><li>资源瓶颈，频繁的构建任务使机器负载过高，频繁触发告警，影响系统稳定性；</li><li>任务堆积，大量任务积压致后续任务延迟甚至超时失败，降低构建效率；</li><li>成本与资源利用问题，增加机器虽可缓解资源紧张，但会增加运维和硬件成本，且任务非持续高峰，部分时间资源闲置浪费。</li></ul><h3 id="2-技术选型方案"><a href="#2-技术选型方案" class="headerlink" title="2. 技术选型方案"></a>2. 技术选型方案</h3><h4 id="2-1-Kaniko"><a href="#2-1-Kaniko" class="headerlink" title="2.1 Kaniko"></a>2.1 Kaniko</h4><p>Kaniko 是谷歌开源的一款构建容器镜像的工具。Kaniko 并不依赖于 Docker 守护进程，完全在用户空间根据 Dockerfile 的内容逐行执行命令来构建镜像，这就使得在一些无法获取 docker 守护 进程的环境下也能够构建镜像。<br><img src="/2025/06/27/devops/landun_dind/workflow.png" alt="alt text"></p><p>Kaniko 通过提取基础镜像的文件系统，按顺序执行 Dockerfile 中的指令，每执行一条指令后在用户空间创建文件系统的快照并与上一状态对比，若有变化则生成新镜像层并更新元数据，最终将构建好的镜像推送到镜像仓库。</p><h5 id="2-1-1-简单例子"><a href="#2-1-1-简单例子" class="headerlink" title="2.1.1 简单例子"></a>2.1.1 简单例子</h5><p>下面是一个使用kaniko的构建的简单例子</p><p><strong>创建密钥</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic -n blazehu kaniko-secret-common --from-file=config.json</span><br></pre></td></tr></table></figure><p><strong>构建测试</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kaniko</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kaniko</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">m.daocloud.io/gcr.io/kaniko-project/executor:latest</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--dockerfile=Dockerfile"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--context=git://user:password@github.com:blazehu/go-examples.git#master"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--destination=blazehu1122/example:latest"</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kaniko-secret</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/kaniko/.docker/</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kaniko-secret</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">kaniko-secret-common</span></span><br></pre></td></tr></table></figure><ul><li>使用 kaniko-project/executor:latest 镜像执行构建任务</li><li>构建参数 –context: 上下文指定 Git Repository（仅支持 git://[repository url][#reference][#commit-id] 格式）</li><li>构建参数 –destination: 指定配置的推送镜像的地址</li><li>镜像推送挂载了 kaniko-secret 密钥</li></ul><h5 id="2-1-2-构建新的CI镜像"><a href="#2-1-2-构建新的CI镜像" class="headerlink" title="2.1.2 构建新的CI镜像"></a>2.1.2 构建新的CI镜像</h5><p>那我们如何结合蓝盾来实现Dind呢？我们需要重新制作一个新的蓝盾CI镜像，参考《<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/ci-images/docker-build.md" target="_blank" rel="noopener">构建并托管一个 CI 镜像 </a>》，该CI镜像需要包括 kaniko 执行器。这里通过多阶段构建来制作新的CI镜像。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> m.daocloud.io/gcr.io/kaniko-project/executor:latest as kaniko</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> bkci/ci:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制必要文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=kaniko /kaniko /kaniko</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /kaniko/executor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt install -y git python-pip python3-pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip config <span class="built_in">set</span> install.trusted-host mirrors.aliyun.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:/kaniko</span><br><span class="line"><span class="keyword">ENV</span> DOCKER_CONFIG /kaniko/.docker</span><br><span class="line"><span class="keyword">ENV</span> SSL_CERT_DIR /kaniko/ssl/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 kaniko 可执行文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /kaniko/executor version</span></span><br></pre></td></tr></table></figure><h5 id="2-1-3-蓝盾流水线"><a href="#2-1-3-蓝盾流水线" class="headerlink" title="2.1.3 蓝盾流水线"></a>2.1.3 蓝盾流水线</h5><p><img src="/2025/06/27/devops/landun_dind/pipeline.png" alt="alt text"></p><ol><li>第一步使用蓝盾 Checkout 插件拉取代码</li><li>第二步使用蓝盾 Shell Script 插件执行 kaniko 构建命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kaniko/executor --context=/data/devops/workspace --dockerfile=Dockerfile --destination=blazehu1122/example:latest --ignore-path=/ <span class="string">"</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-Dind-Unix-Socket"><a href="#2-2-Dind-Unix-Socket" class="headerlink" title="2.2 Dind Unix Socket"></a>2.2 Dind Unix Socket</h4><p>使用 DaemonSet 来启动 Dind Pod，将 Docker socket 文件 /var/run/docker.sock 挂载到 Pod 中。在要使用Docker服务的 Pod 中都需要挂载 socket文件。</p><h5 id="2-2-1-简单例子"><a href="#2-2-1-简单例子" class="headerlink" title="2.2.1 简单例子"></a>2.2.1 简单例子</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dinp-daemonset</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dinp-daemonset</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">dinp-daemonset</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dind</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker:dind</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockersock</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockersock</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Socket</span></span><br></pre></td></tr></table></figure><p>在这个配置中，/var/run/docker.sock 被挂载到 Pod 中，允许 Pod 直接与宿主机上的 Docker 守护进程通信。这种方式不需要设置 DOCKER_HOST 环境变量，因为 Docker 客户端和守护进程直接通过 socket 文件通信。</p><h4 id="2-3-Dind-TCP"><a href="#2-3-Dind-TCP" class="headerlink" title="2.3 Dind TCP"></a>2.3 Dind TCP</h4><p>定义一个 Deployment 和一个 Service，用于启动一个包含 Dind 的 Pod，并通过 Service 对外提供 Docker 服务。在要使用Docker服务的 Pod 中设置 DOCKER_HOST 环境变量，使得 Docker 客户端知道如何连接到 Docker 守护进程（比如在bkci的基础镜像中注入该环境变量）。</p><h5 id="2-3-1-简单例子"><a href="#2-3-1-简单例子" class="headerlink" title="2.3.1 简单例子"></a>2.3.1 简单例子</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dind</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker:dind</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">"4Gi"</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">"2"</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">"8Gi"</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">"4"</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_TLS_CERTDIR</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">""</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">tcp://localhost:2375</span></span><br><span class="line">        <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> <span class="string">["docker",</span> <span class="string">"info"</span><span class="string">]</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">6</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> <span class="string">["docker",</span> <span class="string">"info"</span><span class="string">]</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment">## 污点配置</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"svc"</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">"bk"</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">              <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"app.kubernetes.io/name"</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">"In"</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">dockerhost</span></span><br><span class="line">            <span class="attr">topologyKey:</span> <span class="string">"kubernetes.io/hostname"</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-storage</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker_in_pod</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-run</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blueking/run</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bk-ci-docker-dinp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blueking</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">2375</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">2375</span></span><br></pre></td></tr></table></figure><p>在需要使用 Docker 的 Pod 中设置 DOCKER_HOST 环境变量为 bk-ci-docker-dinp.blueking.svc.cluster.local，通过 Kubernetes Service 的域名解析和端口转发机制，使 Pod 内的 Docker 客户端能够连接到后端的 Docker 守护进程。</p><h5 id="2-3-2-蓝盾流水线"><a href="#2-3-2-蓝盾流水线" class="headerlink" title="2.3.2 蓝盾流水线"></a>2.3.2 蓝盾流水线</h5><ol><li>第一步使用蓝盾 Checkout 插件拉取代码</li><li>第二步使用蓝盾 Shell Script 插件执行 docker 构建命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker context create dind --docker <span class="string">"host=tcp://bk-ci-docker-dinp.blueking.svc.cluster.local:2375,ca=/root/.docker/certs/ca.pem,cert=/root/.docker/certs/cert.pem,key=/root/.docker/certs/key.pem"</span> </span><br><span class="line">docker context use dind</span><br><span class="line"></span><br><span class="line">docker build --platform=linux/amd64 -t <span class="variable">$&#123;IMAGE_REPO&#125;</span>:<span class="variable">$&#123;IMAGE_TAG&#125;</span> -f Dockerfile . --push</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-技术选型对比"><a href="#3-技术选型对比" class="headerlink" title="3. 技术选型对比"></a>3. 技术选型对比</h3><table><thead><tr><th>特性/方案</th><th>Kaniko</th><th>Dind Unix Socket</th><th>Dind TCP</th></tr></thead><tbody><tr><td><strong>依赖环境</strong></td><td>不依赖 Docker 守护进程</td><td>依赖宿主机 Docker Socket</td><td>依赖宿主机 Docker 守护进程（TCP）</td></tr><tr><td><strong>部署复杂度</strong></td><td>简单，只需部署 Pod</td><td>中等，需要配置 DaemonSet</td><td>较复杂，需要配置 Deployment 和 Service</td></tr><tr><td><strong>资源消耗</strong></td><td>低</td><td>中等</td><td>较高</td></tr><tr><td><strong>安全性</strong></td><td>高</td><td>中等</td><td>中等</td></tr><tr><td><strong>适用场景</strong></td><td>Kubernetes 环境</td><td>单机或多节点集群</td><td>跨节点或 Kubernetes 集群</td></tr><tr><td><strong>蓝盾集成难度</strong></td><td>中等</td><td>低</td><td>中等</td></tr></tbody></table><p>虽然我们最终选择了 Kaniko 方案，但在实际应用中发现，基于 m.daocloud.io/gcr.io/kaniko-project/executor:latest 制作的蓝盾 CI 镜像存在一些兼容性问题。根据 Kaniko 的<a href="https://github.com/GoogleContainerTools/kaniko?tab=readme-ov-file#known-issues" target="_blank" rel="noopener">官方文档</a>，这种做法并不被推荐，可能会导致一些不可预见的问题。后续将根据蓝盾的官方文档和 Kaniko 的最佳实践，建议重新制作 CI 镜像。</p><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><ul><li><a href="https://github.com/GoogleContainerTools/kaniko" target="_blank" rel="noopener">https://github.com/GoogleContainerTools/kaniko</a></li><li><a href="https://juejin.cn/post/7217665415710081081" target="_blank" rel="noopener">https://juejin.cn/post/7217665415710081081</a></li><li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/ci-images/docker-build.md" target="_blank" rel="noopener">https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/ci-images/docker-build.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;传统的单机构建环境在项目变大、任务变多时，容易出问题，比如容易崩溃、资源不够用、任务排队，以及成本和资源利用的矛盾。本文会介绍用容器化技术Docker-in-Docker（DinD）来解决这些问题，打造一个灵活、高效的CI/CD系统。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="Dind" scheme="https://blazehu.github.io/tags/Dind/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾公共构建机（Docker）超时问题排查</title>
    <link href="https://blazehu.github.io/2024/08/20/devops/landun_clb/"/>
    <id>https://blazehu.github.io/2024/08/20/devops/landun_clb/</id>
    <published>2024-08-19T16:00:00.000Z</published>
    <updated>2025-06-30T06:37:51.292Z</updated>
    
    <content type="html"><![CDATA[<p>在使用蓝盾公共构建机（Docker）时，我们发现构建机偶尔无法就绪。排查后发现，问题出在拉起的 Pod 在安装蓝盾 Agent 时卡住。经进一步分析，这是由于该 Pod 与 Nginx Ingress Pod 被调度到了同一节点，而同节点访问异常。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在阿里云ACK集群中，出现同节点访问异常的网络现象：</p><table><thead><tr><th>场景</th><th>流量路径</th><th>结果</th></tr></thead><tbody><tr><td>同节点</td><td>Pod → CLB VIP → 同节点 NodePort → 被 CLB 丢弃（回环限制）</td><td>❌ 超时</td></tr><tr><td>跨节点</td><td>Pod → CLB VIP → 其他节点 NodePort → Ingress Pod</td><td>✅ 正常</td></tr></tbody></table><ul><li><strong>跨节点访问正常</strong>：业务 Pod 与 Nginx Ingress Controller 部署在不同节点时，通过 CLB 访问服务完全正常。</li><li><strong>同节点访问超时</strong>：当业务 Pod 与 Ingress Controller 调度到同一节点时，TCP 连接超时：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Pod内测试</span></span><br><span class="line">curl http://devops.bk.xxx.xxx/static/<span class="built_in">local</span>/files/docker_init.sh</span><br><span class="line"><span class="comment"># 返回错误</span></span><br><span class="line">curl: (28) Failed to connect to devops.bk.xxx.xxx port 80: Connection timed out</span><br></pre></td></tr></table></figure></li></ul><h3 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h3><ul><li>Kubernetes 1.20.11 + Terway网络插件（非ENITrunking模式）</li><li>Nginx Ingress 0.44.0（externalTrafficPolicy: Local）</li><li>CLB 类型：四层TCP监听（端口80）</li><li>服务转发模式：IPVS</li></ul><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><h4 id="基础检查"><a href="#基础检查" class="headerlink" title="基础检查"></a>基础检查</h4><p><strong>网络连通性测试：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DNS解析正常</span></span><br><span class="line">ping devops.bk.xxx.xxx  <span class="comment"># 返回CLB VIP 10.200.x.x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP连接失败（同节点）</span></span><br><span class="line">telnet 10.200.x.x 80    <span class="comment"># Connection timed out</span></span><br></pre></td></tr></table></figure><p><strong>安全组验证：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">已确认放行VPC内网段（10.200.0.0/16, 100.100.0.0/16），排除ACL拦截。</span><br></pre></td></tr></table></figure><h4 id="流量路径分析"><a href="#流量路径分析" class="headerlink" title="流量路径分析"></a>流量路径分析</h4><p><strong>CLB后端健康状态：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get endpoints -n kube-system nginx-ingress-controller</span><br><span class="line">ENDPOINTS: 10.212.x.x:80,10.212.x.x:443  <span class="comment"># 正常</span></span><br></pre></td></tr></table></figure><p><strong>Ingress Controller配置：</strong><br><code>externalTrafficPolicy: Local</code>导致 CLB 只会将流量转发到有 Ingress Pod 的节点。</p><p><strong>节点网络抓包：</strong><br>在Ingress节点执行抓包后，发现 CLB 的请求包能到达节点，但未转发到 Ingress Pod。</p><h4 id="根因定位"><a href="#根因定位" class="headerlink" title="根因定位"></a>根因定位</h4><p>阿里云 CLB 对四层TCP监听器默认禁止回环流量（即后端服务器通过 CLB VIP访问自身服务），相关<a href="https://help.aliyun.com/zh/slb/why-am-i-unable-to-access-an-slb-instance" target="_blank" rel="noopener">阿里云文档</a>。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>当前使用修改CoreDNS配置的临时方案，其他方案待评估后实施。</p><h4 id="修改CoreDNS配置（临时）"><a href="#修改CoreDNS配置（临时）" class="headerlink" title="修改CoreDNS配置（临时）"></a>修改CoreDNS配置（临时）</h4><p>将相关域名解析到 Ingress Service 的内网IP（如ClusterIP），绕过 CLB。</p><h4 id="更新集群组件"><a href="#更新集群组件" class="headerlink" title="更新集群组件"></a>更新集群组件</h4><ul><li>升级 Nginx Ingress ：使用新版本，已修复兼容性问题。</li><li>升级 Terway 插件：使用最新版本，优化节点内流量路由。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://help.aliyun.com/zh/slb/why-am-i-unable-to-access-an-slb-instance" target="_blank" rel="noopener">为什么无法访问负载均衡</a></li><li><a href="https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/work-with-terway?spm=a2c4g.11186623.0.i13" target="_blank" rel="noopener">使用Terway网络插件</a></li><li><a href="https://www.tencentcloud.com/zh/document/product/457/42976" target="_blank" rel="noopener">CLB 回环问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用蓝盾公共构建机（Docker）时，我们发现构建机偶尔无法就绪。排查后发现，问题出在拉起的 Pod 在安装蓝盾 Agent 时卡住。经进一步分析，这是由于该 Pod 与 Nginx Ingress Pod 被调度到了同一节点，而同节点访问异常。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="clb" scheme="https://blazehu.github.io/tags/clb/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾存储服务梳理和数据迁移(v7.1)</title>
    <link href="https://blazehu.github.io/2024/06/04/devops/landun_storage/"/>
    <id>https://blazehu.github.io/2024/06/04/devops/landun_storage/</id>
    <published>2024-06-03T16:00:00.000Z</published>
    <updated>2025-03-24T13:25:43.042Z</updated>
    
    <content type="html"><![CDATA[<p>蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的存储服务梳理及数据迁移方案。</p><a id="more"></a><h3 id="1-存储服务梳理"><a href="#1-存储服务梳理" class="headerlink" title="1. 存储服务梳理"></a>1. 存储服务梳理</h3><table><thead><tr><th>存储服务</th><th>CPU/内存/磁盘</th><th>部署方式</th><th>实际资源配置</th><th>所需版本</th><th>连接串配置</th></tr></thead><tbody><tr><td>mysql</td><td>1C/2G/50Gi</td><td>云服务</td><td>2core4G 100G</td><td>5.7.26 (utf8字符集)</td><td>values文件中配置</td></tr><tr><td>redis</td><td>1C/1G/20Gi</td><td>云服务</td><td>2分片4G</td><td>6.2.5-debian-10-r63</td><td></td></tr><tr><td>redis-cluster</td><td>-/-/20Gi</td><td>云服务</td><td>-</td><td>6.2.6-debian-10-r178</td><td></td></tr><tr><td>mongodb</td><td>-/-/20Gi</td><td>云服务</td><td>4C8G</td><td>4.4.x</td><td></td></tr><tr><td>elastic</td><td>2C/4G</td><td>云服务</td><td>2c4g 20GiB</td><td>7.16.2-debian-10-r0</td><td></td></tr><tr><td>rabbitmq</td><td>-/-/20Gi</td><td>自建</td><td></td><td>3.8.21-debian-10-r0</td><td></td></tr><tr><td>zookeeper</td><td>-/-/20Gi</td><td>自建</td><td></td><td>bitnami/zookeeper:3.8.0-debian-10-r20</td><td></td></tr><tr><td>etcd</td><td>-/-/20Gi</td><td>自建</td><td></td><td>bitnami/etcd:3.5.4-debian-11-r31</td><td></td></tr><tr><td>influxdb</td><td>-/-/20Gi</td><td>自建</td><td></td><td>influxdb:1.8.6-alpine</td><td></td></tr></tbody></table><p>基础存储服务包含：mysql、redis、mongodb、rabbitmq、elastic、zookeeper、etcd。<br>蓝盾存储服务包含：mysql、redis、mongodb、rabbitmq、elastic、influxdb。<br>其中 mysql、redis、mongodb、rabbitmq、elastic 可以复用。</p><h3 id="2-基础存储服务"><a href="#2-基础存储服务" class="headerlink" title="2. 基础存储服务"></a>2. 基础存储服务</h3><p>包含：mysql、redis、mongodb、rabbitmq、elastic、zookeeper、etcd。</p><h4 id="2-1-mysql"><a href="#2-1-mysql" class="headerlink" title="2.1 mysql"></a>2.1 mysql</h4><p>镜像： hub.bktencent.com/bitnami/mysql:5.7.26</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="comment"># 处于同一集群可以使用k8s service 名</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">"bk-mysql-mysql"</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">rootPassword:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="comment"># 默认平台和saas都复用该mysql示例时，请分配大一点的磁盘空间给数据盘。</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">50Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-2-rabbitmq"><a href="#2-2-rabbitmq" class="headerlink" title="2.2 rabbitmq"></a>2.2 rabbitmq</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">"bk-rabbitmq"</span></span><br><span class="line">  <span class="comment"># AMQP协议端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">erlangCookie:</span> <span class="string">bluekingcookie</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-3-redis"><a href="#2-3-redis" class="headerlink" title="2.3 redis"></a>2.3 redis</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">64Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-redis-master</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">"blueking"</span></span><br></pre></td></tr></table></figure><h4 id="2-4-redis-cluster"><a href="#2-4-redis-cluster" class="headerlink" title="2.4 redis-cluster"></a>2.4 redis-cluster</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redisCluster:</span></span><br><span class="line">  <span class="attr">persistence:</span> </span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-redis-cluster</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">"blueking"</span></span><br></pre></td></tr></table></figure><h4 id="2-5-mongodb"><a href="#2-5-mongodb" class="headerlink" title="2.5 mongodb"></a>2.5 mongodb</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mongodb:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-mongodb-headless</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">host_port:</span> <span class="string">bk-mongodb-headless:27017</span></span><br><span class="line">  <span class="attr">rootUsername:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">rootPassword:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">rsName:</span> <span class="string">rs0</span></span><br><span class="line">  <span class="comment"># 以下变量对部署bitnamiMongodb生效，外部mongodb服务不需要</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicaSetKey:</span> <span class="string">xEfhjshh3APP0arf</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-6-elastic"><a href="#2-6-elastic" class="headerlink" title="2.6 elastic"></a>2.6 elastic</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">master:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">heapSize:</span> <span class="string">512m</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">10Gi</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">4096Mi</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">40Gi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">coordinating:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="comment"># 集群内访问的k8s service</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-elastic-elasticsearch-master.blueking.svc.cluster.local</span></span><br><span class="line">  <span class="comment"># http协议的REST端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">elastic</span> </span><br><span class="line">  <span class="comment"># 以下变量对部署bitnamiElasticsearch生效，外部elasticsearch服务不需要</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">40Gi</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-7-zookeeper"><a href="#2-7-zookeeper" class="headerlink" title="2.7 zookeeper"></a>2.7 zookeeper</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">256Mi</span></span><br></pre></td></tr></table></figure><h4 id="2-8-etcd"><a href="#2-8-etcd" class="headerlink" title="2.8 etcd"></a>2.8 etcd</h4><h3 id="3-蓝盾存储服务"><a href="#3-蓝盾存储服务" class="headerlink" title="3. 蓝盾存储服务"></a>3. 蓝盾存储服务</h3><p>包含：mysql、redis、mongodb、rabbitmq、elastic、influxdb。</p><h4 id="3-1-自建存储服务"><a href="#3-1-自建存储服务" class="headerlink" title="3.1 自建存储服务"></a>3.1 自建存储服务</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">primary:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">replica:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">influxdb:</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">mongodb:</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="3-2-外部数据库"><a href="#3-2-外部数据库" class="headerlink" title="3.2 外部数据库"></a>3.2 外部数据库</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">externalMysql:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalRedis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalElasticsearch:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalRabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">vhost:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalInfluxdb:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalMongodb:</span></span><br><span class="line">  <span class="attr">turbo:</span></span><br><span class="line">    <span class="attr">turboUrl:</span> <span class="string">mongodb://bkci:bkci@localhost:27017/db_turbo</span></span><br><span class="line">    <span class="attr">quartzUrl:</span> <span class="string">mongodb://bkci:bkci@localhost:27017/db_quart</span></span><br></pre></td></tr></table></figure><h3 id="4-数据迁移-Mysql"><a href="#4-数据迁移-Mysql" class="headerlink" title="4. 数据迁移(Mysql)"></a>4. 数据迁移(Mysql)</h3><h4 id="4-1-数据备份"><a href="#4-1-数据备份" class="headerlink" title="4.1 数据备份"></a>4.1 数据备份</h4><p><strong>1.备份脚本准备</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">MYSQL_USER=root</span><br><span class="line">MYSQL_HOST=127.0.0.1</span><br><span class="line">MYSQL_PASSWD=</span><br><span class="line">ignoredblist=<span class="string">'information_schema|mysql|test|db_infobase|performance_schema|sys'</span></span><br><span class="line">dblist=<span class="string">"<span class="variable">$(mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWD -Nse"show databases;"|grep -Ewv "$ignoredblist" | xargs echo)</span>"</span></span><br><span class="line"></span><br><span class="line">mysqldump -h<span class="variable">$MYSQL_HOST</span> -u<span class="variable">$MYSQL_USER</span> -p<span class="variable">$MYSQL_PASSWD</span> --skip-opt --create-options --default-character-set=utf8mb4 -R  -E -q -e --single-transaction --no-autocommit --max-allowed-packet=1G  --hex-blob -B <span class="variable">$dblist</span> &gt; /tmp/bk_mysql_alldata.sql</span><br></pre></td></tr></table></figure><p>将其中的MYSQL_USER、MYSQL_HOST、MYSQL_PASSWORD更换成需要备份的数据库及用户名密码。存为 <code>dbbackup_mysql.sh</code> 文件。</p><p><strong>2.将脚本拷贝到容器内执行</strong><br>以自建的蓝盾mysql为例</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将上面的数据备份脚本拷贝至自建的蓝盾mysql的pod中</span></span><br><span class="line">kubectl cp -n blueking /data/dbbackup_mysql.sh bk-ci-mysql-0:/tmp/dbbackup_mysql.sh</span><br><span class="line"><span class="comment"># 开始执行数据备份</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it -n blueking bk-mysql-mysql-master-0 -- bash /tmp/dbbackup_mysql.sh</span><br><span class="line"><span class="comment"># 将备份好的sql从pod拷贝到本机暂存</span></span><br><span class="line">kubectl cp -n blueking bk-ci-mysql-0:/tmp/bk_mysql_alldata.sql /data/bkmysql_bak/bk_mysql_alldata.sql</span><br></pre></td></tr></table></figure><p>最后一步数据拷贝可以不做，直接在这个pod里进行后续的数据导入操作。</p><h4 id="4-2-数据导入"><a href="#4-2-数据导入" class="headerlink" title="4.2 数据导入"></a>4.2 数据导入</h4><p>上一步的数据备份是用<code>root</code>用户进行操作，备份中涉及存储过程函数和赋权。</p><blockquote><p>注意：如果导入到阿里云mysql服务中需要处理导出的sql文件，因为阿里云提供的mysql服务，<code>root</code>作为保留字段，不能由用户自由创建，但允许创建拥有<code>root</code>权限的账户，所以需要修改备份数据中相关的内容，更换成实际使用的数据库用户，以替换成 <code>superuser</code> 为例执行如下命令：<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计"`root`@"字符串一共有多少个</span></span><br><span class="line">grep -o <span class="string">'`root`@'</span> bk_mysql_alldata.sql | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将"`root`@" 修改为 "`superuser`@"</span></span><br><span class="line">sed -i <span class="string">'s/`root`@/`superuser`@/g'</span> bk_mysql_alldata.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二次确认</span></span><br><span class="line">grep -o <span class="string">'`superuser`@'</span> bk_mysql_alldata.sql | wc -l</span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>导入</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">mysql -h <span class="variable">$NEW_MYSQL_HOST</span> -usuperuser -p<span class="variable">$YOUR_PASSWORD</span> --force &lt; bk_mysql_alldata.sql</span><br></pre></td></tr></table></figure><p><strong>检查</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -h$MYSQL_HOST -usuperuser -p$MYSQL_PASSWD -Nse"<span class="keyword">show</span> <span class="keyword">databases</span> <span class="keyword">like</span> <span class="string">'devops_ci%'</span>;"</span><br></pre></td></tr></table></figure><h4 id="4-3-Helmfile更新"><a href="#4-3-Helmfile更新" class="headerlink" title="4.3 Helmfile更新"></a>4.3 Helmfile更新</h4><p>变更 bkci\environments\default\bkci\bkci-custom-values.yaml.gotmpl 文件后执行 helmfile 相关命令更新服务。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的存储服务梳理及数据迁移方案。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾快速部署文档(v7.1)</title>
    <link href="https://blazehu.github.io/2024/05/24/devops/landun_install/"/>
    <id>https://blazehu.github.io/2024/05/24/devops/landun_install/</id>
    <published>2024-05-23T16:00:00.000Z</published>
    <updated>2025-03-24T13:25:45.446Z</updated>
    
    <content type="html"><![CDATA[<p>蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的快速部署指南。通过详细的步骤说明和脚本示例，帮助用户在 Kubernetes 集群上快速搭建蓝鲸基础服务和蓝盾平台，并实现 HTTPS 安全访问。</p><a id="more"></a><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>需要先准备一台中控机，在中控机安装 kubectl、helm、helmfile 等工具，以及蓝鲸安装脚本。然后部署基础套餐，最后再部署持续集成套餐。简单来说就是三个步骤：1.准备环境 -&gt; 2.部署基础服务 -&gt; 3.部署蓝盾。</p><h3 id="2-准备中控机"><a href="#2-准备中控机" class="headerlink" title="2. 准备中控机"></a>2. 准备中控机</h3><p>按照<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/prepare-bkctrl.md" target="_blank" rel="noopener">官方文档</a>安装和配置即可。</p><h3 id="3-部署基础服务"><a href="#3-部署基础服务" class="headerlink" title="3. 部署基础服务"></a>3. 部署基础服务</h3><p>需要按照<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/custom-values.md" target="_blank" rel="noopener">官方文档</a>一步步部署。</p><h4 id="3-1-下载安装文件"><a href="#3-1-下载安装文件" class="headerlink" title="3.1 下载安装文件"></a>3.1 下载安装文件</h4><p>请在 <code>中控机</code> 使用下载脚本下载蓝鲸 helmfile 包及公共证书。（ helmfile相关value文件在git上维护）</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">bkdl-7.1-stable.sh -ur latest base demo</span><br></pre></td></tr></table></figure><p>这些文件默认放在了 <code>~/bkce7.1-install/</code> 目录。</p><h4 id="3-2-配置-Helm-Chart-仓库"><a href="#3-2-配置-Helm-Chart-仓库" class="headerlink" title="3.2 配置 Helm Chart 仓库"></a>3.2 配置 Helm Chart 仓库</h4><p>添加 <code>charts</code> 仓库</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helm repo add blueking https://hub.bktencent.com/chartrepo/blueking</span><br><span class="line">helm repo update</span><br><span class="line">helm repo list</span><br></pre></td></tr></table></figure><h4 id="3-3-配置全局-custom-values"><a href="#3-3-配置全局-custom-values" class="headerlink" title="3.3 配置全局 custom-values"></a>3.3 配置全局 custom-values</h4><p>相关文件已经修改，在git上维护，配置访问域名。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">BK_DOMAIN=bk.blazehu.com</span>  <span class="comment"># 请修改为你分配给蓝鲸平台的主域名 cd ~/bkce7.1-install/blueking/  # 进入工作目录# 可使用如下命令添加域名。如果文件已存在，请手动编辑。custom=environments/default/custom.yaml</span></span><br><span class="line"><span class="string">cat</span> <span class="string">&gt;&gt;</span> <span class="string">"$custom"</span> <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="attr">imageRegistry:</span> <span class="string">$&#123;REGISTRY:-hub.bktencent.com&#125;</span></span><br><span class="line"><span class="attr">domain:</span></span><br><span class="line">  <span class="attr">bkDomain:</span> <span class="string">$BK_DOMAIN</span></span><br><span class="line">  <span class="attr">bkMainSiteDomain:</span> <span class="string">$BK_DOMAIN</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h4 id="3-4-生成-values-文件"><a href="#3-4-生成-values-文件" class="headerlink" title="3.4 生成 values 文件"></a>3.4 生成 values 文件</h4><p>还有一些 values 文件随着部署环境的不同而变化，所以我们提供了脚本快速生成。</p><p><strong>生成蓝鲸 app code 对应的 secret</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">./scripts/generate_app_secret.sh ./environments/default/app_secret.yaml</span><br></pre></td></tr></table></figure><p><strong>生成 apigw 所需的 keypair</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">./scripts/generate_rsa_keypair.sh ./environments/default/bkapigateway_builtin_keypair.yaml</span><br></pre></td></tr></table></figure><p><strong>生成 paas 所需的 clusterAdmin</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">./scripts/create_k8s_cluster_admin_for_paas3.sh</span><br></pre></td></tr></table></figure><h4 id="3-5-安装入口网关"><a href="#3-5-安装入口网关" class="headerlink" title="3.5 安装入口网关"></a>3.5 安装入口网关</h4><p><strong>3.5.1 安装 ingress controller</strong><br>先检查你的环境是否已经部署了 ingress controller:</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A -l app.kubernetes.io/name=ingress-nginx</span><br></pre></td></tr></table></figure><p>如果没有，则使用如下命令创建：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f 00-ingress-nginx.yaml.gotmpl sync</span><br><span class="line">kubectl get pods -A -l app.kubernetes.io/name=ingress-nginx  查看创建的pod</span><br></pre></td></tr></table></figure><p>pops集群相关标签如下：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A -l app=ingress-nginx  <span class="comment"># 查看创建的pod</span></span><br><span class="line">IP1=$(kubectl get svc -A -l app=nginx-ingress-lb -o jsonpath=<span class="string">'&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line"><span class="comment"># IP1=$(kubectl get svc -A -l app.kubernetes.io/name=ingress-nginx -o jsonpath='&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;')</span></span><br></pre></td></tr></table></figure><p><strong>3.5.2 配置 coredns</strong><br>在部署过程中，会在容器内访问这些域名，所以需要提前配置 coredns，将蓝鲸域名解析到 service IP。</p><blockquote><p>注意：当 service 被删除，重建后 clusterIP 会变动，此时需刷新 hosts 文件。</p></blockquote><p>因此需要注入 hosts 配置项到 kube-system namespace 下的 coredns 系列 pod，步骤如下：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  <span class="comment"># 进入工作目录</span></span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> environments/default/custom.yaml)  <span class="comment"># 从自定义配置中提取, 也可自行赋值</span></span><br><span class="line"><span class="comment">#IP1=$(kubectl get svc -A -l app.kubernetes.io/instance=ingress-nginx -o jsonpath='&#123;.items[0].spec.clusterIP&#125;')</span></span><br><span class="line">IP1=$(kubectl get svc -A -l app=nginx-ingress-lb -o jsonpath=<span class="string">'&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line">./scripts/control_coredns.sh update <span class="string">"<span class="variable">$IP1</span>"</span> <span class="variable">$BK_DOMAIN</span> bkrepo.<span class="variable">$BK_DOMAIN</span> docker.<span class="variable">$BK_DOMAIN</span> bkapi.<span class="variable">$BK_DOMAIN</span> bkpaas.<span class="variable">$BK_DOMAIN</span> bkiam-api.<span class="variable">$BK_DOMAIN</span> bkiam.<span class="variable">$BK_DOMAIN</span> apps.<span class="variable">$BK_DOMAIN</span> bknodeman.<span class="variable">$BK_DOMAIN</span> job.<span class="variable">$BK_DOMAIN</span> jobapi.<span class="variable">$BK_DOMAIN</span></span><br><span class="line">./scripts/control_coredns.sh update <span class="string">"<span class="variable">$IP1</span>"</span> devops.<span class="variable">$BK_DOMAIN</span></span><br><span class="line">./scripts/control_coredns.sh list  <span class="comment"># 检查添加的记录。</span></span><br></pre></td></tr></table></figure><p>确认注入结果，执行如下命令：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  进入工作目录</span><br><span class="line">./scripts/control_coredns.sh list</span><br></pre></td></tr></table></figure><p>参考输出如下：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">10.241.0.9 bk.blazehu.com</span><br><span class="line">10.241.0.9 apps.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkrepo.bk.blazehu.com</span><br><span class="line">10.241.0.9 docker.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkapi.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkpaas.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkiam-api.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkiam.bk.blazehu.com</span><br><span class="line">10.241.0.9 bcs.bk.blazehu.com</span><br><span class="line">10.241.0.9 bknodeman.bk.blazehu.com</span><br><span class="line">10.241.0.9 job.bk.blazehu.com</span><br><span class="line">10.241.0.9 jobapi.bk.blazehu.com</span><br></pre></td></tr></table></figure><h4 id="3-6-部署或对接存储服务"><a href="#3-6-部署或对接存储服务" class="headerlink" title="3.6 部署或对接存储服务"></a>3.6 部署或对接存储服务</h4><p><strong>3.6.1 部署蓝鲸预置的存储服务</strong><br>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/storage-services.md" target="_blank" rel="noopener">官方文档</a>安装，相关helm配置已经放在git上维护，可以直接简单执行以下命令：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-storage.yaml.gotmpl sync</span><br></pre></td></tr></table></figure><blockquote><p>注意：我当前使用阿里云盘，使用该存储类创建的存储盘最小容量为20Gi，目前git上已经都修改为20Gi.</p></blockquote><p><strong>3.6.2 对接已有的存储服务</strong><br>禁用蓝鲸内置服务，配置使用已有服务。请参考helmfile定义及values文件自行研究。参考官方文档的<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/storage-services.md" target="_blank" rel="noopener">例子</a>。</p><h4 id="3-7-部署基础套餐"><a href="#3-7-部署基础套餐" class="headerlink" title="3.7 部署基础套餐"></a>3.7 部署基础套餐</h4><p>通过helmfile安装 base-blueking.yaml.gotmpl ，按照顺序依次安装。具体每层安装的内容可以查看文件内容。</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=first sync</span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=second sync</span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br><span class="line"><span class="comment">#helmfile -f base-blueking.yaml.gotmpl -l seq=fourth sync</span></span><br></pre></td></tr></table></figure><h4 id="3-8-访问蓝鲸桌面"><a href="#3-8-访问蓝鲸桌面" class="headerlink" title="3.8 访问蓝鲸桌面"></a>3.8 访问蓝鲸桌面</h4><p>在负载均衡器配置后端为 ingress-nginx pod 所在机器的内网 IP，端口为 80。详细信息参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/manual-install-bkce.md" target="_blank" rel="noopener">文档</a>。</p><h4 id="3-9-对接Ldap服务"><a href="#3-9-对接Ldap服务" class="headerlink" title="3.9 对接Ldap服务"></a>3.9 对接Ldap服务</h4><p>在用户中心里配置Ldap相关配置，然后更新 bk-user-api-web 服务的镜像。<br><img src="/2024/05/24/devops/landun_install/ldap0.png" alt="alt text"><br><img src="/2024/05/24/devops/landun_install/ldap1.png" alt="alt text"></p><h3 id="4-部署蓝盾"><a href="#4-部署蓝盾" class="headerlink" title="4. 部署蓝盾"></a>4. 部署蓝盾</h3><p>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/install-ci-suite.md" target="_blank" rel="noopener">官方文档</a>部署，配置 custom values 的内容提前修改完成，执行类似部署基础服务的以下命令：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  <span class="comment"># 进入工作目录</span></span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl sync  <span class="comment"># 部署</span></span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl apply <span class="comment"># 更新</span></span><br></pre></td></tr></table></figure><p>剩下的步骤参考官方文档执行即可，主要步骤有以下三个，其他的步骤可以不做。</p><h4 id="4-1-注册默认构建镜像"><a href="#4-1-注册默认构建镜像" class="headerlink" title="4.1 注册默认构建镜像"></a>4.1 注册默认构建镜像</h4><p>我们提供了 bkci/ci 镜像用于提供构建环境。为了加速镜像下载过程，可以修改镜像地址为 hub.bktencent.com/bkci/ci，或者为你自己托管的内网 registry。<br>先检查数据库有没有历史数据：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it -n blueking bk-ci-mysql-0 -- /bin/bash -c <span class="string">'MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql -u root -e "USE devops_ci_store; SELECT IMAGE_NAME,IMAGE_CODE,IMAGE_REPO_NAME FROM T_IMAGE WHERE IMAGE_CODE = \"bkci\" ;"'</span></span><br></pre></td></tr></table></figure><p>请根据结果进行操作：</p><ul><li>如果有显示镜像数据，可以修改镜像地址为蓝鲸国内仓库，也可改为你已经缓存在内网的镜像：<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">kubectl exec -it -n blueking bk-ci-mysql<span class="number">-0</span> -- /bin/bash -c 'MYSQL_PWD=<span class="string">"$MYSQL_ROOT_PASSWORD"</span> mysql -u root -e <span class="string">"USE devops_ci_store; UPDATE  T_IMAGE SET IMAGE_REPO_NAME=<span class="subst">\"</span>hub.bktencent.com/bkci/ci<span class="subst">\"</span> WHERE IMAGE_CODE = <span class="subst">\"</span>bkci<span class="subst">\"</span> ;"</span>'</span><br></pre></td></tr></table></figure></li><li>然后重新查询数据库，可以看到 <code>IMAGE_REPO_NAME</code> 列已经更新。</li><li>如果没有镜像，可以新增：<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -n blueking deploy/bk-ci-bk-ci-store -- \curl -vs http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/market/image/init -X POST \-H <span class="string">'X-DEVOPS-UID: admin'</span> -H <span class="string">'Content-type: application/json'</span> -d <span class="string">'&#123;"imageCode":"bkci","imageName":"bkci","imageRepo":"hub.bktencent.com/bkci/ci","projectCode":"demo","userId":"admin"&#125;'</span> | jq .</span><br></pre></td></tr></table></figure><blockquote><p>注意：当你单独卸载蓝盾重装后，可能出现查询镜像为空，但是新增镜像时报错 { status: 400, message: “权限中心创建项目失败” } 的情况。这是因为权限中心存在蓝盾 demo 项目的数据所致，我们后续会优化蓝盾单独卸载的文档。请先手动新建项目，并修改上述代码中 projectCode 字段的值。</p></blockquote></li></ul><h4 id="4-2-对接制品库"><a href="#4-2-对接制品库" class="headerlink" title="4.2 对接制品库"></a>4.2 对接制品库</h4><p>蓝盾依靠蓝鲸制品库来提供流水线仓库和自定义仓库，需要调整制品库的认证模式。当 bk-ci release 成功启动后，我们开始配置蓝鲸制品库，并注册到蓝盾中。</p><p><strong>4.2.1 修改 bk-repo custom values</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/</span><br><span class="line"><span class="keyword">case</span> $(yq e <span class="string">'.auth.config.realm'</span> environments/default/bkrepo-custom-values.yaml.gotmpl 2&gt;/dev/null) <span class="keyword">in</span></span><br><span class="line">  null|<span class="string">""</span>)</span><br><span class="line">    tee -a environments/default/bkrepo-custom-values.yaml.gotmpl &lt;&lt;&lt; $<span class="string">'auth:\n  config:\n    realm: devops'</span></span><br><span class="line">  ;;</span><br><span class="line">  devops)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"environments/default/bkrepo-custom-values.yaml.gotmpl 中配置了 .auth.config.realm=devops, 无需修改."</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"environments/default/bkrepo-custom-values.yaml.gotmpl 中配置了 .auth.config.realm 为其他值, 请手动修改值为 devops."</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>修改成功后，继续在工作目录执行如下命令使修改生效：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l name=bk-repo apply</span><br></pre></td></tr></table></figure><p><strong>4.2.2 检查配置是否生效</strong><br>检查 release 生效的 values 和 configmap 是否重新渲染。<br>请在 中控机 执行：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helm get values -n blueking bk-repo | yq e <span class="string">'.auth.config.realm'</span></span><br><span class="line">kubectl get cm -n blueking bk-repo-bkrepo-auth -o json | jq -r <span class="string">'.data."application.yml"'</span> | yq e <span class="string">'.auth.realm'</span> -</span><br></pre></td></tr></table></figure><p>预期 2 条命令均显示 devops。如果任意配置没有生效，请检查上述 helmfile 命令的输出是否正常。</p><p><strong>4.2.3 重启 bk-repo auth 微服务</strong><br>因为 deployment 没有变动，所以不会自动重启，此处需要单独重启：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl rollout restart deployment -n blueking bk-repo-bkrepo-auth</span><br></pre></td></tr></table></figure><p><strong>4.2.4 在蓝盾中注册制品库</strong><br>请在 <code>中控机</code> 执行：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/ </span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> environments/default/custom.yaml)  </span><br><span class="line">kubectl <span class="built_in">exec</span> -i -n blueking deploy/bk-ci-bk-ci-project -- curl -sS -X PUT -H <span class="string">'Content-Type: application/json'</span> -H <span class="string">'Accept: application/json'</span> -H <span class="string">'X-DEVOPS-UID: admin'</span> -d <span class="string">"&#123;\"showProjectList\":true,\"showNav\":true,\"status\":\"ok\",\"deleted\":false,\"iframeUrl\":\"//bkrepo.<span class="variable">$BK_DOMAIN</span>/ui/\"&#125;"</span> <span class="string">"http://bk-ci-bk-ci-project.blueking.svc.cluster.local/api/op/services/update/Repo"</span></span><br></pre></td></tr></table></figure><h4 id="4-3-下载和上传插件"><a href="#4-3-下载和上传插件" class="headerlink" title="4.3 下载和上传插件"></a>4.3 下载和上传插件</h4><p><strong>4.3.1 下载插件</strong><br>请在 <code>中控机</code> 执行：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">bkdl-7.1-stable.sh -ur latest ci-plugins</span><br></pre></td></tr></table></figure><p><strong>4.3.2 上传插件</strong><br>此操作只能新建插件，每个插件只能上传一次。</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  <span class="comment"># 进入工作目录</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> ../ci-plugins/*.zip; <span class="keyword">do</span></span><br><span class="line">    atom=<span class="string">"<span class="variable">$&#123;f##*/&#125;</span>"</span></span><br><span class="line">    atom=<span class="variable">$&#123;atom%.zip&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> &gt;&amp;2 <span class="string">"upload <span class="variable">$atom</span> from <span class="variable">$f</span>"</span></span><br><span class="line">    kubectl <span class="built_in">exec</span> -i -n blueking deploy/bk-ci-bk-ci-store -- \</span><br><span class="line">      curl -s \</span><br><span class="line">      http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/pipeline/atom/deploy/<span class="string">"?publisher=admin"</span> \</span><br><span class="line">      -H <span class="string">'X-DEVOPS-UID: admin'</span> -F atomCode=<span class="variable">$atom</span> -F file=@- &lt; <span class="string">"<span class="variable">$f</span>"</span> | jq .</span><br><span class="line">      <span class="comment"># 设置为默认插件，全部项目可见。</span></span><br><span class="line">    kubectl <span class="built_in">exec</span> -n blueking deploy/bk-ci-bk-ci-store -- \</span><br><span class="line">    curl -s http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/pipeline/atom/default/atomCodes/<span class="variable">$atom</span> \-H <span class="string">'X-DEVOPS-UID: admin'</span> -X POST | jq .</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong>：</p><ul><li><strong>插件重复上传</strong>：如果重复执行会报错：{“status”: 2100001, “message”: “系统内部繁忙，请稍后再试”}。后续更新插件，请访问蓝盾研发商店的工作台界面，在列表中找到对应插件进行“升级”操作。</li><li><strong>插件包体过大</strong>：上传或者更新插件报错：”413 Request Entity Too Large”。原因是nginx-ingress的默认配置中proxy-body-size的数值太小，具体解决方式详见：<a href="https://developer.aliyun.com/article/1001630" target="_blank" rel="noopener">Ingress 域名方式导致413 Request Entity Too Large-阿里云开发者社区</a>。</li></ul></blockquote><h3 id="5-TLS配置"><a href="#5-TLS配置" class="headerlink" title="5. TLS配置"></a>5. TLS配置</h3><p>如果开始就准备好了相关证书，那么可以将该步骤提前，在部署基础服务和蓝盾之前就先修改好相关的yaml，将需要创建的Secret和要更新的Ingress配置都提前修改好，然后直接部署即可。</p><h4 id="5-1-购买相关证书"><a href="#5-1-购买相关证书" class="headerlink" title="5.1 购买相关证书"></a>5.1 购买相关证书</h4><p>涉及的域名：bk.blazehu.com、*.bk.blazehu.com（如devops.bk.blazehu.com）。需购买泛域名证书。</p><h4 id="5-2-创建相关Secret（用于存储TLS证书和私钥）"><a href="#5-2-创建相关Secret（用于存储TLS证书和私钥）" class="headerlink" title="5.2 创建相关Secret（用于存储TLS证书和私钥）"></a>5.2 创建相关Secret（用于存储TLS证书和私钥）</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Secret</span></span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> environments/default/custom.yaml)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/<span class="variable">$BK_DOMAIN</span></span><br><span class="line">kubectl create secret tls <span class="variable">$BK_DOMAIN</span> -n blueking --cert=<span class="variable">$HOME</span>/<span class="variable">$BK_DOMAIN</span>/<span class="variable">$BK_DOMAIN</span>.pem --key=<span class="variable">$HOME</span>/<span class="variable">$BK_DOMAIN</span>/<span class="variable">$BK_DOMAIN</span>.key</span><br></pre></td></tr></table></figure><h4 id="5-3-更新-Ingress-TLS"><a href="#5-3-更新-Ingress-TLS" class="headerlink" title="5.3 更新 Ingress TLS"></a>5.3 更新 Ingress TLS</h4><p>在证书及证书secret准备好之后，需要变更蓝鲸系列ingress开启tls的支持，执行对应的脚本</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置变量</span></span><br><span class="line">NAMESPACE=<span class="string">"blueking"</span></span><br><span class="line">DOMAIN_FILE=<span class="string">"environments/default/custom.yaml"</span></span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> <span class="string">"<span class="variable">$DOMAIN_FILE</span>"</span>)  <span class="comment"># 从配置文件中读取域名</span></span><br><span class="line">TLS_HOST=<span class="string">"*.<span class="variable">$BK_DOMAIN</span>"</span>  <span class="comment"># 泛域名</span></span><br><span class="line">TLS_SECRET=<span class="string">"<span class="variable">$BK_DOMAIN</span>"</span>  <span class="comment"># Secret 名称与域名一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查域名和 Secret 是否正确</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">"<span class="variable">$BK_DOMAIN</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: BK_DOMAIN is not set in <span class="variable">$DOMAIN_FILE</span>."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命名空间中的所有 Ingress 资源</span></span><br><span class="line">ingresses=$(kubectl get ingress -n <span class="string">"<span class="variable">$NAMESPACE</span>"</span> -o jsonpath=<span class="string">'&#123;.items[*].metadata.name&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有 Ingress 资源并更新 TLS 配置</span></span><br><span class="line"><span class="keyword">for</span> ingress <span class="keyword">in</span> <span class="variable">$ingresses</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Updating Ingress: <span class="variable">$ingress</span> in namespace: <span class="variable">$NAMESPACE</span>"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 检查 Ingress 是否已存在 TLS 配置</span></span><br><span class="line">  <span class="keyword">if</span> kubectl get ingress <span class="string">"<span class="variable">$ingress</span>"</span> -n <span class="string">"<span class="variable">$NAMESPACE</span>"</span> -o jsonpath=<span class="string">'&#123;.spec.tls&#125;'</span> | grep -q <span class="string">"<span class="variable">$TLS_HOST</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"TLS configuration for <span class="variable">$TLS_HOST</span> already exists in Ingress <span class="variable">$ingress</span>. Skipping."</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 更新 Ingress 的 TLS 配置</span></span><br><span class="line">  kubectl patch ingress <span class="string">"<span class="variable">$ingress</span>"</span> -n <span class="string">"<span class="variable">$NAMESPACE</span>"</span> --<span class="built_in">type</span>=json -p=<span class="string">'[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "op": "add",</span></span><br><span class="line"><span class="string">      "path": "/spec/tls",</span></span><br><span class="line"><span class="string">      "value": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "hosts": ["'</span><span class="string">"<span class="variable">$TLS_HOST</span>"</span><span class="string">'"],</span></span><br><span class="line"><span class="string">          "secretName": "'</span><span class="string">"<span class="variable">$TLS_SECRET</span>"</span><span class="string">'"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]'</span> || &#123; <span class="built_in">echo</span> <span class="string">"Failed to update Ingress <span class="variable">$ingress</span>"</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Updated Ingress <span class="variable">$ingress</span> with TLS configuration for <span class="variable">$TLS_HOST</span>."</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"All Ingress resources in namespace <span class="variable">$NAMESPACE</span> have been updated with TLS configuration for <span class="variable">$TLS_HOST</span>."</span></span><br></pre></td></tr></table></figure><h4 id="5-4-配置蓝鲸启用HTTPS"><a href="#5-4-配置蓝鲸启用HTTPS" class="headerlink" title="5.4 配置蓝鲸启用HTTPS"></a>5.4 配置蓝鲸启用HTTPS</h4><p>在git仓库维护，主要有两个变更：</p><ul><li>environments/default/custom.yaml: .bkDomainScheme 值设置为 https</li><li>environments/default/bkci/bkci-custom-values.yaml.gotmpl: .config.bkHttpSchema 值设置为 https</li></ul><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">yq -i <span class="string">'.bkDomainScheme = "https"'</span> environments/default/custom.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将bkHttpSchema: https替换为bkHttpSchema: http</span></span><br><span class="line">sed -i <span class="string">'s|bkHttpSchema: http|bkHttpSchema: https|'</span> environments/default/bkci/bkci-custom-values.yaml.gotmpl</span><br></pre></td></tr></table></figure><p><strong>重启服务使https配置生效</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启第一批服务</span></span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=first sync</span><br><span class="line"></span><br><span class="line"><span class="comment"># bk-apigateway 部分 pod 不会重启，主动删除等重建</span></span><br><span class="line">kubectl delete pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-apigateway,app.kubernetes.io/component in (api-support-fe, dashboard-fe)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待 bk-apigateway 全部 pod 重启成功后进行下一步</span></span><br><span class="line">kubectl get pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-apigateway,app.kubernetes.io/component in (api-support-fe, dashboard-fe)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bkrepo 部分 pod 不会重启，主动删除等重建</span></span><br><span class="line">kubectl delete pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-repo,bk.repo.scope=backend'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待 bkrepo 全部 pod 重启成功后进行下一步</span></span><br><span class="line"><span class="comment"># 这里一定要等所有pod重启成功后，才开始下一步，否则会导致服务异常</span></span><br><span class="line"><span class="comment"># repo系列服务会因为阿里云EKS csi插件问题，导致服务卡住，需要手动删除卡在ContainerCreating的pod，让pod重启</span></span><br><span class="line">watch -n 1 kubectl get pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-repo,bk.repo.scope=backend'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启第二批服务</span></span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=second sync</span><br><span class="line"><span class="comment"># 持续观察等 bk-repo-repository pod 全部Ready</span></span><br><span class="line">watch -n 1 kubectl get pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-repo,app.kubernetes.io/component=repository'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启第三批服务</span></span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br><span class="line"> <span class="comment"># bk-paas-webfe-web pod 不会重启，主动删除等重建</span></span><br><span class="line">kubectl delete pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-paas,app.kubernetes.io/name=webfe'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启蓝盾服务</span></span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl sync</span><br><span class="line"><span class="comment"># 这里蓝盾系列服务可能不会重启，需要手动删除老pod</span></span><br><span class="line">kubectl get pods -n blueking --field-selector=status.phase=Running| grep <span class="string">'bk-ci-bk-ci'</span> |awk <span class="string">'&#123;print $1&#125;'</span> | xargs kubectl delete pod -n blueking</span><br></pre></td></tr></table></figure><h4 id="5-5-构建机Agent配置变更及重启"><a href="#5-5-构建机Agent配置变更及重启" class="headerlink" title="5.5 构建机Agent配置变更及重启"></a>5.5 构建机Agent配置变更及重启</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止agent服务</span></span><br><span class="line">./stop.sh</span><br><span class="line"></span><br><span class="line">BK_DOMAIN=<span class="string">"deveops.bk.blazehu.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改.agent.properties文件，开启https</span></span><br><span class="line">sed -i <span class="string">''</span> <span class="string">'s|http://$BK_DOMAIN|https://$BK_DOMAIN|g'</span> .agent.properties</span><br><span class="line"><span class="comment"># 修改telegraf.conf文件，开启https</span></span><br><span class="line">sed -i <span class="string">''</span> <span class="string">'s|http://$BK_DOMAIN|https://$BK_DOMAIN|g'</span> telegraf.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动agent</span></span><br><span class="line">./start.sh</span><br><span class="line"><span class="comment"># 这里需要注意，仔细查看.agent.properties里devops.agent.user， 这里是哪个用户就用哪个用户启动agent</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/prepare-bkctrl.md" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://bk.tencent.com/s-mart/community/search?searchText=ldap&curTypeTab=all&curBestTab=latest" target="_blank" rel="noopener">官方论坛</a></li><li><a href="https://bk.tencent.com/s-mart/community/question/9114?type=article" target="_blank" rel="noopener">对接Ldap登陆</a></li><li><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0-beta.16/src/backend/ci/core/auth/biz-auth-rbac/src/main/kotlin/com/tencent/devops/auth/service/RbacPermissionProjectService.kt" target="_blank" rel="noopener">蓝盾源码</a></li><li><a href="https://developer.aliyun.com/article/1001630" target="_blank" rel="noopener">Ingress 域名方式导致413 Request Entity Too Large-阿里云开发者社区</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的快速部署指南。通过详细的步骤说明和脚本示例，帮助用户在 Kubernetes 集群上快速搭建蓝鲸基础服务和蓝盾平台，并实现 HTTPS 安全访问。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾接入LDAP登录(v7.1)</title>
    <link href="https://blazehu.github.io/2024/05/22/devops/landun_login_ldap/"/>
    <id>https://blazehu.github.io/2024/05/22/devops/landun_login_ldap/</id>
    <published>2024-05-21T16:00:00.000Z</published>
    <updated>2025-06-30T03:50:01.716Z</updated>
    
    <content type="html"><![CDATA[<p>通过蓝鲸用户中心配置 LDAP 后，存在登录失败以及用户名需要加域（与当前用户的使用习惯不符）等问题。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>按照<a href="https://blazehu.com/2024/05/24/devops/landun_install/#3-9-%E5%AF%B9%E6%8E%A5Ldap%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">官方文档</a>对接 LDAP 服务后用户正常同步，但是登录时报用户密码错误。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>后台查看 bk-user-api-web 日志，报错如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"levelname"</span>: <span class="string">"ERROR"</span>,</span><br><span class="line"><span class="attr">"asctime"</span>: <span class="string">"2024-05-22 15:15:30,947"</span>,</span><br><span class="line"><span class="attr">"pathname"</span>: <span class="string">"/app/bkuser_core/api/login/views.py"</span>,</span><br><span class="line"><span class="attr">"lineno"</span>: <span class="number">205</span>,</span><br><span class="line"><span class="attr">"funcName"</span>: <span class="string">"login"</span>,</span><br><span class="line"><span class="attr">"process"</span>: <span class="number">530</span>,</span><br><span class="line"><span class="attr">"thread"</span>: <span class="number">140333237386568</span>,</span><br><span class="line"><span class="attr">"request_id"</span>: <span class="string">"ebf27affe3f74e77b961a11df38583e9"</span>,</span><br><span class="line"><span class="attr">"exc_info"</span>: <span class="string">"Traceback (most recent call last):</span></span><br><span class="line"><span class="string">File \"/app/bkuser_core/api/login/views.py\", line 197, in login</span></span><br><span class="line"><span class="string">    login_class().check(profile, password)</span></span><br><span class="line"><span class="string">File \"/app/bkuser_core/categories/plugins/ldap/login.py\", line 62, in check</span></span><br><span class="line"><span class="string">    target_dn = self.fetch_dn(user)</span></span><br><span class="line"><span class="string">File \"/app/bkuser_core/categories/plugins/ldap/login.py\", line 30, in fetch_dn</span></span><br><span class="line"><span class="string">    return force_str(user_info[\"raw_attributes\"][\"entryDN\"][0])</span></span><br><span class="line"><span class="string">File \"/usr/local/lib/python3.6/site-packages/ldap3/utils/ciDict.py\", line 68, in __getitem__</span></span><br><span class="line"><span class="string">    return self._store[self._case_insensitive_keymap[self._ci_key(key)]]</span></span><br><span class="line"><span class="string">KeyError: 'entrydn'"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息很明显，在 <code>user_info.raw_attributes</code> 里找不到 <code>entryDN</code> 这个 key。即获取用户用于登陆的 login dn 失败，需要修改相关逻辑。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><p>本地通过 vscode 插件连上 ldap 后，发现用户用于登陆的 login dn 的 key 应该是 <code>dn</code>，修改用于用户登陆的 login dn 逻辑。详细步骤如下：</p><ol><li><p>通过部署的配置文件 <code>environments/default/version.yaml</code> 找到部署的 bk-user 的版本为：<code>bk-user: &quot;1.4.14-beta.10&quot;</code></p></li><li><p>下载该包到本地 <code>helm pull blueking/bk-user --version 1.4.14-beta.10</code>，解压找到镜像版本：<code>tag: &quot;v2.5.4-beta.10&quot;</code></p></li><li><p>找到 bk-user 该 tag 源码地址：<a href="https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10</a></p></li><li><p>根据日志找到对应文件 <code>src/api/bkuser_core/categories/plugins/ldap/login.py</code></p></li><li><p>修改 fetch_dn 函数的实现，将 <code>entryDN</code> 修改为 <code>dn</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_dn</span><span class="params">(user_info: dict)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> force_str(user_info[<span class="string">"raw_attributes"</span>][<span class="string">"dn"</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li></ol><h4 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h4><p><strong>制作镜像</strong><br>我们只需要更新 bk-user-api-web 服务所以只需要制作该服务镜像，执行命令 <code>make build-api</code>。</p><p><strong>变更模版</strong><br>在 environments/default 目录下新建 bkuser-custom-values.yaml.gotmpl 文件使用新的镜像，若以存在则跳过。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bk-user-api:v1.0.1</span></span><br><span class="line"><span class="attr">api:</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">registry:</span> <span class="string">your</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">bk-user-api</span></span><br><span class="line">    <span class="attr">pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="string">"v1.0.1"</span></span><br></pre></td></tr></table></figure><p><strong>更新服务</strong><br>执行下面的命令进行更新：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br></pre></td></tr></table></figure><p>检查以下容器镜像的变更是否符合预期：</p><ul><li>bk-user-api-beat</li><li>bk-user-api-web</li><li>bk-user-api-worker</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>登陆失败的问题可以通过修改源码进行修复。</li><li>登陆无需加域的临时方案：将用户和组织结构信息同步至默认域，然后查找默认域。需要修改同步逻辑。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://bk.tencent.com/s-mart/community/question/9114?type=article" target="_blank" rel="noopener">https://bk.tencent.com/s-mart/community/question/9114?type=article</a></li><li><a href="https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过蓝鲸用户中心配置 LDAP 后，存在登录失败以及用户名需要加域（与当前用户的使用习惯不符）等问题。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Golang archive/zip 问题排查小记</title>
    <link href="https://blazehu.github.io/2024/02/18/backend/golang/golang_archive_zip/"/>
    <id>https://blazehu.github.io/2024/02/18/backend/golang/golang_archive_zip/</id>
    <published>2024-02-17T16:00:00.000Z</published>
    <updated>2025-03-24T13:24:05.697Z</updated>
    
    <content type="html"><![CDATA[<p>2021年给开发商做了一个<a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>，近期开发商反馈当上传的ipa文件比较大超过4G的时候上传失败。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>的技术架构如下图，，蓝盾插件请求版本体验后端，后端临时缓存文件并解析ipa和apk文件，获取包的相关信息（包名，版本号，图标等），然后上传至cos存储。服务端使用的golang的版本是<a href="https://go.dev/doc/go1.16" target="_blank" rel="noopener">go1.16</a>。<br><img src="/2024/02/18/backend/golang/golang_archive_zip/ipapk.png" alt></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="插件侧报错"><a href="#插件侧报错" class="headerlink" title="插件侧报错"></a>插件侧报错</h4><p>用户反馈插件执行报错 <strong>“zip: not a valid zip file”</strong>（插件将ipa或者apk包上传至版本体验后端）<br><img src="/2024/02/18/backend/golang/golang_archive_zip/plugin_error.png" alt></p><h4 id="服务端解析包报错"><a href="#服务端解析包报错" class="headerlink" title="服务端解析包报错"></a>服务端解析包报错</h4><p>通过排查后端服务日志，问题比较清晰，就是后端解析包的时候报错。解析<code>ipa</code>包的相关代码如下所示，整体逻辑比较简单，通过 <code>archive/zip</code> 读取<code>ipa</code>文件，通过正则找到 <code>plist</code> 和 <code>AppIcon</code> 文件，然后分别通过 <a href="howett.net/plist">plist</a> 和 <a href="github.com/andrianbdn/iospng">iospng</a> 解析<br>得到相关信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIpa</span><span class="params">(readerAt io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="params">(*App, error)</span></span> &#123;</span><br><span class="line">log.Info(<span class="string">"[upload] file size : "</span>, size)</span><br><span class="line"><span class="keyword">var</span> reInfoPlist = regexp.MustCompile(<span class="string">`Payload/[^/]+/Info\.plist`</span>)</span><br><span class="line"></span><br><span class="line">reader, err := zip.NewReader(readerAt, size)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"[upload] zip new reader failed, err: "</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plistFile, iosIconFile *zip.File</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> reader.File &#123;</span><br><span class="line">log.Info(<span class="string">"[upload] reader file: "</span>, f.Name)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reInfoPlist.MatchString(f.Name):</span><br><span class="line">plistFile = f</span><br><span class="line"><span class="keyword">case</span> strings.Contains(f.Name, <span class="string">"AppIcon60x60"</span>):</span><br><span class="line">iosIconFile = f</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"[upload] reader plist file: "</span>, plistFile.Name)</span><br><span class="line">log.Info(<span class="string">"[upload] reader icon file: "</span>, iosIconFile.Name)</span><br><span class="line">app, err := parseIpaFile(plistFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> ignore error</span></span><br><span class="line">log.Error(<span class="string">"[upload] parse ipa failed, err: "</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"[upload] parse ipa success, err: "</span>, app)</span><br><span class="line">icon, err := parseIpaIcon(iosIconFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> ignore error</span></span><br><span class="line">log.Error(<span class="string">"[upload] parse ipa icon failed, err: "</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">app.Size = size</span><br><span class="line">app.Icon = icon</span><br><span class="line"><span class="keyword">return</span> app, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的报错：<strong>“zip: not a valid zip file”</strong> 定位是 <code>archive/zip</code> 库抛出的。</p><h4 id="源码阅读-archive-zip"><a href="#源码阅读-archive-zip" class="headerlink" title="源码阅读(archive/zip)"></a>源码阅读(<code>archive/zip</code>)</h4><p>通过查阅源码，发现该错误就是常量 <code>ErrFormat</code>，<code>NewReader</code> 方法调用了 <code>init</code> 方法，而 <code>init</code> 方法在循环读取文件头部 <code>readDirectoryHeader</code> 时会判断错误类型，如果是 <code>ErrFormat</code> 会将错误抛出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrFormat       = errors.New(<span class="string">"zip: not a valid zip file"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="params">(*Reader, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"zip: size cannot be negative"</span>)</span><br><span class="line">&#125;</span><br><span class="line">zr := <span class="built_in">new</span>(Reader)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> err = zr.init(r, size); err != <span class="literal">nil</span> &amp;&amp; err != ErrInsecurePath &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">init</span><span class="params">(rdr io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">end, baseOffset, err := readDirectoryEnd(rdr, size)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">r.r = rdr</span><br><span class="line">r.baseOffset = baseOffset</span><br><span class="line"><span class="comment">// Since the number of directory records is not validated, it is not</span></span><br><span class="line"><span class="comment">// safe to preallocate r.File without first checking that the specified</span></span><br><span class="line"><span class="comment">// number of files is reasonable, since a malformed archive may</span></span><br><span class="line"><span class="comment">// indicate it contains up to 1 &lt;&lt; 128 - 1 files. Since each file has a</span></span><br><span class="line"><span class="comment">// header which will be _at least_ 30 bytes we can safely preallocate</span></span><br><span class="line"><span class="comment">// if (data size / 30) &gt;= end.directoryRecords.</span></span><br><span class="line"><span class="keyword">if</span> end.directorySize &lt; <span class="keyword">uint64</span>(size) &amp;&amp; (<span class="keyword">uint64</span>(size)-end.directorySize)/<span class="number">30</span> &gt;= end.directoryRecords &#123;</span><br><span class="line">r.File = <span class="built_in">make</span>([]*File, <span class="number">0</span>, end.directoryRecords)</span><br><span class="line">&#125;</span><br><span class="line">r.Comment = end.comment</span><br><span class="line">rs := io.NewSectionReader(rdr, <span class="number">0</span>, size)</span><br><span class="line"><span class="keyword">if</span> _, err = rs.Seek(r.baseOffset+<span class="keyword">int64</span>(end.directoryOffset), io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">buf := bufio.NewReader(rs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The count of files inside a zip is truncated to fit in a uint16.</span></span><br><span class="line"><span class="comment">// Gloss over this by reading headers until we encounter</span></span><br><span class="line"><span class="comment">// a bad one, and then only report an ErrFormat or UnexpectedEOF if</span></span><br><span class="line"><span class="comment">// the file count modulo 65536 is incorrect.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">f := &amp;File&#123;zip: r, zipr: rdr&#125;</span><br><span class="line">err = readDirectoryHeader(f, buf)</span><br><span class="line"><span class="keyword">if</span> err == ErrFormat || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.headerOffset += r.baseOffset</span><br><span class="line">r.File = <span class="built_in">append</span>(r.File, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint16</span>(<span class="built_in">len</span>(r.File)) != <span class="keyword">uint16</span>(end.directoryRecords) &#123; <span class="comment">// only compare 16 bits here</span></span><br><span class="line"><span class="comment">// Return the readDirectoryHeader error if we read</span></span><br><span class="line"><span class="comment">// the wrong number of directory entries.</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> zipinsecurepath.Value() == <span class="string">"0"</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line"><span class="keyword">if</span> f.Name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Zip permits an empty file name field.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The zip specification states that names must use forward slashes,</span></span><br><span class="line"><span class="comment">// so consider any backslashes in the name insecure.</span></span><br><span class="line"><span class="keyword">if</span> !filepath.IsLocal(f.Name) || strings.Contains(f.Name, <span class="string">`\`</span>) &#123;</span><br><span class="line">zipinsecurepath.IncNonDefault()</span><br><span class="line"><span class="keyword">return</span> ErrInsecurePath</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-本地复现"><a href="#4-本地复现" class="headerlink" title="4. 本地复现"></a>4. 本地复现</h4><p>本地复现该问题的时候发现解析正常，但是打成镜像容器部署会报错，通过对比我发现本地使用的go的版本是 <a href="https://go.dev/doc/go1.21" target="_blank" rel="noopener">go1.21</a> ，而镜像使用的构建镜像是 <a href="https://go.dev/doc/go1.16" target="_blank" rel="noopener">go1.16</a> 。挨个查阅 golang 的 <a href="https://go.dev/doc/devel/release" target="_blank" rel="noopener">release</a> 最终定位到是 <a href="https://go.dev/doc/go1.19" target="_blank" rel="noopener">go1.19</a> 的新特性导致的差异。<br><img src="/2024/02/18/backend/golang/golang_archive_zip/zip.png" alt><br><a href="https://github.com/golang/go/blob/go1.19/src/archive/zip/reader.go" target="_blank" rel="noopener">相关改动代码</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The count of files inside a zip is truncated to fit in a uint16.</span></span><br><span class="line"><span class="comment">// Gloss over this by reading headers until we encounter</span></span><br><span class="line"><span class="comment">// a bad one, and then only report an ErrFormat or UnexpectedEOF if</span></span><br><span class="line"><span class="comment">// the file count modulo 65536 is incorrect.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    f := &amp;File&#123;zip: z, zipr: r&#125;</span><br><span class="line">    err = readDirectoryHeader(f, buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For compatibility with other zip programs,</span></span><br><span class="line">    <span class="comment">// if we have a non-zero base offset and can't read</span></span><br><span class="line">    <span class="comment">// the first directory header, try again with a zero</span></span><br><span class="line">    <span class="comment">// base offset.</span></span><br><span class="line">    <span class="keyword">if</span> err == ErrFormat &amp;&amp; z.baseOffset != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(z.File) == <span class="number">0</span> &#123;</span><br><span class="line">        z.baseOffset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> _, err = rs.Seek(<span class="keyword">int64</span>(end.directoryOffset), io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        buf.Reset(rs)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == ErrFormat || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    f.headerOffset += z.baseOffset</span><br><span class="line">    z.File = <span class="built_in">append</span>(z.File, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增逻辑解读：如果在读取第一个目录头时遇到 <code>ErrFormat</code> 错误，并且基偏移量不为零，则尝试使用零基偏移量重新读取目录头。如果重新读取目录头仍然失败，则返回错误。</p><blockquote><p>NOTE: 不同操作系统或 ZIP 工具创建的 ZIP 文件时，可能会遇到不同的实现和约定。这可能导致基偏移量的计算方式不同，从而导致错误的值。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>升级golang构建的基础镜像，从<code>1.16</code> -&gt; <code>1.22</code>，重新构建新的服务镜像更新服务，这样基本满足了用户的需求。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># builder</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.22</span> AS builder</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /src/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /src &amp;&amp; go mod tidy</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /src &amp;&amp; go build -ldflags <span class="string">'-linkmode "external" --extldflags "-static"'</span> main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.14</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"blazehu"</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /ipapk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /src/main /ipapk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh /docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> /docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://go.dev/doc/go1.19" target="_blank" rel="noopener">https://go.dev/doc/go1.19</a></li><li><a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">https://docs.bkci.net/services/client-experience</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年给开发商做了一个&lt;a href=&quot;https://docs.bkci.net/services/client-experience&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端版本体验&lt;/a&gt;，近期开发商反馈当上传的ipa文件比较大超过4G的时候上传失败。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://blazehu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="golang" scheme="https://blazehu.github.io/tags/golang/"/>
    
    <category term="archive/zip" scheme="https://blazehu.github.io/tags/archive-zip/"/>
    
  </entry>
  
  <entry>
    <title>Argo CD 消息推送之 SSE</title>
    <link href="https://blazehu.github.io/2023/11/30/cloudnative/argocd_sse/"/>
    <id>https://blazehu.github.io/2023/11/30/cloudnative/argocd_sse/</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2025-03-24T13:21:10.748Z</updated>
    
    <content type="html"><![CDATA[<p>服务器发送事件 (Server-Sent Events) 是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新，并描述了在建立初始客户端连接后服务器如何向客户端发起数据传输。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>在使用Argo CD的时候可以发现页面可以实时刷新应用的状态，比如同步中，那Argo CD是如何实现消息的实时推送的呢？本文将简要介绍Argo CD使用到的消息推送技术：SSE。</p><p><img src="/2023/11/30/cloudnative/argocd_sse/argo_app.png" alt></p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><p>通过浏览器开发者工具可以发现前端请求的地址是 <code>stream/applications</code>，响应头表示这是一个服务器发送事件（Server-Sent Events，SSE）。</p><blockquote><p>本文的源码基于2.6.0版本</p></blockquote><p><img src="/2023/11/30/cloudnative/argocd_sse/argo-eventstream1.png" alt><br><img src="/2023/11/30/cloudnative/argocd_sse/argo-eventstream2.png" alt></p><blockquote><p>Content-Type: text/event-stream：这个响应头告诉客户端，服务器将发送的数据是以文本格式的事件流（Event Stream）。</p></blockquote><h4 id="2-1-客户端实现"><a href="#2-1-客户端实现" class="headerlink" title="2.1 客户端实现"></a>2.1 客户端实现</h4><p>Argo CD的前端使用的是 React，相关代码 <a href="https://github.com/argoproj/argo-cd/blob/v2.6.0/ui/src/app/applications/components/application-details/application-details.tsx" target="_blank" rel="noopener">application-details.tsx</a> 实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">private loadAppInfo(name: string, <span class="attr">appNamespace</span>: string): Observable&lt;&#123;<span class="attr">application</span>: appModels.Application; tree: appModels.ApplicationTree&#125;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">from</span>(services.applications.get(name, appNamespace))</span><br><span class="line">        .pipe(</span><br><span class="line">            mergeMap(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> fallbackTree = &#123;</span><br><span class="line">                    nodes: app.status.resources.map(<span class="function"><span class="params">res</span> =&gt;</span> (&#123;...res, <span class="attr">parentRefs</span>: [], <span class="attr">info</span>: [], <span class="attr">resourceVersion</span>: <span class="string">''</span>, <span class="attr">uid</span>: <span class="string">''</span>&#125;)),</span><br><span class="line">                    orphanedNodes: [],</span><br><span class="line">                    hosts: []</span><br><span class="line">                &#125; <span class="keyword">as</span> appModels.ApplicationTree;</span><br><span class="line">                <span class="keyword">return</span> combineLatest(</span><br><span class="line">                    merge(</span><br><span class="line">                        <span class="keyword">from</span>([app]),</span><br><span class="line">                        <span class="keyword">this</span>.appChanged.pipe(filter(<span class="function"><span class="params">item</span> =&gt;</span> !!item)),</span><br><span class="line">                        AppUtils.handlePageVisibility(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">                            services.applications</span><br><span class="line">                                .watch(&#123;name, appNamespace&#125;)</span><br><span class="line">                                .pipe(</span><br><span class="line">                                    map(<span class="function"><span class="params">watchEvent</span> =&gt;</span> &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (watchEvent.type === <span class="string">'DELETED'</span>) &#123;</span><br><span class="line">                                            <span class="keyword">this</span>.onAppDeleted();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">return</span> watchEvent.application;</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                )</span><br><span class="line">                                .pipe(repeat())</span><br><span class="line">                                .pipe(retryWhen(<span class="function"><span class="params">errors</span> =&gt;</span> errors.pipe(delay(<span class="number">500</span>))))</span><br><span class="line">                        )</span><br><span class="line">                    ),</span><br><span class="line">                    merge(</span><br><span class="line">                        <span class="keyword">from</span>([fallbackTree]),</span><br><span class="line">                        services.applications.resourceTree(name, appNamespace).catch(<span class="function"><span class="params">()</span> =&gt;</span> fallbackTree),</span><br><span class="line">                        AppUtils.handlePageVisibility(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">                            services.applications</span><br><span class="line">                                .watchResourceTree(name, appNamespace)</span><br><span class="line">                                .pipe(repeat())</span><br><span class="line">                                .pipe(retryWhen(<span class="function"><span class="params">errors</span> =&gt;</span> errors.pipe(delay(<span class="number">500</span>))))</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        .pipe(filter(<span class="function">(<span class="params">[application, tree]</span>) =&gt;</span> !!application &amp;&amp; !!tree))</span><br><span class="line">        .pipe(map(<span class="function">(<span class="params">[application, tree]</span>) =&gt;</span> (&#123;application, tree&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadAppInfo</code> 方法的主要目的是从服务器加载应用信息，并在页面可见时实时更新。它返回一个 Observable，包含应用信息 <code>services.applications.watch</code> 和应用资源树 <code>services.applications.watchResourceTree</code>。我们继续查看应用信息的 <code>watch</code> 函数实现。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">public watch(query?: &#123;name?: string; resourceVersion?: string; projects?: string[]; appNamespace?: string&#125;, options?: QueryOptions): Observable&lt;models.ApplicationWatchEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> search = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">    <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query.name) &#123;</span><br><span class="line">            search.set(<span class="string">'name'</span>, query.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (query.resourceVersion) &#123;</span><br><span class="line">            search.set(<span class="string">'resourceVersion'</span>, query.resourceVersion);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (query.appNamespace) &#123;</span><br><span class="line">            search.set(<span class="string">'appNamespace'</span>, query.appNamespace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="keyword">const</span> searchOptions = optionsToSearch(options);</span><br><span class="line">        search.set(<span class="string">'fields'</span>, searchOptions.fields);</span><br><span class="line">        search.set(<span class="string">'selector'</span>, searchOptions.selector);</span><br><span class="line">        search.set(<span class="string">'appNamespace'</span>, searchOptions.appNamespace);</span><br><span class="line">        query?.projects?.forEach(<span class="function"><span class="params">project</span> =&gt;</span> search.append(<span class="string">'projects'</span>, project));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> searchStr = search.toString();</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`/stream/applications<span class="subst">$&#123;(searchStr &amp;&amp; <span class="string">'?'</span> + searchStr) || <span class="string">''</span>&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> requests</span><br><span class="line">        .loadEventSource(url)</span><br><span class="line">        .pipe(repeat())</span><br><span class="line">        .pipe(retry())</span><br><span class="line">        .pipe(map(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.parse(data).result <span class="keyword">as</span> models.ApplicationWatchEvent))</span><br><span class="line">        .pipe(</span><br><span class="line">            map(<span class="function"><span class="params">watchEvent</span> =&gt;</span> &#123;</span><br><span class="line">                watchEvent.application = <span class="keyword">this</span>.parseAppFields(watchEvent.application);</span><br><span class="line">                <span class="keyword">return</span> watchEvent;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数使用 <code>requests.loadEventSource(url)</code> 加载服务器发送的事件流（Event Stream），请求地址为 <code>/stream/applications</code>。<code>loadEventSource</code> 的实现是基于 <code>EventSource</code> 对象的, <code>EventSource</code> 实例设置 <code>onmessage</code> 事件处理程序，当接收到新消息时，调用 <code>observer.next(msg.data)</code> 将消息数据推送到 <code>Observable</code> 实现页面的实时刷新。在文档 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">Using server-sent events</a> 中有介绍, 这里就不详细介绍了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    loadEventSource(url: string): Observable&lt;string&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="function">(<span class="params">observer: Observer&lt;any&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">`<span class="subst">$&#123;apiRoot()&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">            eventSource.onmessage = <span class="function"><span class="params">msg</span> =&gt;</span> observer.next(msg.data);</span><br><span class="line">            eventSource.onerror = <span class="function"><span class="params">e</span> =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                observer.error(e);</span><br><span class="line">                onError.next(e);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EventSource does not provide easy way to get notification when connection closed.</span></span><br><span class="line">            <span class="comment">// check readyState periodically instead.</span></span><br><span class="line">            <span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventSource &amp;&amp; eventSource.readyState === ReadyState.CLOSED) &#123;</span><br><span class="line">                    observer.error(<span class="string">'connection got closed unexpectedly'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                clearInterval(interval);</span><br><span class="line">                eventSource.close();</span><br><span class="line">                eventSource = <span class="literal">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-服务端实现"><a href="#2-2-服务端实现" class="headerlink" title="2.2 服务端实现"></a>2.2 服务端实现</h4><p>Argo CD的后端使用的是 Go，相关代码 <a href="https://github.com/argoproj/argo-cd/blob/v2.6.0/server/application/application.go" target="_blank" rel="noopener">application.go</a> 实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ApplicationService_WatchServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(*v1alpha1.ApplicationWatchEvent) error</span><br><span class="line">    grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Watch</span><span class="params">(q *application.ApplicationQuery, ws application.ApplicationService_WatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">appName := q.GetName()</span><br><span class="line">appNs := s.appNamespaceOrDefault(q.GetAppNamespace())</span><br><span class="line">logCtx := log.NewEntry(log.New())</span><br><span class="line"><span class="keyword">if</span> q.Name != <span class="literal">nil</span> &#123;</span><br><span class="line">logCtx = logCtx.WithField(<span class="string">"application"</span>, *q.Name)</span><br><span class="line">&#125;</span><br><span class="line">projects := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> q.Projects &#123;</span><br><span class="line">projects[q.Projects[i]] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">claims := ws.Context().Value(<span class="string">"claims"</span>)</span><br><span class="line">selector, err := labels.Parse(q.GetSelector())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error parsing labels with selectors: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">minVersion := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> q.GetResourceVersion() != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> minVersion, err = strconv.Atoi(q.GetResourceVersion()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">minVersion = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sendIfPermitted is a helper to send the application to the client's streaming channel if the</span></span><br><span class="line"><span class="comment">// caller has RBAC privileges permissions to view it</span></span><br><span class="line">sendIfPermitted := <span class="function"><span class="keyword">func</span><span class="params">(a appv1.Application, eventType watch.EventType)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(projects) &gt; <span class="number">0</span> &amp;&amp; !projects[a.Spec.GetProject()] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> appVersion, err := strconv.Atoi(a.ResourceVersion); err == <span class="literal">nil</span> &amp;&amp; appVersion &lt; minVersion &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">matchedEvent := (appName == <span class="string">""</span> || (a.Name == appName &amp;&amp; a.Namespace == appNs)) &amp;&amp; selector.Matches(labels.Set(a.Labels))</span><br><span class="line"><span class="keyword">if</span> !matchedEvent &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !s.enf.Enforce(claims, rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, a.RBACName(s.ns)) &#123;</span><br><span class="line"><span class="comment">// do not emit apps user does not have accessing</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s.inferResourcesStatusHealth(&amp;a)</span><br><span class="line">err := ws.Send(&amp;appv1.ApplicationWatchEvent&#123;</span><br><span class="line">Type:        eventType,</span><br><span class="line">Application: a,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logCtx.Warnf(<span class="string">"Unable to send stream message: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">events := <span class="built_in">make</span>(<span class="keyword">chan</span> *appv1.ApplicationWatchEvent, watchAPIBufferSize)</span><br><span class="line"><span class="comment">// Mimic watch API behavior: send ADDED events if no resource version provided</span></span><br><span class="line"><span class="comment">// If watch API is executed for one application when emit event even if resource version is provided</span></span><br><span class="line"><span class="comment">// This is required since single app watch API is used for during operations like app syncing and it is</span></span><br><span class="line"><span class="comment">// critical to never miss events.</span></span><br><span class="line"><span class="keyword">if</span> q.GetResourceVersion() == <span class="string">""</span> || q.GetName() != <span class="string">""</span> &#123;</span><br><span class="line">apps, err := s.appLister.List(selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error listing apps with selector: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(apps, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> apps[i].QualifiedName() &lt; apps[j].QualifiedName()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> apps &#123;</span><br><span class="line">sendIfPermitted(*apps[i], watch.Added)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">unsubscribe := s.appBroadcaster.Subscribe(events)</span><br><span class="line"><span class="keyword">defer</span> unsubscribe()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> event := &lt;-events:</span><br><span class="line">sendIfPermitted(event.Application, event.Type)</span><br><span class="line"><span class="keyword">case</span> &lt;-ws.Context().Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>ws</code> 用于发送实时更新的应用程序事件。当有新的事件发生时，<code>sendIfPermitted</code> 函数会将事件发送到客户端。</p><blockquote><p>NOTE: <code>ws</code> 是一个实现了 <code>ApplicationService_WatchServer</code> 接口的对象。<code>ApplicationService_WatchServer</code> 接口继承了 <code>grpc.ServerStream</code> 接口，并定义了一个名为 <code>Send</code> 的方法。这意味着 <code>ws</code> 可以用作服务器端的流，并具有发送 <code>ApplicationWatchEvent</code> 类型消息的能力。</p></blockquote><h3 id="3-实现一个简单的SSE接口服务样例"><a href="#3-实现一个简单的SSE接口服务样例" class="headerlink" title="3 实现一个简单的SSE接口服务样例"></a>3 实现一个简单的SSE接口服务样例</h3><p><a href="https://github.com/blazehu/sse-demo" target="_blank" rel="noopener">相关代码地址</a>，实现如下效果，页面上通过 sse 获取数据（当前时间和推送人），后端服务由 grpc｜grpc-gateway stream 推送。</p><blockquote><p>NOTE: 后续补充更新中</p></blockquote><p><img src="/2023/11/30/cloudnative/argocd_sse/argo-demo.gif" alt></p><h4 id="3-1-使用-protobuf-定义-gRPC-服务"><a href="#3-1-使用-protobuf-定义-gRPC-服务" class="headerlink" title="3.1 使用 protobuf 定义 gRPC 服务"></a>3.1 使用 protobuf 定义 gRPC 服务</h4><p>新建一个项目<a href="https://github.com/blazehu/sse-demo" target="_blank" rel="noopener">sse-demo</a>，在项目目录下执行<code>go mod init</code>命令完成<code>go module</code>初始化。 在项目目录下创建一个 <a href="https://github.com/blazehu/sse-demo/blob/main/proto/chat.proto" target="_blank" rel="noopener">proto/chat.proto</a> 文件，其内容如下:</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"github.com/blazehu/sse-demo/server/apiclient/chat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/api/annotations.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/empty.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ChatService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Chat(google.protobuf.Empty) <span class="keyword">returns</span> (stream Message) &#123;</span></span><br><span class="line"><span class="function">    option (google.api.http) = &#123;</span></span><br><span class="line"><span class="function">      get: "/api/v1/stream/chat"</span></span><br><span class="line"><span class="function">    &#125;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> user = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> content = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-生成代码"><a href="#3-2-生成代码" class="headerlink" title="3.2 生成代码"></a>3.2 生成代码</h4><p>这用 <a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/generating_stubs/using_buf/" target="_blank" rel="noopener">buf</a> 生成代码，首先在项目目录下执行 <code>buf mod init</code> 生成 <code>buf.yaml</code> 文件，我们需要修改该文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">buf.build/blazehu/sse-demo</span></span><br><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/googleapis/googleapis</span></span><br><span class="line"><span class="attr">breaking:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FILE</span></span><br><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DEFAULT</span></span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 这里主要是添加依赖项 googleapis，<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/adding_annotations/" target="_blank" rel="noopener">相关详细文档</a>。</p></blockquote><p>修改完成后执行 <code>buf mod update</code> 来选择要使用的依赖项的版本。 然后我们创建一个 <code>buf.gen.yaml</code> 文件用于生成存根。<code>buf.gen.yaml</code>文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">plugin:</span> <span class="string">go</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span> <span class="string">paths=source_relative</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">plugin:</span> <span class="string">go-grpc</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span> <span class="string">paths=source_relative,require_unimplemented_servers=false</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">plugin:</span> <span class="string">grpc-gateway</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span> <span class="string">paths=source_relative</span></span><br></pre></td></tr></table></figure><p>这时候我们可以通过 <code>buf generate</code> 生成存根，也可以使用 <code>protoc</code> 来生成存根，这里就不展开说明。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> buf generate</span></span><br></pre></td></tr></table></figure><p>这时候将会由如下的目录结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">├── <span class="selector-tag">buf</span><span class="selector-class">.gen</span><span class="selector-class">.yaml</span></span><br><span class="line">├── <span class="selector-tag">buf</span><span class="selector-class">.lock</span></span><br><span class="line">├── <span class="selector-tag">buf</span><span class="selector-class">.yaml</span></span><br><span class="line">├── <span class="selector-tag">gen</span></span><br><span class="line">│   └── <span class="selector-tag">proto</span></span><br><span class="line">│       ├── <span class="selector-tag">chat</span><span class="selector-class">.pb</span><span class="selector-class">.go</span></span><br><span class="line">│       ├── <span class="selector-tag">chat</span><span class="selector-class">.pb</span><span class="selector-class">.gw</span><span class="selector-class">.go</span></span><br><span class="line">│       └── <span class="selector-tag">chat_grpc</span><span class="selector-class">.pb</span><span class="selector-class">.go</span></span><br><span class="line">├── <span class="selector-tag">go</span><span class="selector-class">.mod</span></span><br><span class="line">└── <span class="selector-tag">proto</span></span><br><span class="line">    └── <span class="selector-tag">chat</span><span class="selector-class">.proto</span></span><br></pre></td></tr></table></figure><h4 id="3-3-实现-GRPC-服务"><a href="#3-3-实现-GRPC-服务" class="headerlink" title="3.3 实现 GRPC 服务"></a>3.3 实现 GRPC 服务</h4><p>上述生成 <code>pb</code> 和 <code>grpc</code> 相关代码后，实现一个 <code>gRPC Server</code> 服务，<a href="https://github.com/blazehu/sse-demo/blob/main/server/server.go" target="_blank" rel="noopener">相关代码</a>如下：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/blazehu/sse-demo/gen/proto"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/protobuf/types/known/emptypb"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server provides chat service</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">chat.UnimplementedChatServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chat returns chat content</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Chat</span><span class="params">(_ *emptypb.Empty, stream chat.ChatService_ChatServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg := chat.Message&#123;</span><br><span class="line">User:    <span class="string">"blazehu"</span>,</span><br><span class="line">Content: time.Now().Format(time.RFC3339),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := stream.Send(&amp;msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":50051"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> opts []grpc.ServerOption</span><br><span class="line">grpcServer := grpc.NewServer(opts...)</span><br><span class="line">chat.RegisterChatServiceServer(grpcServer, &amp;Server&#123;&#125;)</span><br><span class="line">grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑非常简单，定义 <code>Server</code> 对象然后实现了相关的 <code>Chat</code> 方法，然后 main 函数注册并启动了一个 <code>gRPC Server</code> 服务。</p><blockquote><p>NOTE: <code>Chat</code> 方法是每隔一秒钟就发送一条消息，该消息内容就是当前的时间。</p></blockquote><h4 id="3-4-实现-HTTP-服务"><a href="#3-4-实现-HTTP-服务" class="headerlink" title="3.4 实现 HTTP 服务"></a>3.4 实现 HTTP 服务</h4><p>新增 <code>main.go</code> 文件，在 <code>main.go</code> 文件中添加和启动 <code>gRPC-Gateway mux</code>。<a href="https://github.com/blazehu/sse-demo/blob/main/main.go" target="_blank" rel="noopener">相关代码</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/blazehu/sse-demo/gen/proto"</span></span><br><span class="line"><span class="string">"github.com/blazehu/sse-demo/util"</span></span><br><span class="line"><span class="string">"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line">googleproto <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">grpcEndpoint = <span class="string">"localhost:50051"</span></span><br><span class="line">httpPort     = <span class="string">":8080"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFilter</span><span class="params">(ctx context.Context, w http.ResponseWriter, resp googleproto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line">w.Header().Set(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 gRPC 连接</span></span><br><span class="line"><span class="keyword">var</span> opts []grpc.DialOption</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">grpcConn, err := grpc.DialContext(ctx, grpcEndpoint, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Failed to dial server: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> grpcConn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 gRPC-Gateway 服务器</span></span><br><span class="line">gwmux := runtime.NewServeMux(</span><br><span class="line">runtime.WithMarshalerOption(runtime.MIMEWildcard, util.NewCustomTranscoder(&amp;runtime.JSONPb&#123;&#125;)),</span><br><span class="line">runtime.WithForwardResponseOption(myFilter),</span><br><span class="line">)</span><br><span class="line">err = chat.RegisterChatServiceHandler(ctx, gwmux, grpcConn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Failed to register gateway: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 CORS 策略</span></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">handler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>)</span><br><span class="line">w.Header().Set(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET, POST, PUT, DELETE, OPTIONS"</span>)</span><br><span class="line">w.Header().Set(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type, Authorization"</span>)</span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">gwmux.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">mux.Handle(<span class="string">"/"</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 gRPC-Gateway 服务器</span></span><br><span class="line">log.Printf(<span class="string">"Starting gRPC-Gateway on %s"</span>, httpPort)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(httpPort, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为前端 sse 访问需要跨域所以需要设置 <code>CORS</code> 策略，并且返回的消息类型为 <code>text/event-stream</code>，所以我们这里自定义一个 <code>CustomTranscoder</code>，它将 <code>JSON</code> 转换为 <code>text/event-stream</code> 格式。<a href="https://github.com/blazehu/sse-demo/blob/main/util/tool.go" target="_blank" rel="noopener">相关实现</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"</span></span><br><span class="line"><span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomTranscoder <span class="keyword">struct</span> &#123;</span><br><span class="line">marshaler runtime.Marshaler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCustomTranscoder</span><span class="params">(marshaler runtime.Marshaler)</span> *<span class="title">CustomTranscoder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CustomTranscoder&#123;marshaler: marshaler&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">ContentType</span><span class="params">(_ <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"text/event-stream"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jsonBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pb, ok := v.(proto.Message); ok &#123;</span><br><span class="line"><span class="comment">// Marshal message to JSON</span></span><br><span class="line">jsonBytes, err = c.marshaler.Marshal(pb)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// If not a proto.Message, try to marshal it as a regular JSON object</span></span><br><span class="line">jsonBytes, err = json.Marshal(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.WriteString(<span class="string">"data: "</span>)</span><br><span class="line">buf.Write(jsonBytes)</span><br><span class="line">buf.WriteString(<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.marshaler.Unmarshal(data, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> <span class="title">runtime</span>.<span class="title">Decoder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.marshaler.NewDecoder(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> <span class="title">runtime</span>.<span class="title">Encoder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.marshaler.NewEncoder(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 这里需要注意输入值转化为 <code>proto.Message</code> 类型可能会失败，所以我们在 Marshal 方法中添加一个检查，以确保输入值是一个 <code>proto.Message</code> 类型。如果不是，我们可以尝试将其序列化为 <code>JSON</code>。</p></blockquote><h4 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h4><p>同时启动 <code>gRPC Server</code> 和 <code>HTTP Server</code>，然后浏览器访问地址: <a href="http://127.0.0.1:8080/api/v1/stream/chat" target="_blank" rel="noopener">http://127.0.0.1:8080/api/v1/stream/chat</a> ，可以发现浏览器将会每秒刷新一条数据。</p><p><img src="/2023/11/30/cloudnative/argocd_sse/argo-curl.png" alt="img.png"></p><h4 id="3-6-前端实现"><a href="#3-6-前端实现" class="headerlink" title="3.6 前端实现"></a>3.6 前端实现</h4><p>前端使用 <code>vue2</code>，这里就不详细说明了，页面通过 <code>EventSource</code> 与服务端建立通信，然后一直在接收服务端推送的消息，并将消息更新至页面上。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadData();</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="keyword">async</span> loadData() &#123;</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">"http://127.0.0.1:8080/api/v1/stream/chat"</span>);</span><br><span class="line">        eventSource.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'connect eventSource success.'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        eventSource.onmessage =  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">            vm.msg = <span class="string">`<span class="subst">$&#123;data.result.content&#125;</span> - <span class="subst">$&#123;data.result.user&#125;</span> send`</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        eventSource.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'connect eventSource failed.'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.$forceUpdate();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Server-sent_events</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events</a></li><li><a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/generating_stubs/using_buf/" target="_blank" rel="noopener">https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/generating_stubs/using_buf/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;服务器发送事件 (Server-Sent Events) 是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新，并描述了在建立初始客户端连接后服务器如何向客户端发起数据传输。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="argocd" scheme="https://blazehu.github.io/tags/argocd/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
    <category term="sse" scheme="https://blazehu.github.io/tags/sse/"/>
    
  </entry>
  
  <entry>
    <title>Argo CD 源码解析之自动同步</title>
    <link href="https://blazehu.github.io/2023/10/25/cloudnative/argocd_webhook/"/>
    <id>https://blazehu.github.io/2023/10/25/cloudnative/argocd_webhook/</id>
    <published>2023-10-24T16:00:00.000Z</published>
    <updated>2025-03-24T13:20:59.940Z</updated>
    
    <content type="html"><![CDATA[<p>Argo CD 的自动同步功能通过监控 Git 仓库中的更改来自动部署和更新应用程序。这确保了 Kubernetes 集群中的应用程序始终与 Git 仓库中的配置保持一致。开发团队只需将应用程序的描述和配置存储在 Git 仓库中，Argo CD 会根据这些信息自动部署和更新应用程序。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>Argo CD 是一个开源的持续部署工具，专为 Kubernetes 应用程序设计。它遵循 GitOps 原则，将 Git 仓库作为应用程序部署和基础设施管理的“单一真实来源”。架构上 Argo CD 采用基于组件的架构设计，将不同可部署单元的职责分开，以提高系统的灵活性、可维护性和可扩展性。</p><p><img src="/2023/10/25/cloudnative/argocd_webhook/dependencies.png" alt="dependencies"></p><blockquote><p>有关架构的详细介绍可以阅读<a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/" target="_blank" rel="noopener">这篇文档</a>。</p></blockquote><p>通过阅读 Argo CD 官方文档我们可以知道 Argo CD 每三分钟轮询一次 Git 存储库，以检测清单的更改。为了消除轮询延迟，Argo CD API server 支持 <a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/#1-create-the-webhook-in-the-git-provider" target="_blank" rel="noopener">配置 Git Webhook</a>。</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><blockquote><p>本文的源码基于2.6.0版本</p></blockquote><h4 id="2-1-main-go-入口函数"><a href="#2-1-main-go-入口函数" class="headerlink" title="2.1 main.go 入口函数"></a>2.1 main.go 入口函数</h4><p>Argo CD 使用 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a> 来构建应用程序。通过 <code>cmd</code> 目录下的 <code>main.go</code> 入口函数，我们可以很轻易的找到每个组件。根据架构可知 API Server 是控制平面中的唯一入口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">command = apiserver.NewCommand()</span><br></pre></td></tr></table></figure><h4 id="2-2-argocd-server"><a href="#2-2-argocd-server" class="headerlink" title="2.2 argocd-server"></a>2.2 argocd-server</h4><p>阅读 <code>ArgoCDServer</code> 实例的 <code>Run</code> 方法，可以发现 <code>ArgoCDServer</code> 使用 <a href="https://github.com/soheilhy/cmux" target="_blank" rel="noopener"><code>cmux</code></a> 库在多路复用，在同一端口上处理标准 HTTP 和 gRPC 请求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">grpcS, appResourceTreeFn := a.newGRPCServer() </span><br><span class="line">grpcWebS := grpcweb.WrapServer(grpcS)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">httpS = a.newHTTPServer(ctx, a.ListenPort, grpcWebS, appResourceTreeFn, listeners.GatewayConn) </span><br><span class="line"></span><br><span class="line">tcpm := cmux.New(listeners.Main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !a.useTLS() &#123;</span><br><span class="line">    httpL = tcpm.Match(cmux.HTTP1Fast())</span><br><span class="line">    grpcL = tcpm.MatchWithWriters(cmux.HTTP2MatchHeaderFieldSendSettings(<span class="string">"content-type"</span>, <span class="string">"application/grpc"</span>))</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a.checkServeErr(<span class="string">"grpcS"</span>, grpcS.Serve(grpcL)) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a.checkServeErr(<span class="string">"httpS"</span>, httpS.Serve(httpL)) &#125;()</span><br></pre></td></tr></table></figure><p>我在官方文档上找到 Argo CD 中如何实现身份验证（authn）和授权（authz）的一张图，可以发现当我们通过 Web 页面或者 CLI 调用 apiserver 的时候首先经过 <code>cmux</code> 检查匹配，如果请求是 http1.x 将由 <code>http mux</code> 处理，如果是 http2 并且 <code>content-type: application/grpc</code> 则由 <code>grpc Server</code> 处理。</p><p><img src="/2023/10/25/cloudnative/argocd_webhook/apiserver.png" alt="apiserver"></p><blockquote><p>由于 Argo CD apiserver 绝大多数的 API 服务是通过 gRPC 实现的，所以这里引入了 gRPC Gateway 来将 gRPC 服务转换为 RESTful API。</p></blockquote><h5 id="2-2-1-ArgoCDWebhookHandler"><a href="#2-2-1-ArgoCDWebhookHandler" class="headerlink" title="2.2.1 ArgoCDWebhookHandler"></a>2.2.1 ArgoCDWebhookHandler</h5><p>从<a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/#1-create-the-webhook-in-the-git-provider" target="_blank" rel="noopener">配置 Git Webhook</a> 中找到 webhook events 的 endpoint 是 /api/webhook 。是走的 http1.x，我们查看 <code>ArgoCDServer</code> 实例的 <code>newHTTPServer</code> 方法，路径为 “/api/webhook” 的 HTTP 请求映射的是 <code>acdWebhookHandler.Handler</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)</span></span><br><span class="line">argoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)</span><br><span class="line">acdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), <span class="number">24</span>*time.Hour, <span class="number">3</span>*time.Minute), a.Cache, argoDB)</span><br><span class="line"></span><br><span class="line">mux.HandleFunc(<span class="string">"/api/webhook"</span>, acdWebhookHandler.Handler)</span><br></pre></td></tr></table></figure><p>继续往下看 <code>ArgoCDWebhookHandler</code> 的 <code>Handle</code> 方法的具体实现，根据请求的 Header 解析得到不同 Git 服务提供商的 Git 事件的数据，然后交给 <code>HandleEvent</code> 方法来处理，<code>HandleEvent</code> 经过一系列的校验检查后执行 <code>RefreshApp</code> 刷新应用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleEvent handles webhook events for repo push events</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *ArgoCDWebhookHandler)</span> <span class="title">HandleEvent</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-RefreshApp"><a href="#2-2-2-RefreshApp" class="headerlink" title="2.2.2 RefreshApp"></a>2.2.2 RefreshApp</h5><p>注释写的很清楚，<code>RefreshApp</code> 通过更新应用的注解，强制控制器处理它。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RefreshApp updates the refresh annotation of an application to coerce the controller to process it</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RefreshApp</span><span class="params">(appIf v1alpha1.ApplicationInterface, name <span class="keyword">string</span>, refreshType argoappv1.RefreshType)</span> <span class="params">(*argoappv1.Application, error)</span></span> &#123;</span><br><span class="line">metadata := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"metadata"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"annotations"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">argoappv1.AnnotationKeyRefresh: <span class="keyword">string</span>(refreshType),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">patch, err := json.Marshal(metadata)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error marshaling metadata: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> attempt := <span class="number">0</span>; attempt &lt; <span class="number">5</span>; attempt++ &#123;</span><br><span class="line">app, err := appIf.Patch(context.Background(), name, types.MergePatchType, patch, metav1.PatchOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !apierr.IsConflict(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error patching annotations in application %q: %w"</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Infof(<span class="string">"Requested app '%s' refresh"</span>, name)</span><br><span class="line"><span class="keyword">return</span> app, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-application-controller"><a href="#2-3-application-controller" class="headerlink" title="2.3 application-controller"></a>2.3 application-controller</h4><p>沿着之前的路径，从入口函数找到应用控制器的实现，appcontroller 中定义了默认的同步周期为180s。控制器通过 <code>newApplicationInformerAndLister</code> 创建 <code>ApplicationInformer</code> 监听应用的事件并加入到队列中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Default time in seconds for application resync period</span></span><br><span class="line">defaultAppResyncPeriod = <span class="number">180</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">resyncDuration = time.Duration(appResyncPeriod) * time.Second</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">appController, err = controller.NewApplicationController(</span><br><span class="line">    namespace,</span><br><span class="line">    settingsMgr,</span><br><span class="line">    kubeClient,</span><br><span class="line">    appClient,</span><br><span class="line">    repoClientset,</span><br><span class="line">    cache,</span><br><span class="line">    kubectl,</span><br><span class="line">    resyncDuration,</span><br><span class="line">    hardResyncDuration,</span><br><span class="line">    time.Duration(selfHealTimeoutSeconds)*time.Second,</span><br><span class="line">    metricsPort,</span><br><span class="line">    metricsCacheExpiration,</span><br><span class="line">    metricsAplicationLabels,</span><br><span class="line">    kubectlParallelismLimit,</span><br><span class="line">    persistResourceHealth,</span><br><span class="line">    clusterFilter,</span><br><span class="line">    applicationNamespaces)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="keyword">go</span> appController.Run(ctx, statusProcessors, operationProcessors)</span><br></pre></td></tr></table></figure><h5 id="2-3-1-newApplicationInformerAndLister"><a href="#2-3-1-newApplicationInformerAndLister" class="headerlink" title="2.3.1 newApplicationInformerAndLister"></a>2.3.1 newApplicationInformerAndLister</h5><p>上文中 <code>RefreshApp</code> 更新应用的注解将会产生一个 Update Event，将会走到 <code>requestAppRefresh</code> 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">informer.AddEventHandler(</span><br><span class="line">    cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                ctrl.appRefreshQueue.Add(key)</span><br><span class="line">                ctrl.appOperationQueue.Add(key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(<span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key, err := cache.MetaNamespaceKeyFunc(<span class="built_in">new</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> compareWith *CompareWith</span><br><span class="line">            oldApp, oldOK := old.(*appv1.Application)</span><br><span class="line">            newApp, newOK := <span class="built_in">new</span>.(*appv1.Application)</span><br><span class="line">            <span class="keyword">if</span> oldOK &amp;&amp; newOK &amp;&amp; automatedSyncEnabled(oldApp, newApp) &#123;</span><br><span class="line">                log.WithField(<span class="string">"application"</span>, newApp.QualifiedName()).Info(<span class="string">"Enabled automated sync"</span>)</span><br><span class="line">                compareWith = CompareWithLatest.Pointer()</span><br><span class="line">            &#125;</span><br><span class="line">            ctrl.requestAppRefresh(newApp.QualifiedName(), compareWith, <span class="literal">nil</span>)</span><br><span class="line">            ctrl.appOperationQueue.Add(key)</span><br><span class="line">        &#125;,</span><br><span class="line">        DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// IndexerInformer uses a delta queue, therefore for deletes we have to use this</span></span><br><span class="line">            <span class="comment">// key function.</span></span><br><span class="line">            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                ctrl.appRefreshQueue.Add(key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="2-3-2-requestAppRefresh"><a href="#2-3-2-requestAppRefresh" class="headerlink" title="2.3.2 requestAppRefresh"></a>2.3.2 requestAppRefresh</h5><p><code>compareWith</code> 是 <code>CompareWithLatest</code>， <code>after</code> 是 <code>nil</code>。requestAppRefresh 方法将会在 <code>appRefreshQueue</code> 和 <code>appOperationQueue</code> 队列中添加该更新事件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestAppRefresh adds a request for given app to the refresh queue. appName</span></span><br><span class="line"><span class="comment">// needs to be the qualified name of the application, i.e. &lt;namespace&gt;/&lt;name&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">requestAppRefresh</span><span class="params">(appName <span class="keyword">string</span>, compareWith *CompareWith, after *time.Duration)</span></span> &#123;</span><br><span class="line">key := ctrl.toAppKey(appName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> compareWith != <span class="literal">nil</span> &amp;&amp; after != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.appComparisonTypeRefreshQueue.AddAfter(fmt.Sprintf(<span class="string">"%s/%d"</span>, key, compareWith), *after)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> compareWith != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.refreshRequestedAppsMutex.Lock()</span><br><span class="line">ctrl.refreshRequestedApps[key] = compareWith.Max(ctrl.refreshRequestedApps[key])</span><br><span class="line">ctrl.refreshRequestedAppsMutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> after != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.appRefreshQueue.AddAfter(key, *after)</span><br><span class="line">ctrl.appOperationQueue.AddAfter(key, *after)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctrl.appRefreshQueue.Add(key)</span><br><span class="line">ctrl.appOperationQueue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-run"><a href="#2-3-3-run" class="headerlink" title="2.3.3 run"></a>2.3.3 run</h5><p>控制器使用两个单独的队列来处理应用的协调（<code>appRefreshQueue</code>）和同步（<code>appOperationQueue</code>），这两个队列分别通过 <code>processAppRefreshQueueItem</code> 和 <code>processAppOperationQueueItem</code> 来处理。</p><blockquote><p><code>statusProcessors</code> 和 <code>operationProcessors</code> 来控制启动协程的数量。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run starts the Application CRD controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, statusProcessors <span class="keyword">int</span>, operationProcessors <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appRefreshQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appComparisonTypeRefreshQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appOperationQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.projectRefreshQueue.ShutDown()</span><br><span class="line"></span><br><span class="line">ctrl.metricsServer.RegisterClustersInfoSource(ctx, ctrl.stateCache)</span><br><span class="line">ctrl.RegisterClusterSecretUpdater(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> ctrl.appInformer.Run(ctx.Done())</span><br><span class="line"><span class="keyword">go</span> ctrl.projInformer.Run(ctx.Done())</span><br><span class="line"></span><br><span class="line">errors.CheckError(ctrl.stateCache.Init())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), ctrl.appInformer.HasSynced, ctrl.projInformer.HasSynced) &#123;</span><br><span class="line">log.Error(<span class="string">"Timed out waiting for caches to sync"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errors.CheckError(ctrl.stateCache.Run(ctx)) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errors.CheckError(ctrl.metricsServer.ListenAndServe()) &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; statusProcessors; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppRefreshQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; operationProcessors; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppOperationQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppComparisonTypeQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processProjectQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-processAppRefreshQueueItem"><a href="#2-3-4-processAppRefreshQueueItem" class="headerlink" title="2.3.4 processAppRefreshQueueItem"></a>2.3.4 processAppRefreshQueueItem</h5><p>从 <code>appRefreshQueue</code> 获取到上文中更新注解的事件后调用 <code>needRefreshAppStatus</code>，<code>needRefresh, refreshType, comparisonLevel = true, RefreshTypeNormal, CompareWithLatestForceResolve</code>。然后通过 <code>CompareAppState</code> 使用指定的版本和提供的源来比较应用程序 git 状态与实时应用程序状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">appKey, shutdown := ctrl.appRefreshQueue.Get()</span><br><span class="line"></span><br><span class="line">obj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line">origApp, ok := obj.(*appv1.Application)</span><br><span class="line"></span><br><span class="line">needRefresh, refreshType, comparisonLevel := ctrl.needRefreshAppStatus(origApp, ctrl.statusRefreshTimeout, ctrl.statusHardRefreshTimeout)</span><br><span class="line"></span><br><span class="line">compareResult := ctrl.appStateManager.CompareAppState(app, project, revisions, sources,</span><br><span class="line">    refreshType == appv1.RefreshTypeHard,</span><br><span class="line">    comparisonLevel == CompareWithLatestForceResolve, localManifests, hasMultipleSources)</span><br></pre></td></tr></table></figure><blockquote><p>上文提到的三分钟定时轮训也是在 needRefreshAppStatus 中实现。</p></blockquote><p><code>CompareAppState</code> 方法中会调用 <code>appStateManager</code> 实例的 <code>getRepoObjs</code> 来获取 Git 仓库中渲染出的清单文件。<code>getRepoObjs</code> 通过 gRPC 调用 reposerver 的 <code>GenerateManifest</code> 方法获取渲染出的清单文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppStateManager defines methods which allow to compare application spec and actual application state.</span></span><br><span class="line"><span class="keyword">type</span> AppStateManager <span class="keyword">interface</span> &#123;</span><br><span class="line">CompareAppState(app *v1alpha1.Application, project *appv1.AppProject, revisions []<span class="keyword">string</span>, sources []v1alpha1.ApplicationSource, noCache <span class="keyword">bool</span>, noRevisionCache <span class="keyword">bool</span>, localObjects []<span class="keyword">string</span>, hasMultipleSources <span class="keyword">bool</span>) *comparisonResult</span><br><span class="line">SyncAppState(app *v1alpha1.Application, state *v1alpha1.OperationState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// repoClientset 初始化后层层传递至 `AppStateManager` 实例中</span></span><br><span class="line">repoClientset := apiclient.NewRepoServerClientset(repoServerAddress, repoServerTimeoutSeconds, tlsConfig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getRepoObjs 通过 gRPC 调用 reposerver 的 GenerateManifest 方法</span></span><br><span class="line">manifestInfo, err := repoClient.GenerateManifest(context.Background(), &amp;apiclient.ManifestRequest&#123;</span><br><span class="line">    Repo:               repo,</span><br><span class="line">    Repos:              permittedHelmRepos,</span><br><span class="line">    Revision:           revisions[i],</span><br><span class="line">    NoCache:            noCache,</span><br><span class="line">    NoRevisionCache:    noRevisionCache,</span><br><span class="line">    AppLabelKey:        appLabelKey,</span><br><span class="line">    AppName:            app.InstanceName(m.namespace),</span><br><span class="line">    Namespace:          app.Spec.Destination.Namespace,</span><br><span class="line">    ApplicationSource:  &amp;source,</span><br><span class="line">    Plugins:            tools,</span><br><span class="line">    KustomizeOptions:   kustomizeOptions,</span><br><span class="line">    KubeVersion:        serverVersion,</span><br><span class="line">    ApiVersions:        argo.APIResourcesToStrings(apiResources, <span class="literal">true</span>),</span><br><span class="line">    VerifySignature:    verifySignature,</span><br><span class="line">    HelmRepoCreds:      permittedHelmCredentials,</span><br><span class="line">    TrackingMethod:     <span class="keyword">string</span>(argo.GetTrackingMethod(m.settingsMgr)),</span><br><span class="line">    EnabledSourceTypes: enabledSourceTypes,</span><br><span class="line">    HelmOptions:        helmOptions,</span><br><span class="line">    HasMultipleSources: app.Spec.HasMultipleSources(),</span><br><span class="line">    RefSources:         refSources,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>得到 <code>compareResult</code> 后会调用 <code>autoSync</code> 方法，如果应用开启了自动同步，将会更新 <code>Application</code> 的 <code>Operation</code> ，来启动同步操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autoSync will initiate a sync operation for an application configured with automated sync</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">autoSync</span><span class="params">(app *appv1.Application, syncStatus *appv1.SyncStatus, resources []appv1.ResourceStatus)</span> *<span class="title">appv1</span>.<span class="title">ApplicationCondition</span></span></span><br></pre></td></tr></table></figure><p><code>processAppRefreshQueueItem</code> 最后将会调用 <code>persistAppStatus</code> 方法用于持久化，通过调用 k8s api 更新 applicaition 的 status。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// persistAppStatus persists updates to application status. If no changes were made, it is a no-op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">persistAppStatus</span><span class="params">(orig *appv1.Application, newStatus *appv1.ApplicationStatus)</span></span> </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 2.3.5 processAppOperationQueueItem</span></span><br><span class="line"><span class="string">跟 `</span>processAppRefreshQueueItem<span class="string">` 类似，从 `</span>appOperationQueue<span class="string">` 队列中拿到待执行同步操作的应用实例，判断该应用的 `</span>Operation<span class="string">` 字段是否为空，如果不为空则执行 `</span>processRequestedAppOperation<span class="string">`。`</span>processRequestedAppOperation<span class="string">` 也会进行一些状态校验，比如是否正在同步中等，最终应用下资源的同步将由 `</span>appStateManager<span class="string">` 实例的 `</span>SyncAppState<span class="string">` 实现。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">processRequestedAppOperation</span><span class="params">(app *appv1.Application)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> err := argo.ValidateDestination(context.Background(), &amp;app.Spec.Destination, ctrl.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">state.Phase = synccommon.OperationFailed</span><br><span class="line">state.Message = err.Error()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctrl.appStateManager.SyncAppState(app, state)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *appStateManager)</span> <span class="title">SyncAppState</span><span class="params">(app *v1alpha1.Application, state *v1alpha1.OperationState)</span></span> &#123;</span><br><span class="line"><span class="comment">// Sync requests might be requested with ambiguous revisions (e.g. master, HEAD, v1.2.3).</span></span><br><span class="line"><span class="comment">// This can change meaning when resuming operations (e.g a hook sync). After calculating a</span></span><br><span class="line"><span class="comment">// concrete git commit SHA, the SHA is remembered in the status.operationState.syncResult field.</span></span><br><span class="line"><span class="comment">// This ensures that when resuming an operation, we sync to the same revision that we initially</span></span><br><span class="line"><span class="comment">// started with.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    syncCtx, cleanup, err := sync.NewSyncContext(</span><br><span class="line">compareResult.syncStatus.Revision,</span><br><span class="line">reconciliationResult,</span><br><span class="line">restConfig,</span><br><span class="line">rawConfig,</span><br><span class="line">m.kubectl,</span><br><span class="line">app.Spec.Destination.Namespace,</span><br><span class="line">openAPISchema,</span><br><span class="line">opts...,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">state.Phase = common.OperationError</span><br><span class="line">state.Message = fmt.Sprintf(<span class="string">"failed to initialize sync context: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> cleanup()</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> state.Phase == common.OperationTerminating &#123;</span><br><span class="line">syncCtx.Terminate()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">syncCtx.Sync()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/argoproj/argo-cd/blob/6e2f2c9d1e2339b3361f3a057747fcfe30e36f44/controller/sync.go#L296" target="_blank" rel="noopener"><code>syncCtx</code></a> 我们这里看接口定义大致了解即可，具体实现这里就不再展开了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyncContext defines an interface that allows to execute sync operation step or terminate it.</span></span><br><span class="line"><span class="keyword">type</span> SyncContext <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Terminate terminates sync operation. The method is asynchronous: it starts deletion is related K8S resources</span></span><br><span class="line"><span class="comment">// such as in-flight resource hooks, updates operation status, and exists without waiting for resource completion.</span></span><br><span class="line">Terminate()</span><br><span class="line"><span class="comment">// Executes next synchronization step and updates operation status.</span></span><br><span class="line">Sync()</span><br><span class="line"><span class="comment">// Returns current sync operation state and information about resources synchronized so far.</span></span><br><span class="line">GetState() (common.OperationPhase, <span class="keyword">string</span>, []common.ResourceSyncResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <a href="https://github.com/argoproj/gitops-engine/blob/master/pkg/sync/sync_context.go" target="_blank" rel="noopener">SyncContext</a> 是由 <code>gitops-engine</code> 库实现。</p></blockquote><h3 id="3-源码流程图"><a href="#3-源码流程图" class="headerlink" title="3. 源码流程图"></a>3. 源码流程图</h3><p><img src="/2023/10/25/cloudnative/argocd_webhook/request.png" alt="request"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>自动同步是 Argo CD 的核心功能，了解其底层实现原理和源码有助于拓展技术视野，深入理解 Argo CD 的工作原理，并在遇到问题时提供解决方案。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/authz-authn/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/authz-authn/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Argo CD 的自动同步功能通过监控 Git 仓库中的更改来自动部署和更新应用程序。这确保了 Kubernetes 集群中的应用程序始终与 Git 仓库中的配置保持一致。开发团队只需将应用程序的描述和配置存储在 Git 仓库中，Argo CD 会根据这些信息自动部署和更新应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="argocd" scheme="https://blazehu.github.io/tags/argocd/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffers 学习笔记</title>
    <link href="https://blazehu.github.io/2023/03/22/backend/golang/golang_pb/"/>
    <id>https://blazehu.github.io/2023/03/22/backend/golang/golang_pb/</id>
    <published>2023-03-21T16:00:00.000Z</published>
    <updated>2025-07-08T03:47:52.723Z</updated>
    
    <content type="html"><![CDATA[<p>Protocol Buffers 是一种跨语言、跨平台的序列化方法，可实现结构化数据的高效编码和解码。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Protocol Buffers 是一种数据序列化格式，类似于 JSON，但体积更小、速度更快，并支持本地语言绑定。它允许用户定义数据结构，并自动生成源代码，以便在各种数据流和编程语言中轻松读写结构化数据。</p><h3 id="Protocol-Buffers-解决了什么问题？"><a href="#Protocol-Buffers-解决了什么问题？" class="headerlink" title="Protocol Buffers 解决了什么问题？"></a>Protocol Buffers 解决了什么问题？</h3><p>Protocol Buffers 为最大几兆字节的类型化、结构化数据包提供一种序列化格式。该格式适用于短暂的网络传输和长期数据存储。它支持在不影响现有数据或更新代码的情况下扩展新信息，广泛应用于谷歌的服务器间通信和数据存储。它还能保持向后兼容性，支持添加新字段和删除现有字段。</p><h3 id="使用-Protocol-Buffers-有什么好处？"><a href="#使用-Protocol-Buffers-有什么好处？" class="headerlink" title="使用 Protocol Buffers 有什么好处？"></a>使用 Protocol Buffers 有什么好处？</h3><p>Protocol Buffers 非常适合需要以语言无关、平台无关、可扩展的方式序列化结构化、类似记录的类型化数据的任何场景。它们通常用于定义通信协议（与 gRPC 一起使用）以及数据存储。</p><h4 id="使用-Protocol-Buffers-的一些优点"><a href="#使用-Protocol-Buffers-的一些优点" class="headerlink" title="使用 Protocol Buffers 的一些优点"></a>使用 Protocol Buffers 的一些优点</h4><ul><li>紧凑的数据存储</li><li>快速解析</li><li>多种编程语言的支持</li><li>通过自动生成的类优化功能</li></ul><h4 id="跨语言兼容性"><a href="#跨语言兼容性" class="headerlink" title="跨语言兼容性"></a>跨语言兼容性</h4><p>同样的消息可以由任何支持的编程语言编写的代码读取。可以在一个平台上使用 Java 程序从一个软件系统捕获数据，根据 <code>.proto</code> 定义序列化它，然后在另一个平台上运行的单独的 Python 应用程序中从序列化数据中提取特定值。</p><p><strong>Protocol buffers 编译器 protoc 直接支持以下语言：</strong></p><ul><li><a href="https://protobuf.dev/reference/cpp/cpp-generated/#invocation" target="_blank" rel="noopener">C++</a></li><li><a href="https://protobuf.dev/reference/csharp/csharp-generated/#invocation" target="_blank" rel="noopener">C#</a></li><li><a href="https://protobuf.dev/reference/java/java-generated/#invocation" target="_blank" rel="noopener">Java</a></li><li><a href="https://protobuf.dev/reference/kotlin/kotlin-generated/#invocation" target="_blank" rel="noopener">Kotlin</a></li><li><a href="https://protobuf.dev/reference/objective-c/objective-c-generated/#invocation" target="_blank" rel="noopener">Objective-C</a></li><li><a href="https://protobuf.dev/reference/php/php-generated/#invocation" target="_blank" rel="noopener">PHP</a></li><li><a href="https://protobuf.dev/reference/python/python-generated/#invocation" target="_blank" rel="noopener">Python</a></li><li><a href="https://protobuf.dev/reference/ruby/ruby-generated/#invocation" target="_blank" rel="noopener">Ruby</a></li></ul><p><strong>以下语言由 Google 支持，但项目源代码位于 GitHub 仓库。protoc 编译器为这些语言使用插件：</strong></p><ul><li><a href="https://github.com/google/protobuf.dart" target="_blank" rel="noopener">Dart</a></li><li><a href="https://github.com/protocolbuffers/protobuf-go" target="_blank" rel="noopener">Go</a></li></ul><p>其他语言不直接由 Google 支持，而是由其他 GitHub 项目支持。这些语言在协议缓冲区的<a href="https://github.com/protocolbuffers/protobuf/blob/main/docs/third_party.md" target="_blank" rel="noopener">第三方插件</a>中有介绍。</p><h4 id="跨项目支持"><a href="#跨项目支持" class="headerlink" title="跨项目支持"></a>跨项目支持</h4><p>可以通过在 <code>.proto</code> 文件中定义消息类型并将其放置在特定项目代码库之外来在项目之间使用 Protocol buffers。如果你正在定义消息类型或枚举，并预计你的团队之外的人员将广泛使用它们，那么可以将它们放在没有依赖关系的单独文件中。<br>谷歌内部广泛使用的一些 <code>proto</code> 定义示例包括 <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener">timestamp.proto</a> 和 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener">status.proto</a>。</p><h3 id="Go-生成代码指南"><a href="#Go-生成代码指南" class="headerlink" title="Go 生成代码指南"></a>Go 生成代码指南</h3><h4 id="编译器调用"><a href="#编译器调用" class="headerlink" title="编译器调用"></a>编译器调用</h4><p>Protocol buffer 编译器需要一个插件来生成 Go 代码。使用 Go 1.16 或更高版本运行以下命令来安装它：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure><h4 id="定义-proto-文件"><a href="#定义-proto-文件" class="headerlink" title="定义 proto 文件"></a>定义 <code>proto</code> 文件</h4><p>创建如下目录结构和定义一个用于测试的 <code>proto</code> 文件:</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── <span class="keyword">proto</span></span><br><span class="line">    └── demo.<span class="keyword">proto</span></span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> results_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好测试用的消息后，为了生成 GO 代码，还必须为每个 <code>.proto</code> 文件提供 Go 包的导入路径。有两种方式指定Go导入路径：</p><blockquote><p>NOTE: 导入路径就是生成的 Go 代码的文件路径。</p></blockquote><ol><li>在 <code>.proto</code> 文件中声明它</li><li>在调用 protoc 时在命令行上声明它</li></ol><blockquote><p>NOTE: 通常建议在 <code>.proto</code> 文件中声明它，以便通过 <code>.proto</code> 文件本身来集中识别，并简化调用 <code>protoc</code> 时传递的标志集。</p></blockquote><h5 id="1-在-proto-文件中声明"><a href="#1-在-proto-文件中声明" class="headerlink" title="1. 在 .proto 文件中声明"></a>1. 在 <code>.proto</code> 文件中声明</h5><p>在文件中通过 <code>go_package</code> 选项声明：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"proto/demo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> results_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>protoc --proto_path=proto --go_out=. demo.proto</code> 可以看到成功生成了代码：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── proto</span><br><span class="line">    ├── <span class="built_in">demo</span></span><br><span class="line">    │   └── <span class="built_in">demo</span>.pb.<span class="built_in">go</span></span><br><span class="line">    └── <span class="built_in">demo</span>.proto</span><br></pre></td></tr></table></figure><h5 id="2-在调用-protoc-时在命令行上声明"><a href="#2-在调用-protoc-时在命令行上声明" class="headerlink" title="2. 在调用 protoc 时在命令行上声明"></a>2. 在调用 protoc 时在命令行上声明</h5><p>传递一个或多个 <code>M${PROTO_FILE}=${GO_IMPORT_PATH}</code> 标志在命令行上指定。这个例子中通过 <code>--go_opt=Mdemo.proto=proto/demo</code> 声明。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=. --go_opt=Mdemo.proto=proto/demo demo.proto</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: Go 导入路径和 <code>.proto</code> 文件中的包说明符 <code>package</code> 之间没有关联。后者仅与 protobuf 命名空间相关，而前者仅与 Go 命名空间相关。此外，Go 导入路径和 <code>.proto</code> 导入路径之间没有关联。</p></blockquote><h4 id="生成-GO-代码"><a href="#生成-GO-代码" class="headerlink" title="生成 GO 代码"></a>生成 GO 代码</h4><p>使用 <code>protoc</code> 命令生成，如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=. --go_opt=paths=source_relative demo.proto</span><br></pre></td></tr></table></figure><ul><li>proto_path：指定在编译 <code>.proto</code> 文件时查找导入文件的路径</li><li>go_out：生成的 Go 代码的导入路径</li><li>go_opt：用来指定生成的 Go 代码的一些特性，比如是否生成 gRPC 代码、是否使用快速的路径解析器等</li></ul><h5 id="常用的-go-opt-选项"><a href="#常用的-go-opt-选项" class="headerlink" title="常用的 go_opt 选项"></a>常用的 <code>go_opt</code> 选项</h5><ol><li><code>paths=source_relative</code>: 表示生成的 Go 代码的导入路径应该相对于 <code>.proto</code> 文件的源文件路径（即 <code>.proto</code> 文件的相对路径），而不是相对于 <code>GOPATH</code>。</li><li><code>M&lt;proto_import_path&gt;=&lt;go_import_path&gt;</code>: 映射 <code>.proto</code> 文件中的导入路径到 Go 代码中的导入路径。这在处理第三方 <code>.proto</code> 文件时非常有用，特别是当这些文件的导入路径与 Go 代码的导入路径不匹配时。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://protobuf.dev/overview/" target="_blank" rel="noopener">https://protobuf.dev/overview/</a></li><li><a href="https://protobuf.dev/reference/go/go-generated/#invocation" target="_blank" rel="noopener">https://protobuf.dev/reference/go/go-generated/#invocation</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Protocol Buffers 是一种跨语言、跨平台的序列化方法，可实现结构化数据的高效编码和解码。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://blazehu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="https://blazehu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>AntV G6 实现 k8s 资源拓扑图展示</title>
    <link href="https://blazehu.github.io/2023/01/30/frontend/g6_tree_demo/"/>
    <id>https://blazehu.github.io/2023/01/30/frontend/g6_tree_demo/</id>
    <published>2023-01-29T16:00:00.000Z</published>
    <updated>2025-03-24T13:12:32.720Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AntV G6 实现类似 <code>argocd</code> 资源拓扑图的树图。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文主要记录总结如何使用 AntV G6 来展示 k8s 的资源拓扑图，下文简单实现一个 helm 部署 zookeeper 的图例，<a href="https://github.com/blazehu/g6-tree-demo" target="_blank" rel="noopener">代码地址</a> 。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里使用 vue2 来快速搭建一个页面，对 vue 熟悉的可以略过。 相关版本如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BLAZEHU-MB:Projects $ node --version</span><br><span class="line">v14.16.0</span><br><span class="line">BLAZEHU-MB:Projects $ vue --version</span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create g6-tree-demo</span><br></pre></td></tr></table></figure><p>官方快速上手文档：<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application" target="_blank" rel="noopener">https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application</a></p><h4 id="安装-amp-引用-G6"><a href="#安装-amp-引用-G6" class="headerlink" title="安装 &amp; 引用 G6"></a>安装 &amp; 引用 G6</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install --save @antv/g6</span><br></pre></td></tr></table></figure><p>官方快速上手文档：<a href="https://g6.antv.antgroup.com/manual/getting-started" target="_blank" rel="noopener">https://g6.antv.antgroup.com/manual/getting-started</a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h4><p>文件地址：common/index.js，参考官方 <a href="https://github.com/antvis/G6/blob/142e9eaeb8812d2b4770243bd3999166e076cdb3/packages/element/src/nodes/modelRect.ts" target="_blank" rel="noopener">modelRect</a> 内置节点源码。</p><h4 id="拓扑图实现逻辑"><a href="#拓扑图实现逻辑" class="headerlink" title="拓扑图实现逻辑"></a>拓扑图实现逻辑</h4><p>文件地址：components/DemoTree.vue，下面简单介绍：</p><ol><li>页面挂载后注册自定义元素 <code>执行 register 函数，后面简写为函数名</code>，初始化拓扑图 <code>initTree</code>。</li><li>初始化拓扑图首先准备数据 <code>initData</code>，然后创建拓扑图 <code>createTree</code>。</li><li>配置数据源，渲染 <code>data、render</code>。</li><li>更新数据使用 changeData 函数。</li></ol><blockquote><p>NOTE: id 如果不更新 changeData 页面刷新不完全，不能识别到node节点的变化。</p></blockquote><p>最终实现效果如下：<br><img src="/2023/01/30/frontend/g6_tree_demo/demo.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上文简单介绍了如何使用G6来绘制拓扑图，要实现类似 <code>argocd</code> 前端页面的效果我们还需要做节点折叠、节点菜单、节点标签展示等等，后续作者也在陆续完善。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://g6.antv.antgroup.com/manual/faq/performance-opt" target="_blank" rel="noopener">http://g6.antv.antgroup.com/manual/faq/performance-opt</a></li><li><a href="http://g6.antv.antgroup.com/zh/examples/scatter/node/#node" target="_blank" rel="noopener">http://g6.antv.antgroup.com/zh/examples/scatter/node/#node</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 AntV G6 实现类似 &lt;code&gt;argocd&lt;/code&gt; 资源拓扑图的树图。&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://blazehu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="g6" scheme="https://blazehu.github.io/tags/g6/"/>
    
  </entry>
  
  <entry>
    <title>Golang 版本管理工具：g</title>
    <link href="https://blazehu.github.io/2023/01/15/backend/golang/golang_g/"/>
    <id>https://blazehu.github.io/2023/01/15/backend/golang/golang_g/</id>
    <published>2023-01-14T16:00:00.000Z</published>
    <updated>2025-07-08T03:47:16.032Z</updated>
    
    <content type="html"><![CDATA[<p>在开发 Go 项目时，不同项目可能需要不同版本的 Go 语言环境。g 是一个简单而强大的 Go 版本管理工具，它可以帮助我们在同一台主机上轻松切换 Go 版本，并为每个项目创建独立的开发环境，避免版本冲突。</p><a id="more"></a><h3 id="g-安装"><a href="#g-安装" class="headerlink" title="g 安装"></a>g 安装</h3><p>g 是一个跨平台的 Go 版本管理工具，支持 Windows、Linux 和 macOS。<a href="https://github.com/voidint/g?tab=readme-ov-file#installation" target="_blank" rel="noopener">安装文档</a></p><h3 id="g-常用命令"><a href="#g-常用命令" class="headerlink" title="g 常用命令"></a>g 常用命令</h3><ol><li><p>查看可用的 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g ls-remote</span><br></pre></td></tr></table></figure></li><li><p>安装指定版本的 Go</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g install 1.20.3</span><br></pre></td></tr></table></figure></li><li><p>设置全局 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g use 1.20.3</span><br></pre></td></tr></table></figure></li><li><p>查看已安装的 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g ls</span><br></pre></td></tr></table></figure></li><li><p>卸载 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g uninstall 1.20.3</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用 g，我们可以在同一台主机上轻松管理多个 Go 版本，并为每个项目选择合适的版本。这不仅解决了不同项目对 Go 版本的需求，还避免了版本冲突，提高了开发效率。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/voidint/g" target="_blank" rel="noopener">g 文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发 Go 项目时，不同项目可能需要不同版本的 Go 语言环境。g 是一个简单而强大的 Go 版本管理工具，它可以帮助我们在同一台主机上轻松切换 Go 版本，并为每个项目创建独立的开发环境，避免版本冲突。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://blazehu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="https://blazehu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>服务上云后如何使用 perf 生成火焰图</title>
    <link href="https://blazehu.github.io/2022/09/14/cloudnative/perf_analyse/"/>
    <id>https://blazehu.github.io/2022/09/14/cloudnative/perf_analyse/</id>
    <published>2022-09-13T16:00:00.000Z</published>
    <updated>2025-03-24T12:36:48.035Z</updated>
    
    <content type="html"><![CDATA[<p>业务上云迁移至腾讯云 Serverless 集群后，使用<code>perf</code>生成服务器的火焰图。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>业务模块使用的基础镜像是<code>Ubuntu20.04</code>，上云前的做法是在机器上docker run的，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --cap-add CAP_SYS_ADMIN --privileged=true --pid=container:$&#123;targetContainerId&#125; --network=container:$&#123;targetContainerId&#125; $&#123;image&#125;:$&#123;imageTag&#125; -ti ...</span><br></pre></td></tr></table></figure><p>上云后通过在 Pod 中的容器之间共享进程命名空间的方式实现，在业务Pod中注入一个用于<code>perf</code>分析的容器。</p><h3 id="安装-perf"><a href="#安装-perf" class="headerlink" title="安装 perf"></a>安装 perf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install linux-tools-generic</span><br><span class="line">ln -s /usr/lib/linux-tools/5.4.0-125-generic/perf /usr/bin/perf</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>安装 linux-tools-generic 完成后，需要建立软链接，不然查看 <code>perf</code>版本，会提示如下报错信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf</span><br><span class="line">WARNING: perf not found for kernel 5.4.119-1</span><br><span class="line"></span><br><span class="line">  You may need to install the following packages for this specific kernel:</span><br><span class="line">    linux-tools-5.4.119-1-tlinux4-0009-public-eks</span><br><span class="line">    linux-cloud-tools-5.4.119-1-tlinux4-0009-public-eks</span><br><span class="line"></span><br><span class="line">  You may also want to install one of the following packages to keep up to date:</span><br><span class="line">    linux-tools-tlinux4-0009-public-eks</span><br><span class="line">    linux-cloud-tools-tlinux4-0009-public-eks</span><br></pre></td></tr></table></figure><blockquote><p>这里报错其实是因为<code>perf</code>已经内置在<code>linux-tools-generic</code>里面，所以我们安装后创建<code>perf</code>软链接即可（5.4.0-125-generic 版本目录根据实际情况替换即可）。</p></blockquote><h3 id="使用-perf-生成火焰图"><a href="#使用-perf-生成火焰图" class="headerlink" title="使用 perf 生成火焰图"></a>使用 perf 生成火焰图</h3><h4 id="pod-共享进程命名空间"><a href="#pod-共享进程命名空间" class="headerlink" title="pod 共享进程命名空间"></a>pod 共享进程命名空间</h4><p>使用 Pod <code>.spec</code> 中的 <code>shareProcessNamespace</code> 字段可以启用进程命名空间共享，官方例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  shareProcessNamespace: true</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    securityContext:</span><br><span class="line">      capabilities:</span><br><span class="line">        add:</span><br><span class="line">        - SYS_PTRACE</span><br><span class="line">      privileged: true</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>我们需要在 <code>perf</code> 容器中分析业务容器 <code>gamesvr</code>，这个操作需要 SYS_PTRACE 权能。所以我们需要为 <code>perf</code> Container 设置权能。通过安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。</p><p>这里列举部分能力：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CAP_SYS_MODULE: 允许插入和删除内核模块</span><br><span class="line">CAP_SYS_RAWIO:  允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备</span><br><span class="line">CAP_SYS_CHROOT: 允许使用chroot()系统调用</span><br><span class="line">CAP_SYS_PTRACE: 允许跟踪任何进程</span><br><span class="line">CAP_SYS_PACCT:  允许执行进程的BSD式审计</span><br></pre></td></tr></table></figure><p>我们使用 <code>perf</code>来分析业务进程，所以需要 CAP_SYS_PTRACE 权能。</p><blockquote><p>Linux Capabilities 的定义的形式为 CAP_XXX。但是你在 Container 字段使用时，需要将名称中的 CAP_ 部分去掉。例如，要添加 CAP_SYS_PTRACE，可在 capabilities 列表中添加 SYS_PTRACE。</p></blockquote><h4 id="perf-容器注入"><a href="#perf-容器注入" class="headerlink" title="perf 容器注入"></a>perf 容器注入</h4><p>我这里工作负载是使用的 deployment，通过 openkruise sidecarset 注入，这里就不赘述。注入完成后我们 exec 进入 perf 容器，执行 <code>ps -ef</code> 可以看到业务容器的进程 <code>gamesvr</code> 的进程ID是13。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">root@</span>game-server<span class="number">-6</span><span class="number">-6f</span>446dcxxx<span class="number">-5</span>j45b:~# ps -ef </span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /pause</span><br><span class="line">root          <span class="number">13</span>       <span class="number">0</span>  <span class="number">6</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">02</span>:<span class="number">37</span> /root/example/bin/gamesvr</span><br><span class="line">root          <span class="number">26</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> sleep <span class="number">9</span>d</span><br><span class="line">root         <span class="number">786</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">02</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /bin/bash</span><br><span class="line">root         <span class="number">855</span>     <span class="number">842</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">11</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps -ef</span><br></pre></td></tr></table></figure><h4 id="perf-分析"><a href="#perf-分析" class="headerlink" title="perf 分析"></a>perf 分析</h4><p>执行 <code>perf record -F 99 -g -m 1 -p ${targetContainerId} -- sleep 120</code>，targetContainerId 是业务进程ID。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf record -F 99 -g -m 1 -p 13 -- sleep 120</span><br><span class="line">[ perf record: Woken up 65 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.148 MB perf.data (524 samples) ]</span><br></pre></td></tr></table></figure><p>查看分析文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><p>生成火焰图，这里会用到<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">火焰图工具</a>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl &gt; demo.svg</span><br></pre></td></tr></table></figure><p>这里生成的 demo.svg 就是我们需要的火焰图（下面是一个例图）。开发可以通过火焰图来查看看服务的性能热点。</p><p><img src="/2022/09/14/cloudnative/perf_analyse/flame.png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里协助开发使用 <code>perf</code> 生成火焰图的过程中遇到了2个问题，一是安装 <code>perf</code> 装不上报错，二是由于 <code>perf</code> 容器没有 SYS_PTRACE 权能导致生成的分析数据没有函数名称（只有地址信息）。通过协助排查问题加深了对 k8s Security Context的理解。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/</a></li><li><a href="https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html" target="_blank" rel="noopener">https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html</a></li><li><a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">https://github.com/brendangregg/FlameGraph</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;业务上云迁移至腾讯云 Serverless 集群后，使用&lt;code&gt;perf&lt;/code&gt;生成服务器的火焰图。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="perf" scheme="https://blazehu.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04 安装 perf 报错</title>
    <link href="https://blazehu.github.io/2022/09/13/ops/linux/ubuntu_install_perf/"/>
    <id>https://blazehu.github.io/2022/09/13/ops/linux/ubuntu_install_perf/</id>
    <published>2022-09-12T16:00:00.000Z</published>
    <updated>2025-03-24T13:17:17.846Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu20.04系统中安装perf工具时出现的报错问题及解决方法。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>尝试安装<code>perf</code>生成服务器的火焰图，安装<code>perf</code>后报错，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install linux-tools-generic</span><br></pre></td></tr></table></figure><p>安装完成后查看<code>perf</code>版本，发现报错如下<br><img src="/2022/09/13/ops/linux/ubuntu_install_perf/perf_error_1.png" alt="perf_error_1.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实<code>perf</code>已经内置在<code>linux-tools-generic</code>里面，所以安装后创建<code>perf</code>软链接即可（5.4.0-125-generic 版本目录根据实际情况替换即可）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/lib/linux-tools/5.4.0-125-generic/perf /usr/bin/perf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Ubuntu20.04系统中安装perf工具时出现的报错问题及解决方法。&lt;/p&gt;</summary>
    
    
    
    <category term="运维" scheme="https://blazehu.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="perf" scheme="https://blazehu.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾插件问题排查小记</title>
    <link href="https://blazehu.github.io/2022/08/21/devops/landun_plugins_ipapk/"/>
    <id>https://blazehu.github.io/2022/08/21/devops/landun_plugins_ipapk/</id>
    <published>2022-08-20T16:00:00.000Z</published>
    <updated>2025-03-25T06:59:39.677Z</updated>
    
    <content type="html"><![CDATA[<p>2021年给开发商做了一个<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Client-experience/intro.md" target="_blank" rel="noopener">移动端版本体验</a>，最近开发商反馈当上传的文件比较大时经常失败。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>用户报障说蓝盾插件使用经常失败。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="插件执行报错"><a href="#插件执行报错" class="headerlink" title="插件执行报错"></a>插件执行报错</h4><p>报错日志内容如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">202</span> : OverflowError: <span class="built_in">string</span> longer than <span class="number">2147483647</span> bytes</span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">362</span> : ##[error] </span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">362</span> : Fail to run the plugin because of error(Process exited with an error: <span class="number">1</span>)</span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">364</span> : ##[warning]No output</span><br></pre></td></tr></table></figure><p>日志报错分析：该插件是用来上传文件的，使用 <code>requests</code> 库来上传文件，这里报错信息是说明插件上传的文件太大。之前没有考虑到文件太大的情况。</p><h4 id="修复后偶尔报错超时504"><a href="#修复后偶尔报错超时504" class="headerlink" title="修复后偶尔报错超时504"></a>修复后偶尔报错超时504</h4><p><img src="/2022/08/21/devops/landun_plugins_ipapk/img.png" alt="img.png"></p><p>日志报错分析：插件日志504，重试了3次。查看后端服务日志发现业务逻辑正常处理完毕，但是请求返回时 <code>write: broken pipe</code>。这里的报错可以基本判断是由于请求处理时间过长，当后端服务返回时 CLB 已经断开了连接。</p><h5 id="请求调用链路"><a href="#请求调用链路" class="headerlink" title="请求调用链路"></a>请求调用链路</h5><p>蓝盾插件 -&gt; 腾讯云CLB -&gt; 后端服务（CVM上跑的docker）</p><h5 id="腾讯云CLB监控"><a href="#腾讯云CLB监控" class="headerlink" title="腾讯云CLB监控"></a>腾讯云CLB监控</h5><p><img src="/2022/08/21/devops/landun_plugins_ipapk/timeout.png" alt="timeout.png"></p><p>排查到这里可以确定问题根因：CLB 的超时导致的504。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="插件上传报错解决方案"><a href="#插件上传报错解决方案" class="headerlink" title="插件上传报错解决方案"></a>插件上传报错解决方案</h4><p>插件侧优化代码使用 <code>requests-toolbelt</code> 上传文件。同时修改 <a href="https://cloud.tencent.com/document/product/214/15171" target="_blank" rel="noopener">CLB个性化配置</a> 支持超过2G的大文件上传，不缓存客户端请求体。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">5120M</span>;</span><br><span class="line"><span class="attribute">proxy_request_buffering</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">900s</span>;</span><br></pre></td></tr></table></figure><h4 id="超时问题解决方案"><a href="#超时问题解决方案" class="headerlink" title="超时问题解决方案"></a>超时问题解决方案</h4><p>修改 <a href="https://cloud.tencent.com/document/product/214/15171" target="_blank" rel="noopener">CLB个性化配置</a> ，修改超时设置。这里主要修改 <code>proxy_read_timeout</code>。</p><blockquote><p>NOTE: proxy_read_timeout 是控制 CLB 至后端服务之间的超时时间。</p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">900s</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年给开发商做了一个&lt;a href=&quot;https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Client-experience/intro.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端版本体验&lt;/a&gt;，最近开发商反馈当上传的文件比较大时经常失败。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="腾讯云" scheme="https://blazehu.github.io/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Webhook 开发之创建 TLS 证书</title>
    <link href="https://blazehu.github.io/2022/08/16/cloudnative/k8s_csr_tls/"/>
    <id>https://blazehu.github.io/2022/08/16/cloudnative/k8s_csr_tls/</id>
    <published>2022-08-15T16:00:00.000Z</published>
    <updated>2025-03-24T13:20:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>在编写一个准入 Webhook 服务时，需要配置相关证书，k8s 提供了 api 用于对用户自主创建的证书进行认证签发。以下部分演示为 Webhook 服务创建 TLS 证书。</p><a id="more"></a><h3 id="创建-TLS-证书"><a href="#创建-TLS-证书" class="headerlink" title="创建 TLS 证书"></a>创建 TLS 证书</h3><h4 id="创建你的证书"><a href="#创建你的证书" class="headerlink" title="创建你的证书"></a>创建你的证书</h4><p>通过运行以下命令生成私钥:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | cfssl genkey - | cfssljson -bare server</span><br><span class="line">&#123;</span><br><span class="line">  "hosts": [</span><br><span class="line">    "my-svc.my-namespace.svc.cluster.local",</span><br><span class="line">    "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">    "192.0.2.24",</span><br><span class="line">    "10.0.34.2"</span><br><span class="line">  ],</span><br><span class="line">  "CN": "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "ecdsa",</span><br><span class="line">    "size": 256</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>此命令生成两个文件；它生成包含 PEM 编码 PKCS#10 证书请求的 <code>server.csr</code>， 以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p><h4 id="创建证书签名请求（CSR）"><a href="#创建证书签名请求（CSR）" class="headerlink" title="创建证书签名请求（CSR）"></a>创建证书签名请求（CSR）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: certificates.k8s.io/v1beta1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  request: $(cat server.csr | base64 | tr -d '\n')</span><br><span class="line">  usages:</span><br><span class="line">  - digital signature</span><br><span class="line">  - key encipherment</span><br><span class="line">  - server auth</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>你能看到的输出类似于：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certificatesigningrequest.certificates.k8s.io/example created</span><br></pre></td></tr></table></figure><blockquote><p>Warning: certificates.k8s.io/v1beta1 CertificateSigningRequest is deprecated in v1.19+, unavailable in v1.22+; use certificates.k8s.io/v1 CertificateSigningRequest</p></blockquote><p>CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE   SIGNERNAME                     REQUESTOR                 CONDITION</span><br><span class="line">example   17s   kubernetes.io/legacy-unknown   100015926370-1650441195   Pending</span><br></pre></td></tr></table></figure><h4 id="批准证书签名请求（CSR）"><a href="#批准证书签名请求（CSR）" class="headerlink" title="批准证书签名请求（CSR）"></a>批准证书签名请求（CSR）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl certificate approve example</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certificatesigningrequest.certificates.k8s.io/example approved</span><br></pre></td></tr></table></figure><p>你现在应该能看到如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE    SIGNERNAME                     REQUESTOR                 CONDITION</span><br><span class="line">example   5m4s   kubernetes.io/legacy-unknown   100015926370-1650441195   Approved,Issued</span><br></pre></td></tr></table></figure><h4 id="下载证书并使用它"><a href="#下载证书并使用它" class="headerlink" title="下载证书并使用它"></a>下载证书并使用它</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr example -o jsonpath='&#123;.status.certificate&#125;' | base64 --decode &gt; server.crt</span><br></pre></td></tr></table></figure><p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 作为你的服务的 https 认证了。</p><p>例如 <code>kubebuilder</code> 中使用 TLS 证书，将 <code>server.crt</code> 和 <code>server-key.pem</code> 放在 <code>cert</code> 目录中并修改名称为 <code>tls.crt</code> 和 <code>tls.key</code>，然后指定证书目录：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">Scheme:                 scheme,</span><br><span class="line">MetricsBindAddress:     metricsAddr,</span><br><span class="line">Port:                   <span class="number">9443</span>,</span><br><span class="line">HealthProbeBindAddress: probeAddr,</span><br><span class="line">LeaderElection:         enableLeaderElection,</span><br><span class="line">LeaderElectionID:       <span class="string">"27e1b0af.blazehu.com"</span>,</span><br><span class="line">CertDir:                <span class="string">"./cert/"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="从-v1beta1-迁移到-v1"><a href="#从-v1beta1-迁移到-v1" class="headerlink" title="从 v1beta1 迁移到 v1"></a>从 v1beta1 迁移到 v1</h3><p>上述例子使用 <code>certificates.k8s.io/v1beta1</code> API 版本的 <code>CertificateSigningRequest</code> 不在 v1.22 版本中继续提供。<a href="https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/" target="_blank" rel="noopener">官方迁移指南</a>点这里。 我们可以使用 <code>certificates.k8s.io/v1</code> API 版本，此 API 从 v1.19 版本开始可用。</p><ul><li><code>certificates.k8s.io/v1</code> 中需要额外注意的变更：<ul><li>对于请求证书的 API 客户端而言：<ul><li><code>spec.signerName</code> 现在变成必需字段（参阅 <a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers" target="_blank" rel="noopener">已知的 Kubernetes 签署者</a>）， 并且通过 <code>certificates.k8s.io/v1</code> API 不可以创建签署者为 <code>kubernetes.io/legacy-unknown</code> 的请求</li><li><code>spec.usages</code> 现在变成必需字段，其中不可以包含重复的字符串值， 并且只能包含已知的用法字符串</li></ul></li></ul></li></ul><h4 id="创建你的证书-1"><a href="#创建你的证书-1" class="headerlink" title="创建你的证书"></a>创建你的证书</h4><p>通过运行以下命令生成私钥:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | cfssl genkey - | cfssljson -bare server</span><br><span class="line">&#123;</span><br><span class="line">  "hosts": [</span><br><span class="line">    "my-svc.my-namespace.svc.cluster.local",</span><br><span class="line">    "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">    "192.0.2.24",</span><br><span class="line">    "10.0.34.2"</span><br><span class="line">  ],</span><br><span class="line">  "CN": "my-pod.my-namespace.pod.cluster.local",</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "ecdsa",</span><br><span class="line">    "size": 256</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="创建证书签名请求（CSR）-1"><a href="#创建证书签名请求（CSR）-1" class="headerlink" title="创建证书签名请求（CSR）"></a>创建证书签名请求（CSR）</h4><p>这里 csr signerName 不能是 <code>kubernetes.io/legacy-unknown</code>，演示我们随便指定一个为 <code>example.com/serving</code>，v1beta1 版本默认是 <code>kubernetes.io/legacy-unknown</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: certificates.k8s.io/v1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  request: $(cat server.csr | base64 | tr -d '\n')</span><br><span class="line">  signerName: example.com/serving</span><br><span class="line">  usages:</span><br><span class="line">  - digital signature</span><br><span class="line">  - key encipherment</span><br><span class="line">  - server auth</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="批准证书签名请求（CSR）-1"><a href="#批准证书签名请求（CSR）-1" class="headerlink" title="批准证书签名请求（CSR）"></a>批准证书签名请求（CSR）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl certificate approve example</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certificatesigningrequest.certificates.k8s.io/example approved</span><br></pre></td></tr></table></figure><p>你现在应该能看到如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE   SIGNERNAME            REQUESTOR                 CONDITION</span><br><span class="line">example   11s   example.com/serving   100015926370-1650441195   Approved</span><br></pre></td></tr></table></figure><p>这里可以看到证书请求已被批准，但是没有自动签名，正在等待请求的签名者对其签名。</p><h4 id="签名证书签名请求（CSR）"><a href="#签名证书签名请求（CSR）" class="headerlink" title="签名证书签名请求（CSR）"></a>签名证书签名请求（CSR）</h4><p>我们扮演证书签署者的角色，颁发证书并将其上传到 API 服务器。</p><h5 id="创建证书颁发机构"><a href="#创建证书颁发机构" class="headerlink" title="创建证书颁发机构"></a>创建证书颁发机构</h5><p>通过运行以下命令创建签名证书:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca</span><br><span class="line">&#123;</span><br><span class="line">  "CN": "example.com/serving",</span><br><span class="line">  "key": &#123;</span><br><span class="line">    "algo": "rsa",</span><br><span class="line">    "size": 2048</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>这会产生一个证书颁发机构密钥文件（<code>ca-key.pem</code>）和证书（<code>ca.pem</code>）。</p><h5 id="颁发证书"><a href="#颁发证书" class="headerlink" title="颁发证书"></a>颁发证书</h5><p>创建文件 <code>server-signing-config.json</code> 内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"signing"</span>: &#123;</span><br><span class="line">    <span class="attr">"default"</span>: &#123;</span><br><span class="line">      <span class="attr">"usages"</span>: [</span><br><span class="line">        <span class="string">"digital signature"</span>,</span><br><span class="line">        <span class="string">"key encipherment"</span>,</span><br><span class="line">        <span class="string">"server auth"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"expiry"</span>: <span class="string">"876000h"</span>,</span><br><span class="line">      <span class="attr">"ca_constraint"</span>: &#123;</span><br><span class="line">        <span class="attr">"is_ca"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>server-signing-config.json</code> 签名配置、证书颁发机构密钥文件和证书来签署证书请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr example -o jsonpath='&#123;.spec.request&#125;' | \</span><br><span class="line">  base64 --decode | \</span><br><span class="line">  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | \</span><br><span class="line">  cfssljson -bare ca-signed-server</span><br></pre></td></tr></table></figure><p>这会生成一个签名的服务证书文件，<code>ca-signed-server.pem</code>。</p><h5 id="上传签名证书"><a href="#上传签名证书" class="headerlink" title="上传签名证书"></a>上传签名证书</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr example -o json | \</span><br><span class="line">  jq '.status.certificate = "'$(base64 ca-signed-server.pem | tr -d '\n')'"' | \</span><br><span class="line">  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/example/status -f -</span><br></pre></td></tr></table></figure><p>批准 CSR 并上传签名证书后，你现在应该能看到如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get csr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME      AGE   SIGNERNAME            REQUESTOR                 CONDITION</span><br><span class="line">example   10m   example.com/serving   100015926370-1650441195   Approved,Issued</span><br></pre></td></tr></table></figure><p>这是你可以正常下载证书并使用它了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/#configuring-your-cluster-to-provide-signing" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/#configuring-your-cluster-to-provide-signing</a></li><li><a href="https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在编写一个准入 Webhook 服务时，需要配置相关证书，k8s 提供了 api 用于对用户自主创建的证书进行认证签发。以下部分演示为 Webhook 服务创建 TLS 证书。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Watching Resources</title>
    <link href="https://blazehu.github.io/2022/07/08/cloudnative/kubebuilder_watch_resource/"/>
    <id>https://blazehu.github.io/2022/07/08/cloudnative/kubebuilder_watch_resource/</id>
    <published>2022-07-07T16:00:00.000Z</published>
    <updated>2025-03-24T13:20:26.607Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发过程中，可能需要开发一个类似<code>Deployment</code>的资源逻辑，管理依赖资源是控制器的基础，如果不能观察它们的状态变化就不可能管理它们。这就意味着，我们需要 <code>reconciler</code> 能监控多个资源的变化。</p><a id="more"></a><blockquote><p>NOTE: <code>Deployment</code> 必须知道其管理的 <code>ReplicaSet</code> 何时更改，<code>ReplicaSet</code> 必须知道其管理的 <code>Pod</code> 何时被删除，或者从健康变为不健康等。</p></blockquote><p>控制器运行时库为管理和监视资源提供了多种方式。这包括从简单而明显的用例（例如查看由控制器创建和管理的资源）到更独特和更高级的用例。</p><ul><li>控制器创建和管理的资源 (Watching Operator Managed Resources)</li><li>外部管理的资源 (Watching Externally Managed Resources)</li></ul><br><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>以 <code>Tcaplus</code> 资源为例，<code>Tcaplus</code> 资源通过 <code>ConfigMap</code>（proto 文件）来创建表格。当 <code>ConfigMap</code> 发生变化时自动更新表格，下面例子不实际调用腾讯云API，只要验证接收到事件请求即可。</p><blockquote><p>NOTE: <code>TcaplusDB</code> 是腾讯出品的分布式NoSQL数据库。官方API文档：<a href="https://cloud.tencent.com/document/product/596/39648。" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/596/39648。</a></p></blockquote><br><h3 id="控制器创建和管理的资源"><a href="#控制器创建和管理的资源" class="headerlink" title="控制器创建和管理的资源"></a>控制器创建和管理的资源</h3><h4 id="资源定义-Defined-Tcaplus-Resources"><a href="#资源定义-Defined-Tcaplus-Resources" class="headerlink" title="资源定义 (Defined Tcaplus Resources)"></a>资源定义 (Defined Tcaplus Resources)</h4><p><strong>api/v1/tcaplus_types.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TcaplusSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Checksum          <span class="keyword">string</span>             <span class="string">`json:"checksum,omitempty"`</span></span><br><span class="line">ConfigMapTemplate ConfigMapTemplate  <span class="string">`json:"configMapTemplate,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigMapTemplate <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span>            <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">Data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="string">`json:"data,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制器逻辑-Manage-the-Owned-Resource"><a href="#控制器逻辑-Manage-the-Owned-Resource" class="headerlink" title="控制器逻辑 (Manage the Owned Resource)"></a>控制器逻辑 (Manage the Owned Resource)</h4><p><strong>controllers/tcaplus_controller.go</strong><br>当 <code>tcaplus</code> CR 创建时根据 <code>ConfigMapTemplate</code> 创建附属的 <code>ConfigMap</code> 资源并设置<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/" target="_blank" rel="noopener">属主关系</a>。</p><ul><li><code>Reconcile</code> 方法：根据模版创建 <code>ConfigMap</code> 并设置属主关系</li><li><code>SetupWithManager</code> 方法：<code>For</code> 方法之后调用 <code>Owns</code> 方法<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">Reconcile</span><span class="params">(ctx context.Context, req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> &#123;</span><br><span class="line">logger := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">"reconciling"</span>)</span><br><span class="line">tcaplus := &amp;examplev1.Tcaplus&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, tcaplus); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configMap := &amp;corev1.ConfigMap&#123;&#125;</span><br><span class="line">configMap.Name = tcaplus.Spec.ConfigMapTemplate.Name</span><br><span class="line">configMap.Namespace = tcaplus.Namespace</span><br><span class="line">configMap.Data = tcaplus.Spec.ConfigMapTemplate.Data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> err := controllerutil.SetControllerReference(tcaplus, configMap, r.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">"get configmap failed"</span>, <span class="string">"configmap"</span>, configMap.Name)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foundConfigMap := &amp;corev1.ConfigMap&#123;&#125;</span><br><span class="line">err := r.Get(ctx, types.NamespacedName&#123;Name: configMap.Name, Namespace: tcaplus.Namespace&#125;, foundConfigMap)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; errors.IsNotFound(err) &#123;</span><br><span class="line">logger.V(<span class="number">1</span>).Info(<span class="string">"creating configmap"</span>, <span class="string">"configmap"</span>, configMap.Name)</span><br><span class="line">err = r.Create(ctx, configMap)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupWithManager sets up the controller with the Manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">SetupWithManager</span><span class="params">(mgr ctrl.Manager)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;examplev1.Tcaplus&#123;&#125;).</span><br><span class="line">Owns(&amp;corev1.ConfigMap&#123;&#125;).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE：同一控制器创建的资源才可以设置属主关系，不然会提示：already owned by another controller。</p></blockquote></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>config/samples/example_v1_tcaplus.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.blazehu.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Tcaplus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">checksum:</span> <span class="string">"123"</span></span><br><span class="line">  <span class="attr">configMapTemplate:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"tcaplus-configmap-example"</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="attr">demo.proto:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">syntax</span> <span class="string">=</span> <span class="string">"proto3"</span><span class="string">;</span></span><br><span class="line">        <span class="string">package</span> <span class="string">example;</span></span><br><span class="line">        <span class="string">message</span> <span class="string">Example</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">uint32</span> <span class="string">a</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">          <span class="string">uint32</span> <span class="string">b</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">          <span class="string">uint32</span> <span class="string">c</span> <span class="string">=</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用上述配置文件创建 <code>tcaplus</code> 资源。创建结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BLAZEHU-MB2:samples $ k get tcaplus</span><br><span class="line">NAME             AGE</span><br><span class="line">tcaplus-sample   19m</span><br><span class="line">BLAZEHU-MB2:samples $ k get configmap</span><br><span class="line">NAME                        DATA   AGE</span><br><span class="line">tcaplus-configmap-example   1      19m</span><br></pre></td></tr></table></figure><p>可以查看 <code>tcaplus-configmap-example</code> 的属主关系：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">demo.proto:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">syntax</span> <span class="string">=</span> <span class="string">"proto3"</span><span class="string">;</span></span><br><span class="line">    <span class="string">package</span> <span class="string">example;</span></span><br><span class="line">    <span class="string">message</span> <span class="string">Example</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">a</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">b</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">"2022-07-07T09:02:43Z"</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-configmap-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">example.blazehu.com/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Tcaplus</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tcaplus-sample</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">7c50f2e1-0e37-4aa0-bf49-c2d410d6153e</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">"6837330713"</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/default/configmaps/tcaplus-configmap-example</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">6c29f90b-0e51-4d9f-a6a8-cfb6906ed1b0</span></span><br></pre></td></tr></table></figure><p>手动修改 <code>tcaplus-sample</code> 和 <code>tcaplus-configmap-example</code> 后查看控制器日志发现能正常观察 <code>CR</code> 和 <code>ConfigMap</code> 的变化了。</p><h3 id="外部管理的资源"><a href="#外部管理的资源" class="headerlink" title="外部管理的资源"></a>外部管理的资源</h3><h4 id="资源定义-Defined-Tcaplus-Resources-1"><a href="#资源定义-Defined-Tcaplus-Resources-1" class="headerlink" title="资源定义 (Defined Tcaplus Resources)"></a>资源定义 (Defined Tcaplus Resources)</h4><p><strong>api/v1/tcaplus_types.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TcaplusSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">Checksum     <span class="keyword">string</span>             <span class="string">`json:"checksum,omitempty"`</span></span><br><span class="line">ConfigMapRef ConfigMapReference <span class="string">`json:"configMapRef,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigMapReference <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="控制器逻辑-Manage-the-Owned-Resource-1"><a href="#控制器逻辑-Manage-the-Owned-Resource-1" class="headerlink" title="控制器逻辑 (Manage the Owned Resource)"></a>控制器逻辑 (Manage the Owned Resource)</h4><p><strong>controllers/tcaplus_controller.go</strong><br><code>For</code> 方法之后调用 <code>Watches</code> 方法就可以监听对应资源的事件，但是会监听集群里所有相关资源的事件，所以这里我们自定义事件处理方法来过滤出我们关注的资源的事件。</p><ul><li>通过 <code>EnqueueRequestsFromMapFunc</code> 创建一个事件处理方法，该方法通过 <code>FieldSelector</code> 在 <code>ConfigMap</code> 的事件中过滤出跟 <code>tcaplus CR</code> 相关联的事件。</li><li>使用 <code>FieldSelector</code> 时我们需要建立对应的索引，使用 <code>mgr.GetFieldIndexer().IndexField()</code> 创建。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ConfigMapField = <span class="string">".spec.configMapRef.name"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">findObjectsForConfigMap</span><span class="params">(configMap client.Object)</span> []<span class="title">reconcile</span>.<span class="title">Request</span></span> &#123;</span><br><span class="line">attachedTcaplusList := &amp;examplev1.TcaplusList&#123;&#125;</span><br><span class="line">listOps := &amp;client.ListOptions&#123;</span><br><span class="line">FieldSelector: fields.OneTermEqualSelector(ConfigMapField, configMap.GetName()),</span><br><span class="line">Namespace:     configMap.GetNamespace(),</span><br><span class="line">&#125;</span><br><span class="line">err := r.List(context.TODO(), attachedTcaplusList, listOps)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []reconcile.Request&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests := <span class="built_in">make</span>([]reconcile.Request, <span class="built_in">len</span>(attachedTcaplusList.Items))</span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> attachedTcaplusList.Items &#123;</span><br><span class="line">requests[i] = reconcile.Request&#123;</span><br><span class="line">NamespacedName: types.NamespacedName&#123;</span><br><span class="line">Name:      item.GetName(),</span><br><span class="line">Namespace: item.GetNamespace(),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> requests</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupWithManager sets up the controller with the Manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *TcaplusReconciler)</span> <span class="title">SetupWithManager</span><span class="params">(mgr ctrl.Manager)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := mgr.GetFieldIndexer().IndexField(context.Background(), &amp;examplev1.Tcaplus&#123;&#125;, ConfigMapField, <span class="function"><span class="keyword">func</span><span class="params">(rawObj client.Object)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">tcaplus := rawObj.(*examplev1.Tcaplus)</span><br><span class="line"><span class="keyword">if</span> tcaplus.Spec.ConfigMapRef.Name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">string</span>&#123;tcaplus.Spec.ConfigMapRef.Name&#125;</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;examplev1.Tcaplus&#123;&#125;).</span><br><span class="line">Watches(</span><br><span class="line">&amp;source.Kind&#123;Type: &amp;corev1.ConfigMap&#123;&#125;&#125;,</span><br><span class="line">handler.EnqueueRequestsFromMapFunc(r.findObjectsForConfigMap),</span><br><span class="line">builder.WithPredicates(predicate.ResourceVersionChangedPredicate&#123;&#125;),</span><br><span class="line">).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面 <code>ConfigMap</code> 监听使用默认的 <code>Predicates</code> 过滤器 <code>ResourceVersionChangedPredicate</code>，查看源码定义就是说当 resource version 变化时事件会入队。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ResourceVersionChangedPredicate implements a default update predicate function on resource version change.</span></span><br><span class="line"><span class="keyword">type</span> ResourceVersionChangedPredicate <span class="keyword">struct</span> &#123;</span><br><span class="line">Funcs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 我们也可以自己定一个变更过滤器 <code>Predicate</code>。也可以通过 <code>WithEventFilter</code> 来针对监听的所有资源过滤。</p></blockquote></li></ul><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><strong>config/samples/example_v1_tcaplus.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-configmap-example</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">demo.proto:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">syntax</span> <span class="string">=</span> <span class="string">"proto3"</span><span class="string">;</span></span><br><span class="line">    <span class="string">package</span> <span class="string">example;</span></span><br><span class="line">    <span class="string">message</span> <span class="string">Example</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">a</span> <span class="string">=</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">b</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span></span><br><span class="line">      <span class="string">uint32</span> <span class="string">c</span> <span class="string">=</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">example.blazehu.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Tcaplus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcaplus-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">checksum:</span> <span class="string">"123"</span></span><br><span class="line">  <span class="attr">configMapRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">"tcaplus-configmap-example"</span></span><br></pre></td></tr></table></figure><p>使用上述配置创建完毕后，手动修改 <code>tcaplus-sample</code> 和 <code>tcaplus-configmap-example</code> 查看控制器日志发现同样能正常观察 <code>CR</code> 和 <code>ConfigMap</code> 的变化。</p><blockquote><p>NOTE: 查看 <code>tcaplus-configmap-example</code> 可以看到没有和 <code>tcaplus</code> 的属主关系。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>EventHandler</code> 可以在 <code>watch</code> 特定资源时设置该资源的事件监听规则。</li><li><code>WithEventFilter</code> 配置变更过滤器，可以针对 <code>watch</code> 的所有资源，统一地设置事件监听规则。</li><li><code>Owns</code> 源码分析可以发现 <code>Owns</code> 相当于调用 <code>Watches(&amp;source.Kind{Type: &lt;ForType-forInput&gt;}, &amp;handler.EnqueueRequestForOwner{OwnerType: apiType, IsController: true})</code>。</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.kubebuilder.io/reference/watching-resources.html" target="_blank" rel="noopener">https://www.kubebuilder.io/reference/watching-resources.html</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/</a></li><li><a href="https://segmentfault.com/a/1190000020359577" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020359577</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在开发过程中，可能需要开发一个类似&lt;code&gt;Deployment&lt;/code&gt;的资源逻辑，管理依赖资源是控制器的基础，如果不能观察它们的状态变化就不可能管理它们。这就意味着，我们需要 &lt;code&gt;reconciler&lt;/code&gt; 能监控多个资源的变化。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Admission Webhooks</title>
    <link href="https://blazehu.github.io/2022/04/12/cloudnative/kubebuilder_admission_webhooks/"/>
    <id>https://blazehu.github.io/2022/04/12/cloudnative/kubebuilder_admission_webhooks/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2025-03-24T13:20:24.397Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="1-什么是准入控制"><a href="#1-什么是准入控制" class="headerlink" title="1. 什么是准入控制?"></a>1. 什么是准入控制?</h3><p>准入控制（Admission Controller）是 Kubernetes API Server 用于拦截请求的一种手段。Admission 可以做到对请求的资源对象进行校验，修改。service mesh 最近很火的项目 Istio 天生支持 Kubernetes，利用的就是 Admission 对服务实例自动注入 sidecar。</p><h3 id="2-什么是准入-Webhook？"><a href="#2-什么是准入-Webhook？" class="headerlink" title="2. 什么是准入 Webhook？"></a>2. 什么是准入 Webhook？</h3><p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。 可以定义两种类型的准入 webhook，即 验证性质的准入 Webhook 和 修改性质的准入 Webhook。修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API 服务器的对象以执行自定义的设置默认值操作。</p><p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后， 验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p><blockquote><p>说明： 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。 则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。</p></blockquote><p><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/webhook1.jpeg" alt></p><h3 id="3-尝试准入-Webhook"><a href="#3-尝试准入-Webhook" class="headerlink" title="3. 尝试准入 Webhook"></a>3. 尝试准入 Webhook</h3><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><ul><li>确保 Kubernetes 集群版本至少为 v1.16（以便使用 admissionregistration.k8s.io/v1 API） 或者 v1.9 （以便使 admissionregistration.k8s.io/v1beta1 API）。</li><li>确保启用 <code>MutatingAdmissionWebhook</code> 和 <code>ValidatingAdmissionWebhook</code> 控制器。 <a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use" target="_blank" rel="noopener">这里</a>是一组推荐的 admission 控制器，通常可以启用。</li><li>确保启用了 admissionregistration.k8s.io/v1beta1 API。</li></ul><h3 id="4-配置准入-Webhook"><a href="#4-配置准入-Webhook" class="headerlink" title="4. 配置准入 Webhook"></a>4. 配置准入 Webhook</h3><p>你可以通过 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io" target="_blank" rel="noopener">ValidatingWebhookConfiguration</a> 或者 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io" target="_blank" rel="noopener">MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。详细配置可以参阅 <a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#webhook-configuration" target="_blank" rel="noopener">Webhook配置</a> 部分。</p><h3 id="5-认证和信任"><a href="#5-认证和信任" class="headerlink" title="5. 认证和信任"></a>5. 认证和信任</h3><p>默认情况下，apiserver不会向webhooks进行身份验证。但是，如果您想对客户端进行身份验证，可以将apiserver配置为使用基本身份验证、承载令牌或证书对Webhook进行身份验证。你可以在<a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#authenticate-apiservers" target="_blank" rel="noopener">这里</a>找到详细的步骤。</p><h3 id="6-编写一个准入-Webhook-服务器"><a href="#6-编写一个准入-Webhook-服务器" class="headerlink" title="6. 编写一个准入 Webhook 服务器"></a>6. 编写一个准入 Webhook 服务器</h3><p>Webhook Admission 属于同步调用，需要用户部署自己的 webhook server，创建自定义的配置资源对象： ValidatingWebhookConfiguration 或 MutatingWebhookConfiguration。下面使用 kubebuilder 开发一个简单的 demo。</p><h4 id="6-1-创建项目"><a href="#6-1-创建项目" class="headerlink" title="6.1 创建项目"></a>6.1 创建项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubebuilder init --domain blazehu.com --owner <span class="string">"blazehu"</span> --repo blazehu.com/kubegame</span><br></pre></td></tr></table></figure><blockquote><p>提示： 这里通过 kubebuilder v3 创建的话，在 config 目录下会缺少 certmanager、webhook 目录以及 default/manager_webhook_patch.yml 和 webhookcainjection_patch.yaml 文件。可以通过从v2生成拷贝过来进行修改。</p></blockquote><h4 id="6-2-创建控制器"><a href="#6-2-创建控制器" class="headerlink" title="6.2 创建控制器"></a>6.2 创建控制器</h4><p>这里只需要创建一个控制器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubebuilder create api --group svc --version v1 --kind App</span><br></pre></td></tr></table></figure><h4 id="6-3-创建-webhook"><a href="#6-3-创建-webhook" class="headerlink" title="6.3 创建 webhook"></a>6.3 创建 webhook</h4><h5 id="Implement-Your-Handler"><a href="#Implement-Your-Handler" class="headerlink" title="Implement Your Handler"></a>Implement Your Handler</h5><p>新增 mutatingwebhook.go &amp; validatingwebhook.go 文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mutatingwebhook.go</span></span><br><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line">corev1 <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/client"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/webhook/admission"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +kubebuilder:webhook:admissionReviewVersions=v1,sideEffects=None,path=/mutate-v1-svc,mutating=true,failurePolicy=fail,groups="",resources=services,verbs=create;update,versions=v1,name=msvc.kb.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameAnnotator annotates Pods</span></span><br><span class="line"><span class="keyword">type</span> KubeGameAnnotator <span class="keyword">struct</span> &#123;</span><br><span class="line">Client  client.Client</span><br><span class="line">decoder *admission.Decoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle adds an annotation to every incoming pods.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *KubeGameAnnotator)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, req admission.Request)</span> <span class="title">admission</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">pod := &amp;corev1.Pod&#123;&#125;</span><br><span class="line"></span><br><span class="line">err := a.decoder.Decode(req, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pod.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">pod.Annotations = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pod.Annotations[<span class="string">"example-mutating-admission-webhook"</span>] = <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line">marshaledPod, err := json.Marshal(pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusInternalServerError, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> admission.PatchResponseFromRaw(req.Object.Raw, marshaledPod)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameAnnotator implements admission.DecoderInjector.</span></span><br><span class="line"><span class="comment">// A decoder will be automatically injected.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InjectDecoder injects the decoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *KubeGameAnnotator)</span> <span class="title">InjectDecoder</span><span class="params">(d *admission.Decoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">a.decoder = d</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// validatingwebhook.go</span></span><br><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">corev1 <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/client"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/webhook/admission"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// +kubebuilder:webhook:admissionReviewVersions=v1,sideEffects=None,path=/validate-v1-svc,mutating=false,failurePolicy=fail,groups="",resources=services,verbs=create;update,versions=v1,name=vsvc.kb.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameValidator validates Pods</span></span><br><span class="line"><span class="keyword">type</span> KubeGameValidator <span class="keyword">struct</span> &#123;</span><br><span class="line">Client  client.Client</span><br><span class="line">decoder *admission.Decoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle admits a pod if a specific annotation exists.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *KubeGameValidator)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, req admission.Request)</span> <span class="title">admission</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">pod := &amp;corev1.Pod&#123;&#125;</span><br><span class="line"></span><br><span class="line">err := v.decoder.Decode(req, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Errored(http.StatusBadRequest, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key := <span class="string">"example-mutating-admission-webhook"</span></span><br><span class="line">anno, found := pod.Annotations[key]</span><br><span class="line"><span class="keyword">if</span> !found &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Denied(fmt.Sprintf(<span class="string">"missing annotation %s"</span>, key))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> anno != <span class="string">"foo"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> admission.Denied(fmt.Sprintf(<span class="string">"annotation %s did not have value %q"</span>, key, <span class="string">"foo"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> admission.Allowed(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KubeGameValidator implements admission.DecoderInjector.</span></span><br><span class="line"><span class="comment">// A decoder will be automatically injected.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InjectDecoder injects the decoder.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *KubeGameValidator)</span> <span class="title">InjectDecoder</span><span class="params">(d *admission.Decoder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">v.decoder = d</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：因为上述逻辑需要services权限，所以我们在控制器里需要添加如下内容 <code>//+kubebuilder:rbac:groups=&quot;&quot;,resources=services,verbs=get;list;watch;create;update;patch;delete</code> 用于生成 rbac manifests。</p></blockquote><h5 id="Register-Your-Handler"><a href="#Register-Your-Handler" class="headerlink" title="Register Your Handler"></a>Register Your Handler</h5><p>修改 main.go ，注册我们的 webhook handler</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">setupLog.Info(<span class="string">"setting up webhook server"</span>)</span><br><span class="line">hookServer := mgr.GetWebhookServer()</span><br><span class="line"></span><br><span class="line">setupLog.Info(<span class="string">"registering webhooks to the webhook server"</span>)</span><br><span class="line">hookServer.Register(<span class="string">"/mutate-v1-svc"</span>, &amp;webhook.Admission&#123;Handler: &amp;controllers.KubeGameAnnotator&#123;Client: mgr.GetClient()&#125;&#125;)</span><br><span class="line">hookServer.Register(<span class="string">"/validate-v1-svc"</span>, &amp;webhook.Admission&#123;Handler: &amp;controllers.KubeGameValidator&#123;Client: mgr.GetClient()&#125;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>提示： 这里注册的<code>path</code>（例如 validate-v1-sv）路径需要和 validatingwebhook.go 、mutatingwebhook.go 文件里的 CRD validation 匹配，不然 <code>kustomize</code> 生成出来的 webhook yaml 文件不对。</p></blockquote><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><p>make run 会报如下错误，是因为没有证书导致，需要配置证书，可以<a href="http://blazehu.com/2022/08/16/cloudnative/k8s_csr_tls/" target="_blank" rel="noopener">手动签发证书</a>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.646924212701068e+09ERRORsetupproblem running manager&#123;<span class="string">"error"</span>: <span class="string">"open /var/folders/67/375276sx6hv0nln1whwm5syh0000gq/T/k8s-webhook-server/serving-certs/tls.crt: no such file or directory"</span>&#125;</span><br></pre></td></tr></table></figure><p>我本地指定证书目录：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options&#123;</span><br><span class="line">Scheme:                 scheme,</span><br><span class="line">MetricsBindAddress:     metricsAddr,</span><br><span class="line">Port:                   <span class="number">9443</span>,</span><br><span class="line">HealthProbeBindAddress: probeAddr,</span><br><span class="line">LeaderElection:         enableLeaderElection,</span><br><span class="line">LeaderElectionID:       <span class="string">"27e1b0af.blazehu.com"</span>,</span><br><span class="line">CertDir:                <span class="string">"./cert/"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重新启动发现恢复正常<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/run1.png" alt></p><blockquote><p>提示： run <code>controller-gen rbac:roleName=manager-role crd webhook paths=./... output:crd:artifacts:config=config/crd/bases -w</code> to see all available markers, or <code>controller-gen rbac:roleName=manager-role crd webhook paths=./... output:crd:artifacts:config=config/crd/bases -h</code> for usage</p></blockquote><h3 id="7-部署至集群"><a href="#7-部署至集群" class="headerlink" title="7. 部署至集群"></a>7. 部署至集群</h3><h4 id="7-1-部署-cert-manager"><a href="#7-1-部署-cert-manager" class="headerlink" title="7.1 部署 cert manager"></a>7.1 部署 cert manager</h4><p>建议使用 <a href="https://github.com/cert-manager/cert-manager" target="_blank" rel="noopener">certmanager</a> 为 webhook 服务器提供证书。其他解决方案也有效，只要它们将证书放在所需的位置。安装文档点<a href="https://cert-manager.io/docs/installation/" target="_blank" rel="noopener">这里</a><br>通过如下方式注入 <code>caBundle</code> :</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This patch add annotation to admission webhook config and</span></span><br><span class="line"><span class="comment"># the variables $(CERTIFICATE_NAMESPACE) and $(CERTIFICATE_NAME) will be substituted by kustomize.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mutating-webhook-configuration</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">cert-manager.io/inject-ca-from:</span> <span class="string">$(CERTIFICATE_NAMESPACE)/$(CERTIFICATE_NAME)</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ValidatingWebhookConfiguration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">validating-webhook-configuration</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">cert-manager.io/inject-ca-from:</span> <span class="string">$(CERTIFICATE_NAMESPACE)/$(CERTIFICATE_NAME)</span></span><br></pre></td></tr></table></figure><h4 id="7-2-构建镜像"><a href="#7-2-构建镜像" class="headerlink" title="7.2 构建镜像"></a>7.2 构建镜像</h4><ul><li>镜像替换：default/manager_auth_proxy_patch.yaml 文件中的 gcr.io/kubebuilder/kube-rbac-proxy:v0.8.0 （网络慢）</li><li>Dockerfile 去掉 <code>go mod download</code>，直接使用本地 vendor 构建 （网络慢）</li><li>Dockerfile 去掉 <code>COPY api/ api/</code>， 因为没有创建 Resource</li><li>去掉 main.go 文件中配置的证书路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make docker-build IMG=xxxx</span><br><span class="line">make docker-push IMG=xxxx</span><br></pre></td></tr></table></figure><h4 id="7-3-修改模版，然后部署"><a href="#7-3-修改模版，然后部署" class="headerlink" title="7.3 修改模版，然后部署"></a>7.3 修改模版，然后部署</h4><ul><li>修改 config/default/kustomization.yaml ， 将 webhook、certmanager 相关的注释去掉。</li><li>修改 config/crd/kustomization.yaml ，将 webhook、certmanager 相关的注释去掉。</li><li>修改 config/default/kustomization.yaml ， 将 crd 相关的给注释掉。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make deploy IMG=xxxx</span><br></pre></td></tr></table></figure><p>部署成功：<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/deploy.png" alt></p><p>查看控制器日志：<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/logs.png" alt></p><h4 id="7-4-测试"><a href="#7-4-测试" class="headerlink" title="7.4 测试"></a>7.4 测试</h4><p>简单创建一个 service，webhook 会注入一个注解，并进行验证。下图可以看到成功注入。<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/test2.png" alt><br>控制日志：<br><img src="/2022/04/12/cloudnative/kubebuilder_admission_webhooks/test1.png" alt></p><blockquote><p>说明：查看 MutatingWebhookConfiguration 配置可以看到 caBundle 被注入其中了。</p></blockquote><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>总结下 webhook Admission 的优势：</p><ul><li>webhook 可动态扩展 Admission 能力，满足自定义客户的需求。</li><li>不需要重启 API Server，可通过创建 webhook configuration 热加载 webhook admission。</li></ul><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers</a></li><li><a href="https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/</a></li><li><a href="https://book.kubebuilder.io/reference/admission-webhook.html" target="_blank" rel="noopener">https://book.kubebuilder.io/reference/admission-webhook.html</a></li><li><a href="https://github.com/kubernetes-sigs/controller-runtime/tree/master/examples/builtins" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/controller-runtime/tree/master/examples/builtins</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;h3 id=&quot;1-什么是准入控制&quot;&gt;&lt;a href=&quot;#1-什么是准入控制&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是准入控制?&quot;&gt;&lt;/a&gt;1. 什么是准入控制?&lt;/h3&gt;&lt;p&gt;准入控制（Admission Contro</summary>
      
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Kubebuilder Best Practices</title>
    <link href="https://blazehu.github.io/2022/04/10/cloudnative/kubebuilder/"/>
    <id>https://blazehu.github.io/2022/04/10/cloudnative/kubebuilder/</id>
    <published>2022-04-09T16:00:00.000Z</published>
    <updated>2025-03-24T13:20:29.243Z</updated>
    
    <content type="html"><![CDATA[<p>Kubebuilder is a framework for building Kubernetes APIs using custom resource definitions (CRDs).</p><a id="more"></a><blockquote><p>Note: kubebuilder can save us a lot of work and make developing CRDs and adminsion webhooks incredibly easy.</p></blockquote><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># download kubebuilder and install locally.</span></span><br><span class="line">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go env GOOS)/$(go env GOARCH)</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><br><h3 id="Create-a-Project"><a href="#Create-a-Project" class="headerlink" title="Create a Project"></a>Create a Project</h3><hr><p>Create a directory, and then run the init command inside of it to initialize a new project. Follows an example.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ mkdir ~/Project/workspace-go/example</span><br><span class="line">[blazehu@MacBook ~]$ <span class="built_in">cd</span> ~/Project/workspace-go/example</span><br><span class="line">[blazehu@MacBook ~]$ kubebuilder init --domain blazehu.com --owner <span class="string">"blazehu"</span> --repo blazehu.com/example</span><br><span class="line">Writing kustomize manifests <span class="keyword">for</span> you to edit...</span><br><span class="line">Writing scaffold <span class="keyword">for</span> you to edit...</span><br><span class="line">Get controller runtime:</span><br><span class="line">$ go get sigs.k8s.io/controller-runtime@v0.10.0</span><br><span class="line">Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">Next: define a resource with:</span><br><span class="line">$ kubebuilder create api</span><br></pre></td></tr></table></figure><blockquote><p>If your project is initialized within GOPATH, the implicitly called go mod init will interpolate the module path for you. Otherwise –repo=<module path>must be set.</module></p></blockquote><br><h3 id="Adding-a-new-API"><a href="#Adding-a-new-API" class="headerlink" title="Adding a new API"></a>Adding a new API</h3><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubebuilder create api --group cos --version v1 --kind Bucket</span><br><span class="line">Create Resource [y/n]</span><br><span class="line">y</span><br><span class="line">Create Controller [y/n]</span><br><span class="line">y</span><br><span class="line">Writing kustomize manifests <span class="keyword">for</span> you to edit...</span><br><span class="line">Writing scaffold <span class="keyword">for</span> you to edit...</span><br><span class="line">api/v1/bucket_types.go</span><br><span class="line">controllers/bucket_controller.go</span><br><span class="line">Update dependencies:</span><br><span class="line">$ go mod tidy</span><br><span class="line">Running make:</span><br><span class="line">$ make generate</span><br><span class="line">go: creating new go.mod: module tmp</span><br><span class="line">Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.7.0</span><br><span class="line">go get: added sigs.k8s.io/controller-tools v0.7.0</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen object:headerFile=<span class="string">"hack/boilerplate.go.txt"</span> paths=<span class="string">"./..."</span></span><br><span class="line">Next: implement your new API and generate the manifests (e.g. CRDs,CRs) with:</span><br><span class="line">$ make manifests</span><br></pre></td></tr></table></figure><br><h3 id="Designing-an-API"><a href="#Designing-an-API" class="headerlink" title="Designing an API"></a>Designing an API</h3><hr><p><strong>api/v1/bucket_types.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BucketSpec defines the desired state of Bucket</span></span><br><span class="line"><span class="keyword">type</span> BucketSpec <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span></span><br><span class="line"><span class="comment">// Important: Run "make" to regenerate code after modifying this file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo is an example field of Bucket. Edit bucket_types.go to remove/update</span></span><br><span class="line">Name   <span class="keyword">string</span> <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">Region <span class="keyword">string</span> <span class="string">`json:"region,omitempty"`</span></span><br><span class="line">ACL    <span class="keyword">string</span> <span class="string">`json:"acl,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Implementing-a-controller"><a href="#Implementing-a-controller" class="headerlink" title="Implementing a controller"></a>Implementing a controller</h3><hr><p><strong>controllers/cos.go</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/tencentyun/cos-go-sdk-v5"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CosStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">client          *cos.Client</span><br><span class="line">accessKeyId     <span class="keyword">string</span></span><br><span class="line">accessKeySecret <span class="keyword">string</span></span><br><span class="line">bucket          <span class="keyword">string</span></span><br><span class="line">region          <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCosStorage endpoint: https://cloud.tencent.com/document/product/436/6224</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCosStorage</span><span class="params">(region, bucketName <span class="keyword">string</span>)</span> *<span class="title">CosStorage</span></span> &#123;</span><br><span class="line">url, _ := url.Parse(fmt.Sprintf(<span class="string">"https://%s.cos.%s.myqcloud.com"</span>, bucketName, region))</span><br><span class="line">accessKeyId := <span class="string">""</span></span><br><span class="line">accessKeySecret := <span class="string">""</span></span><br><span class="line">b := &amp;cos.BaseURL&#123;BucketURL: url&#125;</span><br><span class="line">client := cos.NewClient(b, &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;cos.AuthorizationTransport&#123;</span><br><span class="line">SecretID:  accessKeyId,</span><br><span class="line">SecretKey: accessKeySecret,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> &amp;CosStorage&#123;</span><br><span class="line">client:          client,</span><br><span class="line">accessKeyId:     accessKeyId,</span><br><span class="line">accessKeySecret: accessKeySecret,</span><br><span class="line">region:          region,</span><br><span class="line">bucket:          bucketName,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosStorage)</span> <span class="title">Put</span><span class="params">(acl <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">opt := &amp;cos.BucketPutOptions&#123;</span><br><span class="line">XCosACL: acl,</span><br><span class="line">&#125;</span><br><span class="line">_, err := c.client.Bucket.Put(context.Background(), opt)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CosStorage)</span> <span class="title">Delete</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">_, err := c.client.Bucket.Delete(context.Background())</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>controllers/bucket_controller.go</strong></p><blockquote><p>tips: Finalizers allow controllers to implement asynchronous pre-delete hooks. Let’s say you create an external resource (such as a storage bucket) for each object of your API type, and you want to delete the associated external resource on object’s deletion from Kubernetes, you can use a finalizer to do that.</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright 2022 blazehu.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"k8s.io/apimachinery/pkg/runtime"</span></span><br><span class="line">ctrl <span class="string">"sigs.k8s.io/controller-runtime"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/client"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"</span></span><br><span class="line"><span class="string">"sigs.k8s.io/controller-runtime/pkg/log"</span></span><br><span class="line"></span><br><span class="line">cosv1 <span class="string">"blazehu.com/example/api/v1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// BucketReconciler reconciles a Bucket object</span></span><br><span class="line"><span class="keyword">type</span> BucketReconciler <span class="keyword">struct</span> &#123;</span><br><span class="line">client.Client</span><br><span class="line">Scheme *runtime.Scheme</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">bucketFinalizerName = <span class="string">"bucket.cos.blazehu.com/finalizer"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=cos.blazehu.com,resources=buckets,verbs=get;list;watch;create;update;patch;delete</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=cos.blazehu.com,resources=buckets/status,verbs=get;update;patch</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=cos.blazehu.com,resources=buckets/finalizers,verbs=update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span></span><br><span class="line"><span class="comment">// move the current state of the cluster closer to the desired state.</span></span><br><span class="line"><span class="comment">// TODO(user): Modify the Reconcile function to compare the state specified by</span></span><br><span class="line"><span class="comment">// the Bucket object against the actual cluster state, and then</span></span><br><span class="line"><span class="comment">// perform operations to make the cluster state reflect the state specified by</span></span><br><span class="line"><span class="comment">// the user.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For more details, check Reconcile and its Result here:</span></span><br><span class="line"><span class="comment">// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.10.0/pkg/reconcile</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">Reconcile</span><span class="params">(ctx context.Context, req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> &#123;</span><br><span class="line">logger := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">bucket := &amp;cosv1.Bucket&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// examine DeletionTimestamp to determine if object is under deletion</span></span><br><span class="line"><span class="keyword">if</span> bucket.ObjectMeta.DeletionTimestamp.IsZero() &#123;</span><br><span class="line"><span class="comment">// The object is not being deleted, so if it does not have our finalizer,</span></span><br><span class="line"><span class="comment">// then lets add the finalizer and update the object. This is equivalent</span></span><br><span class="line"><span class="comment">// registering our finalizer.</span></span><br><span class="line"><span class="keyword">if</span> !controllerutil.ContainsFinalizer(bucket, bucketFinalizerName) &#123;</span><br><span class="line">controllerutil.AddFinalizer(bucket, bucketFinalizerName)</span><br><span class="line"><span class="keyword">if</span> err := r.Update(ctx, bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.updateExternalResources(bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">"unable to create Bucket"</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"create Bucket succeed"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// The object is being deleted</span></span><br><span class="line"><span class="keyword">if</span> controllerutil.ContainsFinalizer(bucket, bucketFinalizerName) &#123;</span><br><span class="line"><span class="comment">// our finalizer is present, so lets handle any external dependency</span></span><br><span class="line"><span class="keyword">if</span> err := r.deleteExternalResources(bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// if fail to delete the external dependency here, return with error</span></span><br><span class="line"><span class="comment">// so that it can be retried</span></span><br><span class="line">logger.Error(err, <span class="string">"unable to delete Bucket"</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove our finalizer from the list and update it.</span></span><br><span class="line">controllerutil.RemoveFinalizer(bucket, bucketFinalizerName)</span><br><span class="line"><span class="keyword">if</span> err := r.Update(ctx, bucket); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">"delete Bucket succeed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop reconciliation as the item is being deleted</span></span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket reconcile logic</span></span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">updateExternalResources</span><span class="params">(bucket *cosv1.Bucket)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cosClient := NewCosStorage(bucket.Spec.Region, bucket.Spec.Name)</span><br><span class="line"><span class="keyword">return</span> cosClient.Put(bucket.Spec.ACL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">deleteExternalResources</span><span class="params">(bucket *cosv1.Bucket)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cosClient := NewCosStorage(bucket.Spec.Region, bucket.Spec.Name)</span><br><span class="line"><span class="keyword">return</span> cosClient.Delete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupWithManager sets up the controller with the Manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketReconciler)</span> <span class="title">SetupWithManager</span><span class="params">(mgr ctrl.Manager)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctrl.NewControllerManagedBy(mgr).</span><br><span class="line">For(&amp;cosv1.Bucket&#123;&#125;).</span><br><span class="line">Complete(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Test-It-Out"><a href="#Test-It-Out" class="headerlink" title="Test It Out"></a>Test It Out</h3><hr><ol><li><p>Install the CRDs into the cluster (<code>make install</code>)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ make install</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen rbac:roleName=manager-role crd webhook paths=<span class="string">"./..."</span> output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/kustomize build config/crd | kubectl apply -f -</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/buckets.cos.blazehu.com created</span><br></pre></td></tr></table></figure></li><li><p>Run your controller (this will run in the foreground, so switch to a new terminal if you want to leave it running) (<code>make run</code>)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ make run</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen rbac:roleName=manager-role crd webhook paths=<span class="string">"./..."</span> output:crd:artifacts:config=config/crd/bases</span><br><span class="line">/Users/huyuhan/Project/workspace-go/example/bin/controller-gen object:headerFile=<span class="string">"hack/boilerplate.go.txt"</span> paths=<span class="string">"./..."</span></span><br><span class="line">go fmt ./...</span><br><span class="line">go vet ./...</span><br><span class="line">go run ./main.go</span><br><span class="line">2022-01-27T22:05:30.207+0800INFOcontroller-runtime.metricsmetrics server is starting to listen&#123;<span class="string">"addr"</span>: <span class="string">":8080"</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.207+0800INFOsetupstarting manager</span><br><span class="line">2022-01-27T22:05:30.208+0800INFOstarting metrics server&#123;<span class="string">"path"</span>: <span class="string">"/metrics"</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.208+0800INFOcontroller.bucketStarting EventSource&#123;<span class="string">"reconciler group"</span>: <span class="string">"cos.blazehu.com"</span>, <span class="string">"reconciler kind"</span>: <span class="string">"Bucket"</span>, <span class="string">"source"</span>: <span class="string">"kind source: /, Kind="</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.208+0800INFOcontroller.bucketStarting Controller&#123;<span class="string">"reconciler group"</span>: <span class="string">"cos.blazehu.com"</span>, <span class="string">"reconciler kind"</span>: <span class="string">"Bucket"</span>&#125;</span><br><span class="line">2022-01-27T22:05:30.309+0800INFOcontroller.bucketStarting workers&#123;<span class="string">"reconciler group"</span>: <span class="string">"cos.blazehu.com"</span>, <span class="string">"reconciler kind"</span>: <span class="string">"Bucket"</span>, <span class="string">"worker count"</span>: 1&#125;</span><br></pre></td></tr></table></figure></li><li><p>Create Custom Resources (create bucket.cos.blazehu.com/bucket-sample) (<code>cos_v1_bucket.yaml</code>)</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">cos.blazehu.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Bucket</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bucket-sample</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blazehu</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># TODO(user): Add fields here</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-1251762279</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-shanghai</span></span><br><span class="line">  <span class="attr">acl:</span> <span class="string">private</span></span><br></pre></td></tr></table></figure><p><code>kubectl apply -f cos_v1_bucket.yaml</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl apply -f cos_v1_bucket.yaml</span><br><span class="line">bucket.cos.blazehu.com/bucket-sample created</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get bucket.cos.blazehu.com  -n blazehu</span><br><span class="line">NAME            AGE</span><br><span class="line">bucket-sample   17s</span><br></pre></td></tr></table></figure><p>Tencent cloud console view found that the bucket was created normally.<br><img src="/2022/04/10/cloudnative/kubebuilder/crd_example1.png" alt></p></li><li><p>Delete Instances of Custom Resources (delete bucket.cos.blazehu.com/bucket-sample)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl delete -f cos_v1_bucket.yaml</span><br><span class="line">bucket.cos.blazehu.com <span class="string">"bucket-sample"</span> deleted</span><br></pre></td></tr></table></figure><p>Tencent Cloud Console view found that the bucket has been deleted.</p><br></li></ol><h3 id="Run-It-On-the-Cluster"><a href="#Run-It-On-the-Cluster" class="headerlink" title="Run It On the Cluster"></a>Run It On the Cluster</h3><hr><p>Deploy the controller to the cluster with image specified by IMG</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make docker-build docker-push IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br><span class="line">make deploy IMG=&lt;some-registry&gt;/&lt;project-name&gt;:tag</span><br></pre></td></tr></table></figure><br><h3 id="Uninstall-CRDs"><a href="#Uninstall-CRDs" class="headerlink" title="Uninstall CRDs"></a>Uninstall CRDs</h3><hr><p>To delete your CRDs from the cluster, run <code>make uninstall</code><br><br></p><h3 id="Undeploy-controller"><a href="#Undeploy-controller" class="headerlink" title="Undeploy controller"></a>Undeploy controller</h3><hr><p>UnDeploy the controller to the cluster, run <code>make undeploy</code><br><br></p><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubebuilder</a></li><li><a href="https://book.kubebuilder.io/introduction.html" target="_blank" rel="noopener">https://book.kubebuilder.io/introduction.html</a></li><li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/operator/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kubebuilder is a framework for building Kubernetes APIs using custom resource definitions (CRDs).&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="kubebuilder" scheme="https://blazehu.github.io/tags/kubebuilder/"/>
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>FluxCD GitOps Toolkit components</title>
    <link href="https://blazehu.github.io/2022/04/01/cloudnative/fluxcd/"/>
    <id>https://blazehu.github.io/2022/04/01/cloudnative/fluxcd/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2025-03-24T13:21:22.940Z</updated>
    
    <content type="html"><![CDATA[<p>Flux is a tool for keeping Kubernetes clusters in sync with sources of configuration (like Git repositories), and automating updates to configuration when there is new code to deploy.</p><a id="more"></a><br><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><hr><h4 id="Install-CLI"><a href="#Install-CLI" class="headerlink" title="Install CLI"></a>Install CLI</h4><p><a href="https://fluxcd.io/docs/installation/#install-the-flux-cli" target="_blank" rel="noopener">FluxCLI安装文档</a></p><h4 id="Check-your-Kubernetes-cluster"><a href="#Check-your-Kubernetes-cluster" class="headerlink" title="Check your Kubernetes cluster"></a>Check your Kubernetes cluster</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flux check --pre</span><br></pre></td></tr></table></figure><h4 id="Dev-install"><a href="#Dev-install" class="headerlink" title="Dev install"></a>Dev install</h4><p>For testing purposes you can install Flux without storing its manifests in a Git repository:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flux install</span><br></pre></td></tr></table></figure><p>Or using kubectl:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/fluxcd/flux2/releases/latest/download/install.yaml</span><br></pre></td></tr></table></figure><br><h3 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h3><hr><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── apps                         <span class="comment"># 应用相关信息</span></span><br><span class="line">│   └── exmaple</span><br><span class="line">├── clusters                     <span class="comment"># 集群相关配置</span></span><br><span class="line">│   ├── gitrepo.yaml             <span class="comment"># gitrepository    (CR)</span></span><br><span class="line">│   ├── terraform.yaml           <span class="comment"># terraform        (CR)</span></span><br><span class="line">│   ├── helm.yaml                <span class="comment"># helmrelease      (CR)</span></span><br><span class="line">│   └── notification.yaml        <span class="comment"># alert &amp; provider (CR)</span></span><br><span class="line">└── infrastructure               <span class="comment"># iac 相关配置（主要是 terraform hcl 配置）              </span></span><br><span class="line">    ├── main.tf</span><br><span class="line">    ├── provider.tf</span><br><span class="line">    └── variable.tf</span><br></pre></td></tr></table></figure><h4 id="Source-Controller"><a href="#Source-Controller" class="headerlink" title="Source Controller"></a>Source Controller</h4><p>The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller.<br><img src="https://fluxcd.io/img/source-controller.png" alt="enter image description here"></p><p><code>gitrepo.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">source.toolkit.fluxcd.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">secretRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https-credentials</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/blazehu/gitops_example.git</span></span><br><span class="line">  <span class="attr">ref:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">https-credentials</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>secret 主要是做 git 仓库的认证</li><li>interval 是拉取 git 提交的间隔，每隔一分钟会查看 git 仓库是否会有新的提交</li></ul></blockquote><h4 id="TF-Controller"><a href="#TF-Controller" class="headerlink" title="TF Controller"></a>TF Controller</h4><p>TF-controller is an experimental controller for <a href="https://fluxcd.io/" target="_blank" rel="noopener">Flux</a> to reconcile Terraform resources in the GitOps way. With the power of Flux together with Terraform, TF-controller allows you to GitOps-ify infrastructure, and application resources, in the Kubernetes and Terraform universe, at your own pace.</p><p><code>tf config</code></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">infrastructure</span><br><span class="line">├── main.tf</span><br><span class="line">├── provider.tf</span><br><span class="line">└── <span class="keyword">variable</span>.tf</span><br></pre></td></tr></table></figure><p><code>provider.tf</code></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">terraform &#123;</span><br><span class="line">  required_providers &#123;</span><br><span class="line">    tencentcloud = &#123;</span><br><span class="line">      <span class="keyword">source</span>  = <span class="string">"tencentcloudstack/tencentcloud"</span></span><br><span class="line">      version = <span class="string">"1.60.5"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provider <span class="string">"tencentcloud"</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.tf</code></p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">resource <span class="string">"tencentcloud_clb_instance"</span> <span class="string">"example"</span> &#123;</span><br><span class="line">  target_region_info_region    = var.region</span><br><span class="line">  target_region_info_vpc_id    = var.vpc</span><br><span class="line">  vpc_id                       = var.vpc</span><br><span class="line">  clb_name                     = var.clb_name</span><br><span class="line">  network_type                 = <span class="string">"OPEN"</span></span><br><span class="line">  project_id                   = <span class="number">0</span></span><br><span class="line">  security_groups              = [tencentcloud_security_group.sg1.id]</span><br><span class="line">  internet_bandwidth_max_out   = <span class="string">"10"</span></span><br><span class="line">  internet_charge_type         = <span class="string">"TRAFFIC_POSTPAID_BY_HOUR"</span></span><br><span class="line">  load_balancer_pass_to_target = <span class="string">"true"</span></span><br><span class="line"></span><br><span class="line">  lifecycle &#123;</span><br><span class="line">    ignore_changes = [</span><br><span class="line">      tags,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"tencentcloud_security_group"</span> <span class="string">"sg1"</span> &#123;</span><br><span class="line">  description = <span class="string">"默认安全组"</span></span><br><span class="line">  name        = <span class="string">"example-sg1"</span></span><br><span class="line">  project_id  = <span class="string">"0"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">"tencentcloud_security_group_lite_rule"</span> <span class="string">"sglr1"</span> &#123;</span><br><span class="line">  egress            = [<span class="string">"ACCEPT#0.0.0.0/0#ALL#ALL"</span>]</span><br><span class="line">  ingress           = [<span class="string">"ACCEPT#0.0.0.0/0#80,443#TCP"</span>, <span class="string">"DROP#0.0.0.0/0#ALL#ALL"</span>]</span><br><span class="line">  security_group_id = tencentcloud_security_group.sg1.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output <span class="string">"clb_vip"</span> &#123;</span><br><span class="line">  value = tencentcloud_clb_instance.example.clb_vips[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>terraform.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">infra.contrib.fluxcd.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Terraform</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tf-example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">approvePlan:</span> <span class="string">"auto"</span></span><br><span class="line">  <span class="attr">destroyResourcesOnDeletion:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./infrastructure</span></span><br><span class="line">  <span class="attr">sourceRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line">  <span class="attr">varsFrom:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tf-secret</span></span><br><span class="line">  <span class="attr">writeOutputsToSecret:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tf-output</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tf-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">secret_id:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">secret_key:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>writeOutputsToSecret 输出相关信息至 secret 便于其他资源引用</li><li>varsFrom 敏感信息通过该方式在 terraform 中引用</li></ul></blockquote><h4 id="Helm-Controller"><a href="#Helm-Controller" class="headerlink" title="Helm Controller"></a>Helm Controller</h4><p>The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests.<br><img src="https://fluxcd.io/img/helm-controller.png" alt="enter image description here"></p><p><code>helm.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">helm.toolkit.fluxcd.io/v2beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HelmRelease</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">targetNamespace:</span> <span class="string">blazehu</span></span><br><span class="line">  <span class="attr">releaseName:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">chart:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">chart:</span> <span class="string">apps/exmaple</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">"&gt;=0.0.1"</span></span><br><span class="line">      <span class="attr">valuesFile:</span> <span class="string">./apps/exmaple/values.yaml</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">1m</span></span><br><span class="line">      <span class="attr">sourceRef:</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line">  <span class="attr">upgrade:</span></span><br><span class="line">    <span class="attr">remediation:</span></span><br><span class="line">      <span class="attr">remediateLastFailure:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">valuesFrom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">tf-output</span></span><br><span class="line">      <span class="attr">valuesKey:</span> <span class="string">clb_vip</span></span><br><span class="line">      <span class="attr">targetPath:</span> <span class="string">clb.serviceVIP</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>version: a SemVer range (i.e. &gt;=4.0.0 &lt;5.0.0) to automatically upgrade your releases when a new chart version is available in the release’s referenced HelmRepository.</li><li>charts: The name or path the Helm chart is available at in the SourceRef.</li><li>valuesFile: Alternative list of values files to use as the chart values.</li><li>releaseName: Defaults to a composition of ‘[TargetNamespace-]Name’.</li><li>targetNamespace: TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease.</li></ul></blockquote><h4 id="Notification-Controller"><a href="#Notification-Controller" class="headerlink" title="Notification Controller"></a>Notification Controller</h4><p>The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events.<br><img src="https://fluxcd.io/img/notification-controller.png" alt="enter image description here"></p><p><code>notification.yaml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">notification.toolkit.fluxcd.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Alert</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-alert</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">providerRef:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">generic</span> </span><br><span class="line">  <span class="attr">eventSeverity:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">eventSources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">gitrepo</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">HelmRelease</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">blazehu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">notification.toolkit.fluxcd.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Provider</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">generic</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">generic</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK</span></span><br></pre></td></tr></table></figure><br><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://fluxcd.io/docs/components/" target="_blank" rel="noopener">https://fluxcd.io/docs/components/</a></li><li><a href="https://weaveworks.github.io/tf-controller/" target="_blank" rel="noopener">https://weaveworks.github.io/tf-controller/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Flux is a tool for keeping Kubernetes clusters in sync with sources of configuration (like Git repositories), and automating updates to configuration when there is new code to deploy.&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
    <category term="fluxcd" scheme="https://blazehu.github.io/tags/fluxcd/"/>
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
  </entry>
  
  <entry>
    <title>Terraform Controller Practices</title>
    <link href="https://blazehu.github.io/2022/03/11/cloudnative/terraform-controller/"/>
    <id>https://blazehu.github.io/2022/03/11/cloudnative/terraform-controller/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2025-03-24T13:24:49.204Z</updated>
    
    <content type="html"><![CDATA[<p>Terraform Controller is a Kubernetes Controller for Terraform.</p><a id="more"></a><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><hr><p><img src="/2022/03/11/cloudnative/terraform-controller/t1.png" alt></p><h3 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h3><hr><p>Github: <a href="https://github.com/oam-dev/terraform-controller" target="_blank" rel="noopener">https://github.com/oam-dev/terraform-controller</a></p><h3 id="Standalone-Terraform-Controller"><a href="#Standalone-Terraform-Controller" class="headerlink" title="Standalone Terraform Controller"></a>Standalone Terraform Controller</h3><hr><h4 id="Install-Kubernetes-Terraform-Controller-Chart"><a href="#Install-Kubernetes-Terraform-Controller-Chart" class="headerlink" title="Install Kubernetes Terraform Controller Chart"></a>Install Kubernetes Terraform Controller Chart</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm repo add kubevela-addons https://charts.kubevela.net/addons</span><br><span class="line"><span class="string">"kubevela-addons"</span> has been added to your repositories</span><br><span class="line"></span><br><span class="line">$ helm upgrade --install terraform-controller -n terraform --create-namespace kubevela-addons/terraform-controller</span><br><span class="line">Release <span class="string">"terraform-controller"</span> does not exist. Installing it now.</span><br><span class="line">NAME: terraform-controller</span><br><span class="line">LAST DEPLOYED: Fri Mar 11 15:08:57 2022</span><br><span class="line">NAMESPACE: terraform</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl get all -n terraform</span><br><span class="line">NAME                                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/terraform-controller-557d4b8869-nv28x   1/1     Running   0          22s</span><br><span class="line"></span><br><span class="line">NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/terraform-controller   1/1     1            1           22s</span><br><span class="line"></span><br><span class="line">NAME                                              DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/terraform-controller-557d4b8869   1         1         1       22s</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get crd | grep terraform</span><br><span class="line">configurations.terraform.core.oam.dev            2022-03-11T07:08:27Z</span><br><span class="line">providers.terraform.core.oam.dev                 2022-03-11T07:08:27Z</span><br></pre></td></tr></table></figure><h3 id="Authenticate-Cloud-Provider-and-Create-a-Cloud-Resource"><a href="#Authenticate-Cloud-Provider-and-Create-a-Cloud-Resource" class="headerlink" title="Authenticate Cloud Provider and Create a Cloud Resource"></a>Authenticate Cloud Provider and Create a Cloud Resource</h3><hr><p>下面验证腾讯云的 cos bucket 创建和销毁，准备以下文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── provider.yaml                      <span class="comment"># provider 描述文件</span></span><br><span class="line">├── configuration_hcl_example.yaml     <span class="comment"># cos bucket 描述文件</span></span><br><span class="line">└── tencent-credentials.conf           <span class="comment"># 腾讯云相关 secret 信息（secretid &amp; secretkey）</span></span><br></pre></td></tr></table></figure><p>provider.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">terraform.core.oam.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Provider</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tencent</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">tencent</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-nanjing</span></span><br><span class="line">  <span class="attr">credentials:</span></span><br><span class="line">    <span class="attr">source:</span> <span class="string">Secret</span></span><br><span class="line">    <span class="attr">secretRef:</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">vela-system</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">tencent-account-creds</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">credentials</span></span><br></pre></td></tr></table></figure><p>configuration_hcl_example.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">terraform.core.oam.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Configuration</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tencent-cos-hcl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hcl:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">terraform</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">required_providers</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">tencentcloud</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">source</span>  <span class="string">=</span> <span class="string">"tencentcloudstack/tencentcloud"</span></span><br><span class="line">          <span class="string">version</span> <span class="string">=</span> <span class="string">"1.60.5"</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">resource</span> <span class="string">"tencentcloud_cos_bucket"</span> <span class="string">"mycos"</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">bucket</span> <span class="string">=</span> <span class="string">"blazehu-test-125834470x"</span></span><br><span class="line">      <span class="string">acl</span>    <span class="string">=</span> <span class="string">"private"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="attr">providerRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tencent</span></span><br></pre></td></tr></table></figure><p>tencent-credentials.conf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secretID: </span><br><span class="line">secretKey:</span><br></pre></td></tr></table></figure><h4 id="create-secret"><a href="#create-secret" class="headerlink" title="create secret"></a>create secret</h4><p>通过 tencent-credentials.conf 文件创建 secret ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic tencent-account-creds -n vela-system --from-file=credentials=tencent-credentials.conf</span><br></pre></td></tr></table></figure><h4 id="create-provider"><a href="#create-provider" class="headerlink" title="create provider"></a>create provider</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl apply -f provider.yaml</span><br><span class="line">provider.terraform.core.oam.dev/tencent created</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get provider.terraform.core.oam.dev</span><br><span class="line">NAME      STATE   AGE</span><br><span class="line">tencent   ready   3m41s</span><br></pre></td></tr></table></figure><h4 id="create-configuration"><a href="#create-configuration" class="headerlink" title="create configuration"></a>create configuration</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ kubectl apply -f configuration_hcl_example.yaml</span><br><span class="line">configuration.terraform.core.oam.dev/tencent-cos-hcl created</span><br><span class="line">[blazehu@MacBook ~]$ kubectl get configuration.terraform.core.oam.dev</span><br><span class="line">NAME              STATE                     AGE</span><br><span class="line">tencent-cos-hcl   ProvisioningAndChecking   13s</span><br></pre></td></tr></table></figure><p>terraform-controller 会拉起 Job 跑 terraform 命令来创建，源码：<br><img src="/2022/03/11/cloudnative/terraform-controller/scr1.png" alt></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ k get job</span><br><span class="line">NAME                    COMPLETIONS   DURATION   AGE</span><br><span class="line">tencent-cos-hcl-apply   0/1           3s         3s</span><br><span class="line">[blazehu@MacBook ~]$ k get po</span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">tencent-cos-hcl-apply-fhpsg   1/1     Running   0          7s</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">[blazehu@MacBook ~]$ k get configuration.terraform.core.oam.dev</span><br><span class="line">NAME              STATE       AGE</span><br><span class="line">tencent-cos-hcl   Available   4m16s</span><br></pre></td></tr></table></figure><p>腾讯云控制台可以观测到 cos bucket 成功创建。</p><blockquote><p>tip: 执行成功后 state 相关内容写入了 secret 里。</p></blockquote><h4 id="delete-configuration"><a href="#delete-configuration" class="headerlink" title="delete configuration"></a>delete configuration</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ k delete -f configuration_hcl_example.yaml</span><br><span class="line">configuration.terraform.core.oam.dev <span class="string">"tencent-cos-hcl"</span> deleted</span><br><span class="line"></span><br><span class="line">[blazehu@MacBook ~]$ k get job</span><br><span class="line">NAME                      COMPLETIONS   DURATION   AGE</span><br><span class="line">tencent-cos-hcl-apply     1/1           2m55s      5m11s</span><br><span class="line">tencent-cos-hcl-destroy   0/1           7s         7s</span><br><span class="line">[blazehu@MacBook ~]$ k get pod</span><br><span class="line">NAME                            READY   STATUS      RESTARTS   AGE</span><br><span class="line">tencent-cos-hcl-apply-qnfnx     0/1     Completed   3          3m30s</span><br><span class="line">tencent-cos-hcl-destroy-vt5b2   0/1     Completed   0          10s</span><br></pre></td></tr></table></figure><p>腾讯云控制台可以观测到 cos bucket 已经被回收处理。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>因为每一个新的操作都是启动一个新的 Pod 去执行 <code>terraform init...</code>，由于网络问题， Initializing provider plugins 经常失败，于是这里使用 cache ，构建一个新的 job 镜像然后更新 release。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> oamdev/docker-terraform:<span class="number">1.1</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"blazehu"</span></span></span><br><span class="line"><span class="keyword">ENV</span> TF_PLUGIN_CACHE_DIR /.terraform.d/plugin-cache</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> registry.terraform.io /.terraform.d/plugin-cache/registry.terraform.io</span></span><br></pre></td></tr></table></figure><p>upgrade release</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[blazehu@MacBook ~]$ helm upgrade --install terraform-controller -n terraform --create-namespace kubevela-addons/terraform-controller --<span class="built_in">set</span> terraformImage=docker-terraform:2.0</span><br></pre></td></tr></table></figure><blockquote><p>tips: 也可以是用 sidecar 注入 pod 来使用 cache （<a href="https://openkruise.io/zh/docs/user-manuals/sidecarset/" target="_blank" rel="noopener">openkruise</a>）</p></blockquote><h3 id="Reference-documentation"><a href="#Reference-documentation" class="headerlink" title="Reference documentation"></a>Reference documentation</h3><ul><li><a href="https://developer.aliyun.com/article/724349" target="_blank" rel="noopener">https://developer.aliyun.com/article/724349</a></li><li><a href="https://github.com/oam-dev/terraform-controller/blob/master/getting-started.md" target="_blank" rel="noopener">https://github.com/oam-dev/terraform-controller/blob/master/getting-started.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Terraform Controller is a Kubernetes Controller for Terraform.&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
    <category term="iac" scheme="https://blazehu.github.io/tags/iac/"/>
    
  </entry>
  
</feed>
