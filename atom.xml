<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小千世界</title>
  
  
  <link href="https://blazehu.github.io/atom.xml" rel="self"/>
  
  <link href="https://blazehu.github.io/"/>
  <updated>2025-09-10T15:45:00.750Z</updated>
  <id>https://blazehu.github.io/</id>
  
  <author>
    <name>BlazeHu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ArgoCD 使用 GitLab 和 Dex 实现单点登录</title>
    <link href="https://blazehu.github.io/2025/09/03/cloudnative/argocd_sso_gitlab/"/>
    <id>https://blazehu.github.io/2025/09/03/cloudnative/argocd_sso_gitlab/</id>
    <published>2025-09-02T16:00:00.000Z</published>
    <updated>2025-09-10T15:45:00.750Z</updated>
    
    <content type="html"><![CDATA[<p>ArgoCD 初始仅提供 admin 账号，用于首次部署和配置；为安全与协作，后续应启用本地用户或接入 SSO，避免长期使用超级管理员账号。</p><a id="more"></a><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>ArgoCD 以“开箱即用”的方式内置了 <a href="https://dexidp.io/docs/" target="_blank" rel="noopener">Dex</a>（一个轻量级 OIDC 代理）。Dex 的职责只有一个：把企业里各式各样的身份源（SAML、LDAP、GitHub、GitLab …）统一翻译成 ArgoCD 能消费的 OIDC 令牌，从而把 <a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sso" target="_blank" rel="noopener">ArgoCD SSO</a> 落地成两行配置。下文以 GitLab OAuth2 为样本，演示如何修改 <code>argocd-cm</code> ConfigMap 完成连接器编排，并给出可直接粘贴的 <a href="https://dexidp.io/docs/connectors/gitlab/" target="_blank" rel="noopener">GitLab-Dex</a> 最小 YAML 模板。</p><h3 id="2-整体流程"><a href="#2-整体流程" class="headerlink" title="2. 整体流程"></a>2. 整体流程</h3><ol><li>GitLab: 注册 OAuth2 Application → 获取 Client ID/Secret</li><li>ArgoCD: 修改 argocd-cm 注入 dex gitlab 连接器</li><li>ArgoCD: 修改 argocd-rbac-cm 把 GitLab Group 映射成 ArgoCD 角色</li></ol><h3 id="3-GitLab-配置"><a href="#3-GitLab-配置" class="headerlink" title="3. GitLab 配置"></a>3. GitLab 配置</h3><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_gitlab_sso.jpg" alt="argocd_gitlab_sso"></p><ol><li>打开 Admin Area → Applications → New Application</li><li>填写关键点<ul><li>Name：argocd-dex</li><li>Redirect URI：<a href="https://argocd.blazehu.com/api/dex/callback" target="_blank" rel="noopener">https://argocd.blazehu.com/api/dex/callback</a></li><li>Scopes：勾选 read_user openid profile email</li></ul></li><li>保存后记录 ClientID 和 ClientSecret</li></ol><h3 id="4-ArgoCD-接入-Dex（GitLab-连接器）"><a href="#4-ArgoCD-接入-Dex（GitLab-连接器）" class="headerlink" title="4. ArgoCD 接入 Dex（GitLab 连接器）"></a>4. ArgoCD 接入 Dex（GitLab 连接器）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl edit cm argocd-cm -n argocd</span><br></pre></td></tr></table></figure><p>新增以下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://argocd.blazehu.com</span>          <span class="comment"># 对外访问地址</span></span><br><span class="line">  <span class="attr">dex.config:</span> <span class="string">|</span></span><br><span class="line">    <span class="attr">connectors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">gitlab</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">gitlab</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">GitLab</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">baseURL:</span> <span class="string">https://gitlab.example.com</span>   <span class="comment"># 自建 GitLab 填域名</span></span><br><span class="line">        <span class="attr">clientID:</span> <span class="string">XXXX...</span></span><br><span class="line">        <span class="attr">clientSecret:</span> <span class="string">XXXX...</span></span><br><span class="line">        <span class="attr">redirectURI:</span> <span class="string">https://argocd.blazehu.com/api/dex/callback</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://argocd.blazehu.com</span></span><br><span class="line">        <span class="attr">users.anonymous.enabled:</span> <span class="string">"false"</span></span><br></pre></td></tr></table></figure><blockquote><p>如果登录提示：Failed to query provider “<a href="https://argocd.blazehu.com/api/dex" target="_blank" rel="noopener">https://argocd.blazehu.com/api/dex</a> “: Get “<a href="https://argocd-dex-server:5556/api/dex/.well-known/openid-configuration&quot;" target="_blank" rel="noopener">https://argocd-dex-server:5556/api/dex/.well-known/openid-configuration&quot;</a>: http: server gave HTTP response to HTTPS client。这是由于协议对不上，首先检查证书是否合法，另外检查 <code>argocd-cmd-params-cm</code> 配置文件的 dex server 相关参数。</p></blockquote><h3 id="5-RBAC：GitLab-Group-映射成角色"><a href="#5-RBAC：GitLab-Group-映射成角色" class="headerlink" title="5. RBAC：GitLab Group 映射成角色"></a>5. RBAC：GitLab Group 映射成角色</h3><p>编辑 argocd-rbac-cm：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">policy.default:</span> <span class="string">role:readonly</span></span><br><span class="line">  <span class="attr">policy.csv:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">p,</span> <span class="string">role:devops,</span> <span class="string">applications,</span> <span class="string">*,</span> <span class="string">*/*,</span> <span class="string">allow</span></span><br><span class="line">    <span class="string">p,</span> <span class="string">role:devops,</span> <span class="string">clusters,</span> <span class="string">get,</span> <span class="string">*,</span> <span class="string">allow</span></span><br><span class="line">    <span class="string">g,</span> <span class="string">devops,</span> <span class="string">role:devops</span></span><br></pre></td></tr></table></figure><h3 id="6-重启与验证"><a href="#6-重启与验证" class="headerlink" title="6. 重启与验证"></a>6. 重启与验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout restart deployment/argocd-dex-server -n argocd</span><br></pre></td></tr></table></figure><p>重启后点击快速登录：<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_gitlab_sso_login.png" alt="argocd_gitlab_sso_login"></p><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sso" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sso</a></li><li><a href="https://dexidp.io/docs/connectors/gitlab/" target="_blank" rel="noopener">https://dexidp.io/docs/connectors/gitlab/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ArgoCD 初始仅提供 admin 账号，用于首次部署和配置；为安全与协作，后续应启用本地用户或接入 SSO，避免长期使用超级管理员账号。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="argocd" scheme="https://blazehu.github.io/tags/argocd/"/>
    
    <category term="dex" scheme="https://blazehu.github.io/tags/dex/"/>
    
    <category term="gitlab" scheme="https://blazehu.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾流水线中的 Kubernetes 调度优化</title>
    <link href="https://blazehu.github.io/2025/07/30/devops/landun_dispatch_scheduler/"/>
    <id>https://blazehu.github.io/2025/07/30/devops/landun_dispatch_scheduler/</id>
    <published>2025-07-29T16:00:00.000Z</published>
    <updated>2025-07-30T04:20:33.463Z</updated>
    
    <content type="html"><![CDATA[<p>在大量使用蓝盾「Docker公共构建机」来跑构建任务后，我们发现拉起的构建 Pod 通过 hostPath 挂载工作目录做缓存，当同一流水线任务重复执行时能够加速，本文介绍蓝盾调度器如何进行调度到有缓存的节点。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>在前文<a href="http://localhost:4000/2025/07/17/devops/landun_dind_cleaner/#2-%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">蓝盾「Docker公共构建机」缓存清理</a>中我们通过分析源码，知道拉起的构建 Pod 通过 hostPath 挂载工作目录做缓存。我们接下来进一步分析创建 Pod 的流程。</p><h3 id="2-部署配置"><a href="#2-部署配置" class="headerlink" title="2. 部署配置"></a>2. 部署配置</h3><p><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/dispatch-k8s-manager/resources/config.yaml" target="_blank" rel="noopener">dispatch-k8s-manager/resources/config.yaml</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dispatch:</span></span><br><span class="line">  <span class="comment"># 调度需要使用到的label，确定构建机唯一性</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">bkci.dispatch.kubenetes/core</span></span><br><span class="line">  <span class="comment"># 通过k8s watch来观察构建机状态</span></span><br><span class="line">  <span class="attr">watch:</span></span><br><span class="line">    <span class="attr">task:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">bkci.dispatch.kubenetes/watch-task</span></span><br><span class="line">  <span class="attr">builder:</span></span><br><span class="line">    <span class="comment"># 将构建机调度到指定标签节点的配置，不填写则在集群内都可以调度，优先级小于专机和特殊机器</span></span><br><span class="line">    <span class="attr">nodeSelector:</span></span><br><span class="line">      <span class="attr">label:</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">    <span class="comment"># 构建机曾经调度过的节点名称列表</span></span><br><span class="line">    <span class="attr">nodesAnnotation:</span> <span class="string">bkci.dispatch.kubenetes/builder-history-nodes</span></span><br><span class="line">    <span class="comment"># 容器历史资源使用相关</span></span><br><span class="line">    <span class="attr">realResource:</span></span><br><span class="line">      <span class="comment"># 监控构建机容器资源使用的 prometheus api地址， 字段为空则不开启realResource优化</span></span><br><span class="line">      <span class="comment"># 注：集群内为 集群内为 &lt;service&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</span></span><br><span class="line">      <span class="attr">prometheusUrl:</span> </span><br><span class="line">      <span class="attr">realResourceAnnotation:</span> <span class="string">bkci.dispatch.kubenetes/builder-real-resources</span></span><br><span class="line">  <span class="comment"># 一些具有特定属性的机器，例如独特的网络策略</span></span><br><span class="line">  <span class="attr">specialMachine:</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">bkci.dispatch.kubenetes/special-builder</span></span><br><span class="line">  <span class="comment"># 只给特定用户使用的专机</span></span><br><span class="line">  <span class="attr">privateMachine:</span></span><br><span class="line">    <span class="attr">label:</span> <span class="string">bkci.dispatch.kubenetes/private-builder</span></span><br></pre></td></tr></table></figure><p>通过 <code>dispatch-k8s-manager</code> 模块的配置文件，我们发现可以通过 <code>nodeSelector</code>、 <code>nodesAnnotation</code> 、<code>realResource</code> 等配置来设置调度策略。</p><h3 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h3><h4 id="3-1-亲和性和污点容忍"><a href="#3-1-亲和性和污点容忍" class="headerlink" title="3.1 亲和性和污点容忍"></a>3.1 亲和性和污点容忍</h4><p><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/dispatch-k8s-manager/pkg/apiserver/service/builder_start.go" target="_blank" rel="noopener">dispatch-k8s-manager/pkg/apiserver/service/builder_start.go</a></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBuilder</span><span class="params">(builder *Builder)</span> <span class="params">(taskId <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">volumes, volumeMounts := getBuilderVolumeAndMount(builder.Name, builder.NFSs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replicas <span class="keyword">int32</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tolers, nodeMatches := buildDedicatedBuilder(builder)</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  annotations, err := getBuilderAnnotations(builder.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> task.DoCreateBuilder(</span><br><span class="line">taskId,</span><br><span class="line">&amp;kubeclient.Deployment&#123;</span><br><span class="line">Name:        builder.Name,</span><br><span class="line">Labels:      labels,</span><br><span class="line">MatchLabels: matchlabels,</span><br><span class="line">Replicas:    &amp;replicas,</span><br><span class="line">Pod: kubeclient.Pod&#123;</span><br><span class="line">Labels:      labels,</span><br><span class="line">Annotations: annotations,</span><br><span class="line">Volumes:     volumes,</span><br><span class="line">Containers: []kubeclient.Container&#123;</span><br><span class="line">&#123;</span><br><span class="line">Image:        builder.Image,</span><br><span class="line">Resources:    *resources,</span><br><span class="line">Env:          getEnvs(builder.Env),</span><br><span class="line">Command:      builder.Command,</span><br><span class="line">VolumeMounts: volumeMounts,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">NodeMatches:     nodeMatches,</span><br><span class="line">Tolerations:     tolers,</span><br><span class="line">PullImageSecret: pullImageSecret,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> taskId, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// buildDedicatedBuilder 获取污点和节点亲和度配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildDedicatedBuilder</span><span class="params">(builder *Builder)</span> <span class="params">([]corev1.Toleration, []kubeclient.NodeMatch)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 优先读取专机配置</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 读取具有特殊配置的机器</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果配置中配置了节点选择器则使用节点选择器</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBuilderAnnotations 获取构建机注释配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBuilderAnnotations</span><span class="params">(builderName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 获取节点记录，用来把构建机分配到已有的节点</span></span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 获取RealResource记录</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/dispatch-k8s-manager/pkg/kubeclient/deployment.go" target="_blank" rel="noopener">dispatch-k8s-manager/pkg/kubeclient/deployment.go</a></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateDeployment</span><span class="params">(dep *Deployment)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将 NodeMatches 转为 nodeAffinity</span></span><br><span class="line"><span class="keyword">var</span> affinity *corev1.Affinity</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dep.Pod.NodeMatches) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> matches []corev1.NodeSelectorRequirement</span><br><span class="line"><span class="keyword">for</span> _, mat := <span class="keyword">range</span> dep.Pod.NodeMatches &#123;</span><br><span class="line">matches = <span class="built_in">append</span>(matches, corev1.NodeSelectorRequirement&#123;</span><br><span class="line">Key:      mat.Key,</span><br><span class="line">Operator: mat.Operator,</span><br><span class="line">Values:   mat.Values,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">affinity = &amp;corev1.Affinity&#123;</span><br><span class="line">NodeAffinity: &amp;corev1.NodeAffinity&#123;</span><br><span class="line">RequiredDuringSchedulingIgnoredDuringExecution: &amp;corev1.NodeSelector&#123;</span><br><span class="line">NodeSelectorTerms: []corev1.NodeSelectorTerm&#123;</span><br><span class="line">&#123;</span><br><span class="line">MatchExpressions: matches,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CreateBuilder 里，调度相关的两个核心参数 tolers 和 nodeMatches 都是通过 buildDedicatedBuilder(builder) 返回的，这两个参数会一起传递给 kubeclient 层，在 kubeclient 的 CreateDeployment 方法中：</p><ul><li>NodeMatches 会被转换为 affinity.nodeAffinity，用于节点亲和调度。</li><li>Tolerations 会直接下发到 Pod 的 spec.tolerations 字段，用于污点容忍。</li></ul><h4 id="3-2-历史节点调度"><a href="#3-2-历史节点调度" class="headerlink" title="3.2 历史节点调度"></a>3.2 历史节点调度</h4><p>蓝盾源码里我们找到了有关亲和性以及污点容忍的实现，但是有关历史节点调度的实现只有通过 getBuilderAnnotations 给 Pod 设置注解。至于如何通过注解影响调度在蓝盾源码里并没有找到相关内容。我们进一步分析发现，历史节点调度需要通过<a href="https://github.com/TencentBlueKing/ci-dispatch-k8s-manager-plugin" target="_blank" rel="noopener">蓝盾基于K8S调度插件</a>实现。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">bkci.dispatch.kubenetes/builder-history-nodes:</span> <span class="string">'["10.x.x.1","10.x.x.2","10.x.x.3"]'</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">bkci.dispatch.kubenetes/core:</span> <span class="string">build1753761077695-ivcpmoxg</span></span><br><span class="line">    <span class="attr">bkci.dispatch.kubenetes/watch-task:</span> <span class="string">t-1753785688231121886-iInjpMUr-builder-start</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">build1753761077695-ivcpmoxg-c9d8fc6c9-mqhkk</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bkdevopsschedulerplugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line">    <span class="string">"k8s.io/kubernetes/pkg/scheduler/framework"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nodesAnnotation = <span class="string">"bkci.dispatch.kubenetes/builder-history-nodes"</span></span><br><span class="line"><span class="keyword">const</span> readResourceAnnotation = <span class="string">"bkci.dispatch.kubenetes/builder-real-resources"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> realResourceUsage <span class="keyword">struct</span> &#123;</span><br><span class="line">    Cpu    <span class="keyword">string</span> <span class="string">`json:"cpu"`</span></span><br><span class="line">    Memory <span class="keyword">string</span> <span class="string">`json:"memory"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SchedulerPlugin)</span> <span class="title">Score</span><span class="params">(_ context.Context, _ *framework.CycleState, pod *v1.Pod, nodeName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int64</span>, *framework.Status)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取历史节点信息</span></span><br><span class="line">    <span class="keyword">var</span> nodeHis []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> nodesS, ok := pod.ObjectMeta.Annotations[nodesAnnotation]; ok &#123;</span><br><span class="line">        _ = json.Unmarshal([]<span class="keyword">byte</span>(nodesS), &amp;nodeHis)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取资源信息</span></span><br><span class="line">    <span class="keyword">var</span> realResources []realResourceUsage</span><br><span class="line">    <span class="keyword">if</span> realS, ok := pod.ObjectMeta.Annotations[readResourceAnnotation]; ok &#123;</span><br><span class="line">        _ = json.Unmarshal([]<span class="keyword">byte</span>(realS), &amp;realResources)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算历史节点分数</span></span><br><span class="line">    nodeScore := calculateNodeHisScore(nodeHis, nodeName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算资源分数</span></span><br><span class="line">    <span class="comment">// ...省略资源分数计算逻辑...</span></span><br><span class="line">    realResourceScore := ... <span class="comment">// 通过 realResources 和节点资源情况计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回总分</span></span><br><span class="line">    <span class="keyword">return</span> nodeScore + realResourceScore, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeHisScores = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int64</span>&#123;<span class="number">0</span>: <span class="number">30</span>, <span class="number">1</span>: <span class="number">20</span>, <span class="number">2</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculateNodeHisScore 计算历史节点分数，将3个历史节点从最近到最远依次打分 30 - 10分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateNodeHisScore</span><span class="params">(nodeHis []<span class="keyword">string</span>, nodeName <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodeHis) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> framework.MinNodeScore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, name := <span class="keyword">range</span> nodeHis &#123;</span><br><span class="line"><span class="keyword">if</span> name != nodeName &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">score := framework.MinNodeScore</span><br><span class="line"><span class="keyword">if</span> indexS, ok := nodeHisScores[index]; ok &#123;</span><br><span class="line">score = indexS</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> framework.MinNodeScore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在插件的 Score 阶段，会读取 Pod 的 <code>bkci.dispatch.kubenetes/builder-history-nodes</code> 注解内容，并将其反序列化为历史节点名称数组，即提供历史节点信息。</li><li>插件通过 calculateNodeHisScore 方法，根据当前调度节点是否在历史节点列表中，以及其在列表中的顺序，给予不同的分数（最近的历史节点分数最高）。</li><li>该分数会与资源分数（通过 <code>bkci.dispatch.kubenetes/builder-real-resources</code> 注解和节点资源情况计算得出）相加，作为最终调度优先级，影响调度器选择节点的排序。</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>在蓝盾流水线中，通过以下方式实现了 Kubernetes 的调度优化：</p><ul><li>历史节点调度：通过注解记录历史节点信息，调度插件优先选择这些节点，减少初始化时间。</li><li>亲和性（Affinity）：根据配置文件中的 nodeSelector 和代码中的 NodeMatches 转换为 nodeAffinity，确保 Pod 调度到特定节点。</li><li>污点容忍（Tolerations）：仅在配置文件中指定了专机（privateMachine）时，生成污点容忍配置，允许 Pod 调度到带特定污点的节点。</li></ul><p>这些机制协同提升了调度效率和资源利用率。</p><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><ul><li><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/</a></li><li><a href="https://github.com/TencentBlueKing/ci-dispatch-k8s-manager-plugin" target="_blank" rel="noopener">https://github.com/TencentBlueKing/ci-dispatch-k8s-manager-plugin</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在大量使用蓝盾「Docker公共构建机」来跑构建任务后，我们发现拉起的构建 Pod 通过 hostPath 挂载工作目录做缓存，当同一流水线任务重复执行时能够加速，本文介绍蓝盾调度器如何进行调度到有缓存的节点。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾「Docker公共构建机」全链路源码解析</title>
    <link href="https://blazehu.github.io/2025/07/18/devops/landun_dispatch/"/>
    <id>https://blazehu.github.io/2025/07/18/devops/landun_dispatch/</id>
    <published>2025-07-17T16:00:00.000Z</published>
    <updated>2025-08-15T03:50:45.300Z</updated>
    
    <content type="html"><![CDATA[<p>蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。日常 CI 场景中，开发者点击 「执行流水线」 后，如果 Job 的构建类型选择 「容器构建机」，最终会在 Kubernetes 中启动一个 Deployment 作为构建 Pod。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>本文以蓝盾社区版7.1为例，结合实际源码和配置，详细梳理从前端点击「执行」到最终在 Kubernetes 集群拉起 Deployment 的全链路调用过程，</p><h3 id="2-工程鸟瞰"><a href="#2-工程鸟瞰" class="headerlink" title="2. 工程鸟瞰"></a>2. 工程鸟瞰</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bk-ci/src</span></span><br><span class="line"><span class="keyword">├── </span>gateway          <span class="comment"># OpenResty 网关（Lua）</span></span><br><span class="line">├── frontend         <span class="comment"># Vue 前端，模块级微前端</span></span><br><span class="line">├── <span class="keyword">backend </span>         <span class="comment"># Kotlin + SpringCloud 微服务</span></span><br><span class="line">│   ├── process      <span class="comment"># 流水线引擎</span></span><br><span class="line">│   ├── <span class="keyword">dispatch </span>    <span class="comment"># 构建调度（Docker &amp; K8s）</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── agent            <span class="comment"># Go 语言 Agent</span></span><br><span class="line">└── pipeline-plugin  <span class="comment"># Java 插件 SDK</span></span><br></pre></td></tr></table></figure><h3 id="3-源码拆解"><a href="#3-源码拆解" class="headerlink" title="3. 源码拆解"></a>3. 源码拆解</h3><h4 id="3-1-前端触发"><a href="#3-1-前端触发" class="headerlink" title="3.1 前端触发"></a>3.1 前端触发</h4><p>页面地址：<a href="https://devops.bk.tencent.com/console/pipeline/{projectId}/{pipelineId}/preview" target="_blank" rel="noopener">https://devops.bk.tencent.com/console/pipeline/{projectId}/{pipelineId}/preview</a></p><table><thead><tr><th>事件/方法</th><th>对应后端接口</th><th>作用</th></tr></thead><tbody><tr><td><code>requestStartupInfo</code></td><td><code>GET /ms/process/api/user/builds/{p}/{pl}/manualStartupInfo</code></td><td>获取流水线启动所需参数</td></tr><tr><td><code>executePipeline()</code></td><td><code>POST /ms/process/api/user/builds/{p}/{pl}</code></td><td>真正触发流水线执行</td></tr></tbody></table><p>相关文件路径：</p><ul><li><code>src/frontend/devops-pipeline/src/views/subpages/preview.vue</code>： 获取流水线启动所需参数</li><li><code>src/frontend/devops-pipeline/src/components/PipelineHeader/PreviewHeader.vue</code>： 点击执行按钮，触发流水线执行</li></ul><blockquote><p>通过全局事件总线 bus 通信，以及具名视图（named views）机制实现页面拆分和组合。在 <code>preview.vue</code> 页面监听 <code>executePipeline</code> 事件，然后在 <code>PreviewHeader.vue</code> 中通过事件总线触发执行。</p></blockquote><h4 id="3-2-网关转发"><a href="#3-2-网关转发" class="headerlink" title="3.2 网关转发"></a>3.2 网关转发</h4><p>/ms/process/api/user/builds/… 统一转发到 process 微服务。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /ms/process/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://process/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-Process-服务：流水线启动主链路"><a href="#3-3-Process-服务：流水线启动主链路" class="headerlink" title="3.3 Process 服务：流水线启动主链路"></a>3.3 Process 服务：流水线启动主链路</h4><p>主要方法调用链如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">UserBuildResource</span>.</span></span>manual<span class="constructor">Startup()</span>                <span class="comment">// 接收启动流水线的请求</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">ServiceBuildResourceImpl</span>.</span></span>manual<span class="constructor">Startup()</span>         <span class="comment">// 具体实现，做参数校验、权限校验等</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineBuildFacadeService</span>.</span></span>build<span class="constructor">ManualStartup()</span>  <span class="comment">// 负责组装启动参数、调用核心服务</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineBuildService</span>.</span></span>start<span class="constructor">Pipeline()</span>             <span class="comment">// 启动流水线主流程，负责流水线状态流转、记录等</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineRuntimeService</span>.</span></span>start<span class="constructor">Build()</span>              <span class="comment">// 流水线引擎，解析模型，调度 Stage/Job/Container，准备构建任务</span></span><br></pre></td></tr></table></figure><p>这一阶段主要负责接收前端的启动请求，经过参数校验、权限校验后，组装启动参数，最终进入流水线引擎。流水线引擎会解析流水线的模型（YAML/DSL），为后续的调度和任务准备做铺垫。</p><h4 id="3-4-生成并下发构建任务"><a href="#3-4-生成并下发构建任务" class="headerlink" title="3.4. 生成并下发构建任务"></a>3.4. 生成并下发构建任务</h4><p>主要方法调用链如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineContainerService</span>.</span></span>prepare<span class="constructor">BuildContainerTasks()</span>      <span class="comment">// 遍历流水线模型，为每个 Job/Container 生成任务，判断分发类型</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">VmOperateTaskGenerator</span>.</span></span>make<span class="constructor">StartVMContainerTask()</span>          <span class="comment">// 针对容器构建机，生成 VM 启动任务（taskAtom = "dispatchVMStartupTaskAtom"）</span></span><br><span class="line">    ↓</span><br><span class="line">pipelineEventDispatcher.dispatch(<span class="constructor">PipelineBuildStartEvent()</span>) <span class="comment">// 下发流水线启动事件</span></span><br></pre></td></tr></table></figure><p>此阶段会遍历流水线模型中的每个 Job/Container，根据其类型（如容器构建机）生成对应的任务。对于容器构建机，会生成 VM 启动任务，并通过事件分发器下发流水线启动事件，为后续的事件驱动调度做准备。</p><h4 id="3-5-事件驱动：Stage-Container-Task-调度"><a href="#3-5-事件驱动：Stage-Container-Task-调度" class="headerlink" title="3.5. 事件驱动：Stage/Container/Task 调度"></a>3.5. 事件驱动：Stage/Container/Task 调度</h4><p>主要方法调用链如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineBuildStartListener</span>.</span></span>run(event)                      <span class="comment">// 消费 PipelineBuildStartEvent，驱动流水线调度</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">BuildStartControl</span>.</span></span>handle(event)</span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineBuildStartEvent</span>.</span></span>execute(watcher)</span><br><span class="line">    ↓</span><br><span class="line">build<span class="constructor">Model()</span></span><br><span class="line">    ↓</span><br><span class="line">pipelineEventDispatcher.dispatch(<span class="constructor">PipelineBuildStageEvent()</span>) <span class="comment">// 下发 Stage 事件</span></span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineStageBuildListener</span>.</span></span>run(event)                      <span class="comment">// 消费 PipelineBuildStageEvent</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">StageControl</span>.</span></span>handle(event)</span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineBuildStageEvent</span>.</span></span>execute(watcher)</span><br><span class="line">    ↓</span><br><span class="line">pipelineContainerService.<span class="built_in">list</span><span class="constructor">Containers(<span class="operator">...</span>)</span>               <span class="comment">// 遍历当前 Stage 下所有 Container（Job）</span></span><br><span class="line">    ↓</span><br><span class="line">pipelineEventDispatcher.dispatch(<span class="constructor">PipelineBuildContainerEvent()</span>) <span class="comment">// 为每个 Job 下发事件</span></span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineContainerBuildListener</span>.</span></span>run(event)                  <span class="comment">// 消费 PipelineBuildContainerEvent</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">ContainerControl</span>.</span></span>handle(event)</span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">ContainerCmdChain</span>.</span></span><span class="keyword">do</span><span class="constructor">Command(<span class="params">context</span>)</span>                       <span class="comment">// 命令链执行，关键命令 StartActionTaskContainerCmd</span></span><br><span class="line">    ↓</span><br><span class="line">pipelineEventDispatcher.dispatch(<span class="constructor">PipelineBuildAtomTaskEvent()</span>) <span class="comment">// 下发插件任务事件</span></span><br></pre></td></tr></table></figure><p>蓝盾采用事件驱动架构，每个阶段（Stage）、每个 Job（Container）、每个插件（Task）都通过事件进行调度。每个事件都有对应的 Listener 消费，逐步推进流水线的执行流程，保证了系统的高解耦和可扩展性。</p><h4 id="3-6-插件任务调度与-VM-启动"><a href="#3-6-插件任务调度与-VM-启动" class="headerlink" title="3.6. 插件任务调度与 VM 启动"></a>3.6. 插件任务调度与 VM 启动</h4><p>主要方法调用链如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">PipelineAtomTaskBuildListener</span>.</span></span>run(event)                   <span class="comment">// 消费 PipelineBuildAtomTaskEvent</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">TaskControl</span>.</span></span>handle(event)</span><br><span class="line">    ↓</span><br><span class="line">taskAtomService.start(buildTask)</span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">SpringContextUtil</span>.</span></span>get<span class="constructor">Bean(IAtomTask::<span class="params">class</span>.<span class="params">java</span>, <span class="params">task</span>.<span class="params">taskAtom</span>)</span>.execute(task, runVariables)</span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">DispatchVMStartupTaskAtom</span>.</span></span>execute<span class="literal">()</span>                        <span class="comment">// 对于 VM 启动任务，加载并执行</span></span><br><span class="line">    ↓</span><br><span class="line">dispatch<span class="literal">()</span></span><br><span class="line">    ↓</span><br><span class="line">get<span class="constructor">DispatchType()</span>                                          <span class="comment">// 返回 DockerDispatchType（社区版容器构建机默认）</span></span><br><span class="line">    ↓</span><br><span class="line">pipelineEventDispatcher.dispatch(<span class="constructor">PipelineAgentStartupEvent()</span>) <span class="comment">// 下发分发事件</span></span><br></pre></td></tr></table></figure><p>每个插件任务（Atom）都会被动态加载并执行。对于 VM 启动任务，会加载 DispatchVMStartupTaskAtom 插件，判断分发类型（如 Docker），并下发 PipelineAgentStartupEvent，为后续的构建机分发做准备。</p><h4 id="3-7-dispatch-docker-服务：分发到-k8s"><a href="#3-7-dispatch-docker-服务：分发到-k8s" class="headerlink" title="3.7. dispatch-docker 服务：分发到 k8s"></a>3.7. dispatch-docker 服务：分发到 k8s</h4><p>主要方法调用链如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DockerVMListener</span>.</span></span>on<span class="constructor">Startup(<span class="params">dispatchMessage</span>)</span>                <span class="comment">// 消费 PipelineAgentStartupEvent</span></span><br><span class="line">    ↓</span><br><span class="line">get<span class="constructor">DockerRoutingType(<span class="params">projectId</span>)</span>                            <span class="comment">// 判断路由类型（如 configmap 配置为 "KUBERNETES"）</span></span><br><span class="line">    ↓</span><br><span class="line">start<span class="constructor">KubernetesDocker(<span class="operator">...</span>)</span>                                 <span class="comment">// 路由类型为 KUBERNETES 时，走 k8s 资源池</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">DispatchBuildService</span>.</span></span>start<span class="constructor">Up()</span></span><br><span class="line">    ↓</span><br><span class="line">create<span class="constructor">AndStartNewBuilder()</span></span><br><span class="line">    ↓</span><br><span class="line">containerServiceFactory.load(projectId).create<span class="constructor">AndStartBuilder()</span></span><br><span class="line">    ↓</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">KubernetesContainerService</span>.</span></span>create<span class="constructor">AndStartBuilder()</span></span><br><span class="line">    ↓</span><br><span class="line">kubernetesBuilderClient.create<span class="constructor">Builder()</span>                    <span class="comment">// HTTP POST /api/builders 调用 dispatch-k8s-manager</span></span><br></pre></td></tr></table></figure><p>dispatch-docker 服务会根据项目的路由配置，决定是走本地 Docker 还是 k8s 资源池。若配置为 KUBERNETES，则会通过 HTTP 请求调用 dispatch-k8s-manager 服务，准备在 k8s 集群中拉起构建容器。</p><blockquote><p>查看 bk-ci-bk-ci-dispatch-docker 这个 configmap，可以发现配置文件里的 defaultDockerRoutingType 是 “KUBERNETES”。</p></blockquote><h4 id="3-8-dispatch-k8s-manager-服务：拉起-k8s-Deployment"><a href="#3-8-dispatch-k8s-manager-服务：拉起-k8s-Deployment" class="headerlink" title="3.8. dispatch-k8s-manager 服务：拉起 k8s Deployment"></a>3.8. dispatch-k8s-manager 服务：拉起 k8s Deployment</h4><p>主要方法调用链如下：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">POST <span class="regexp">/api/</span>builders                                         <span class="comment">// 路由</span></span><br><span class="line">    ↓</span><br><span class="line">createBuilder handler</span><br><span class="line">    ↓</span><br><span class="line">service.CreateBuilder</span><br><span class="line">    ↓</span><br><span class="line"><span class="keyword">task</span>.DoCreateBuilder</span><br><span class="line">    ↓</span><br><span class="line">kubeclient.CreateDeployment(dep)                           <span class="comment">// 通过 k8s API 创建 Deployment，拉起实际的构建容器</span></span><br></pre></td></tr></table></figure><p>dispatch-k8s-manager 服务负责与 Kubernetes API 交互，接收来自 dispatch-docker 的 HTTP 请求后，组装 Deployment 对象并调用 k8s API，最终在集群中拉起实际的构建容器，完成流水线的环境准备。</p><h4 id="3-9-总结时序图"><a href="#3-9-总结时序图" class="headerlink" title="3.9 总结时序图"></a>3.9 总结时序图</h4><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_dispatch_chain.png" alt="landun_dispatch_chain"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><table><thead><tr><th>阶段</th><th>关键技术点</th><th>一句话描述</th></tr></thead><tbody><tr><td>前端</td><td>Vue + Event Bus</td><td>点击按钮 → 事件总线 → 请求发出</td></tr><tr><td>网关</td><td>OpenResty 前缀转发</td><td>统一入口，/ms/process/** 直接透传至 process 服务。</td></tr><tr><td>流程引擎</td><td>自研事件-命令链框架</td><td>PipelineBuildStart → Stage → Container → Task → AgentStartup，层层事件推进，高内聚低耦合。</td></tr><tr><td>插件</td><td><code>IAtomTask</code> SPI 机制</td><td>运行时动态加载 <code>DispatchVMStartupTaskAtom</code>，扩展即插即用。</td></tr><tr><td>调度</td><td>dispatch-docker → dispatch-kubernetes</td><td>根据 <code>defaultDockerRoutingType=KUBERNETES</code> 路由到对应资源池。</td></tr><tr><td>K8s 交付</td><td>dispatch-k8s-manager 与 kube-apiserver 交互</td><td>一条 HTTP 请求即可在集群内拉起 Deployment，数秒完成环境就绪。</td></tr></tbody></table><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><ul><li><a href="https://github.com/TencentBlueKing/bk-ci/tree/v2.0.0" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-ci/tree/v2.0.0</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。日常 CI 场景中，开发者点击 「执行流水线」 后，如果 Job 的构建类型选择 「容器构建机」，最终会在 Kubernetes 中启动一个 Deployment 作为构建 Pod。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾「Docker公共构建机」缓存清理</title>
    <link href="https://blazehu.github.io/2025/07/17/devops/landun_dind_cleaner/"/>
    <id>https://blazehu.github.io/2025/07/17/devops/landun_dind_cleaner/</id>
    <published>2025-07-16T16:00:00.000Z</published>
    <updated>2025-07-30T03:02:53.139Z</updated>
    
    <content type="html"><![CDATA[<p>在使用蓝盾「Docker公共构建机」一段时间后，我们发现构建镜像偶发性超时。排查后发现是由于集群的 Node 节点的磁盘满了，本文会介绍如何清理构建缓存。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>我们发现构建镜像偶发性超时，排查发现是上了 Docker-in-Docker 构建镜像之后发生的，而且发生频率越来越高，进一步排查发现是由于 Pod 会通过 hostPath 挂载工作目录和日志目录，由于构建任务过多导致 Node 节点磁盘打满。</p><h3 id="2-排查过程"><a href="#2-排查过程" class="headerlink" title="2. 排查过程"></a>2. 排查过程</h3><h4 id="2-1-事件分析"><a href="#2-1-事件分析" class="headerlink" title="2.1 事件分析"></a>2.1 事件分析</h4><p>通过 Pod 事件可以发现是由于 Node 节点磁盘打满，导致 Pod 被驱逐，构建任务失败。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason                 Age                 From     Message</span><br><span class="line">  ----     ------                 ----                ----     -------</span><br><span class="line">  Warning  Evicted                20m                 kubelet  The node was low on resource: ephemeral-storage. Container build1753761077695-ivcpmoxg was using 1580320Ki, which exceeds its request of 0.</span><br><span class="line">  Normal   NodeHasNoDiskPressure  3m (x32 over 6d5h)  kubelet  Node 10.10.32.2 status is now: NodeHasNoDiskPressure</span><br></pre></td></tr></table></figure><p><strong>pod yaml</strong><br>是由于 Pod 通过 hostPath 挂载工作目录和日志目录，通过 hostPath 挂载目录是为了做缓存，当同一流水线任务重复执行时能够加速。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/landun/workspace/build1753761077695-ivcpmoxg</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/landun/logs/build1753761077695-ivcpmoxg</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">logs-volume</span></span><br></pre></td></tr></table></figure><p><strong>dispatch-k8s-manager 模块的配置文件</strong><br><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/dispatch-k8s-manager/resources/config.yaml" target="_blank" rel="noopener">dispatch-k8s-manager/resources/config.yaml</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dispatch:</span></span><br><span class="line">  <span class="attr">volume:</span></span><br><span class="line">    <span class="comment"># 构建机脚本</span></span><br><span class="line">    <span class="attr">builderConfigMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dispatch-kubernetes-builder</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">        <span class="comment"># 初始化脚本</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">initsh.properties</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">init.sh</span></span><br><span class="line">        <span class="comment"># 登录调试需要的sleep脚本</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">sleepsh.properties</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">sleep.sh</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="comment"># 数据盘</span></span><br><span class="line">      <span class="attr">dataHostDir:</span> <span class="string">/data/landun/workspace</span></span><br><span class="line">      <span class="comment"># 日志盘</span></span><br><span class="line">      <span class="attr">logsHostDir:</span> <span class="string">/data/landun/logs</span></span><br><span class="line">    <span class="comment"># 应用数据使用cfs</span></span><br><span class="line">    <span class="attr">cfs:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data/cfs</span></span><br><span class="line">  <span class="attr">volumeMount:</span></span><br><span class="line">    <span class="attr">dataPath:</span> <span class="string">/data/landun/workspace</span></span><br><span class="line">    <span class="attr">logPath:</span> <span class="string">/data/logs</span></span><br><span class="line">    <span class="attr">builderConfigMapPath:</span> <span class="string">/data/landun/config</span></span><br><span class="line">    <span class="attr">cfs:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data/bkdevops/apps</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h4><p><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/dispatch-k8s-manager/pkg/apiserver/service/builder_start.go" target="_blank" rel="noopener">dispatch-k8s-manager/pkg/apiserver/service/builder_start.go</a></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getBuilderVolumeAndMount 获取一些构建机的常规的被挂载到pod上的volume和mount</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBuilderVolumeAndMount</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">workloadName <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">nFSs []types.NFS,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(volumes []corev1.Volume, volumeMounts []corev1.VolumeMount)</span></span> &#123;</span><br><span class="line">volumes = getBuilderPodVolume(workloadName)</span><br><span class="line">volumeMounts = getBuilderPodVolumeMount()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> volumes, volumeMounts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBuilderPodVolume 获取一些构建机的常规的被挂载到pod上的volume，包括配置configmap和data目录hostpath</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBuilderPodVolume</span><span class="params">(workloadName <span class="keyword">string</span>)</span> []<span class="title">corev1</span>.<span class="title">Volume</span></span> &#123;</span><br><span class="line">dataHostPath := filepath.Join(config.Config.Dispatch.Volume.HostPath.DataHostDir, workloadName)</span><br><span class="line">logHostPath := filepath.Join(config.Config.Dispatch.Volume.HostPath.LogsHostDir, workloadName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> items []corev1.KeyToPath</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> config.Config.Dispatch.Volume.BuilderConfigMap.Items &#123;</span><br><span class="line">items = <span class="built_in">append</span>(items, corev1.KeyToPath&#123;</span><br><span class="line">Key:  v.Key,</span><br><span class="line">Path: v.Path,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码分析可以发现 hostPath 是通过 <a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/dispatch-k8s-manager/resources/config.yaml" target="_blank" rel="noopener">dispatch-k8s-manager/resources/config.yaml</a> 加上 workloadName 拼接而成的，所以没办法通过配置文件控制不使用 hostPath，于是我们通过定时任务来清理该缓存。</p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>参考 bk-applog-bkapp-filebeat 的日志清理方案，通过 DaemonSet 实现蓝盾挂载工作目录实施定时清理操作。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME                                   DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">bk-applog-bkapp-filebeat-ingress       18        18        18      18           18          &lt;none&gt;          424d</span><br><span class="line">bk-applog-bkapp-filebeat-json          18        18        18      18           18          &lt;none&gt;          424d</span><br><span class="line">bk-applog-bkapp-filebeat-log-cleaner   18        18        18      18           18          &lt;none&gt;          424d</span><br><span class="line">bk-applog-bkapp-filebeat-stdout        18        18        18      18           18          &lt;none&gt;          424d</span><br><span class="line">bk-ci-builder-cleaner                  18        18        18      18           18          &lt;none&gt;          13d</span><br></pre></td></tr></table></figure><p><strong>编写 daemonSet.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bk-ci-builder-cleaner</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">bk-ci-builder</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">bk-ci-builder</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">bk-ci-builder</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">bk-ci-builder-cleaner</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">bk-applog-bkapp-filebeat</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">batch-delete-files</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">xxx.xxx.com/bk-ci-builder-cleaner:v1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">bash</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span> <span class="string">./delete_files.sh;</span> <span class="string">sleep</span> <span class="number">21600</span><span class="string">;</span> <span class="string">done;</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">25m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">32Mi</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">2560m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data/devops/workspace</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/data/devops/logs</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/data/landun/workspace</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/data/landun/logs</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br></pre></td></tr></table></figure><p><strong>缓存清理脚本 delete_files.sh</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># delete_files.sh  —— 正式删除版</span></span><br><span class="line"><span class="comment"># 同时扫描 /data/devops/workspace 和 /data/devops/logs</span></span><br><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------- 可配置参数 ---------</span></span><br><span class="line">ROOT_DIRS=(<span class="string">"/data/devops/workspace"</span> <span class="string">"/data/devops/logs"</span>)</span><br><span class="line">RETENTION_DAYS=7</span><br><span class="line">LOG_FILE=<span class="string">"/tmp/delete_build_dirs.log"</span></span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">  <span class="built_in">printf</span> <span class="string">'%s [%s] %s\n'</span> <span class="string">"<span class="variable">$(date '+%F %T')</span>"</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="string">"<span class="variable">$2</span>"</span> | tee -a <span class="string">"<span class="variable">$LOG_FILE</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cutoff_date=$(date -d <span class="string">"<span class="variable">$RETENTION_DAYS</span> days ago"</span> +%F)</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span> INFO <span class="string">"==== 开始检查并删除 <span class="variable">$RETENTION_DAYS</span> 天未更新的 build* 目录 ===="</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;ROOT_DIRS[@]&#125;</span>"</span>; <span class="keyword">do</span></span><br><span class="line">  [[ -d <span class="variable">$root</span> ]] || &#123; <span class="built_in">log</span> WARN <span class="string">"目录不存在: <span class="variable">$root</span>"</span>; <span class="built_in">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> dir <span class="keyword">in</span> <span class="string">"<span class="variable">$root</span>"</span>/build*; <span class="keyword">do</span></span><br><span class="line">    [[ -d <span class="variable">$dir</span> ]] || <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二次确认：目录内是否仍无任何 7 天内更新的文件</span></span><br><span class="line">    <span class="keyword">if</span> ! find <span class="string">"<span class="variable">$dir</span>"</span> -<span class="built_in">type</span> f -newermt <span class="string">"<span class="variable">$cutoff_date</span>"</span> -<span class="built_in">print</span> -quit | grep -q .; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">log</span> DELETE <span class="string">"<span class="variable">$dir</span>"</span></span><br><span class="line">        rm -rf <span class="string">"<span class="variable">$dir</span>"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">log</span> SKIP <span class="string">"<span class="variable">$dir</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span> INFO <span class="string">"==== 清理完成，日志: <span class="variable">$LOG_FILE</span> ===="</span></span><br></pre></td></tr></table></figure><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><ul><li><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用蓝盾「Docker公共构建机」一段时间后，我们发现构建镜像偶发性超时。排查后发现是由于集群的 Node 节点的磁盘满了，本文会介绍如何清理构建缓存。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾从单机到 DinD 的实践</title>
    <link href="https://blazehu.github.io/2025/06/27/devops/landun_dind/"/>
    <id>https://blazehu.github.io/2025/06/27/devops/landun_dind/</id>
    <published>2025-06-26T16:00:00.000Z</published>
    <updated>2025-08-15T03:49:23.332Z</updated>
    
    <content type="html"><![CDATA[<p>传统的单机构建环境在项目变大、任务变多时，容易出问题，比如容易崩溃、资源不够用、任务排队，以及成本和资源利用的矛盾。本文会介绍用容器化技术Docker-in-Docker（DinD）来解决这些问题，打造一个灵活、高效的CI/CD系统。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>当前构建环境因依赖单台机器，面临诸多挑战：</p><ul><li>单点故障风险，硬件或网络故障易致构建流程中断；</li><li>资源瓶颈，频繁的构建任务使机器负载过高，频繁触发告警，影响系统稳定性；</li><li>任务堆积，大量任务积压致后续任务延迟甚至超时失败，降低构建效率；</li><li>成本与资源利用问题，增加机器虽可缓解资源紧张，但会增加运维和硬件成本，且任务非持续高峰，部分时间资源闲置浪费。</li></ul><h3 id="2-技术选型方案"><a href="#2-技术选型方案" class="headerlink" title="2. 技术选型方案"></a>2. 技术选型方案</h3><h4 id="2-1-Kaniko"><a href="#2-1-Kaniko" class="headerlink" title="2.1 Kaniko"></a>2.1 Kaniko</h4><p>Kaniko 是谷歌开源的一款构建容器镜像的工具。Kaniko 并不依赖于 Docker 守护进程，完全在用户空间根据 Dockerfile 的内容逐行执行命令来构建镜像，这就使得在一些无法获取 docker 守护 进程的环境下也能够构建镜像。<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_workflow.png" alt="landun_workflow"></p><p>Kaniko 通过提取基础镜像的文件系统，按顺序执行 Dockerfile 中的指令，每执行一条指令后在用户空间创建文件系统的快照并与上一状态对比，若有变化则生成新镜像层并更新元数据，最终将构建好的镜像推送到镜像仓库。</p><h5 id="2-1-1-简单例子"><a href="#2-1-1-简单例子" class="headerlink" title="2.1.1 简单例子"></a>2.1.1 简单例子</h5><p>下面是一个使用kaniko的构建的简单例子</p><p><strong>创建密钥</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic -n blazehu kaniko-secret-common --from-file=config.json</span><br></pre></td></tr></table></figure><p><strong>构建测试</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kaniko</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kaniko</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">m.daocloud.io/gcr.io/kaniko-project/executor:latest</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--dockerfile=Dockerfile"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--context=git://user:password@github.com:blazehu/go-examples.git#master"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"--destination=blazehu1122/example:latest"</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kaniko-secret</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/kaniko/.docker/</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kaniko-secret</span></span><br><span class="line">      <span class="attr">secret:</span></span><br><span class="line">        <span class="attr">secretName:</span> <span class="string">kaniko-secret-common</span></span><br></pre></td></tr></table></figure><ul><li>使用 kaniko-project/executor:latest 镜像执行构建任务</li><li>构建参数 –context: 上下文指定 Git Repository（仅支持 git://[repository url][#reference][#commit-id] 格式）</li><li>构建参数 –destination: 指定配置的推送镜像的地址</li><li>镜像推送挂载了 kaniko-secret 密钥</li></ul><h5 id="2-1-2-构建新的CI镜像"><a href="#2-1-2-构建新的CI镜像" class="headerlink" title="2.1.2 构建新的CI镜像"></a>2.1.2 构建新的CI镜像</h5><p>那我们如何结合蓝盾来实现Dind呢？我们需要重新制作一个新的蓝盾CI镜像，参考《<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/ci-images/docker-build.md" target="_blank" rel="noopener">构建并托管一个 CI 镜像 </a>》，该CI镜像需要包括 kaniko 执行器。这里通过多阶段构建来制作新的CI镜像。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> m.daocloud.io/gcr.io/kaniko-project/executor:latest as kaniko</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> bkci/ci:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制必要文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=kaniko /kaniko /kaniko</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /kaniko/executor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt install -y git python-pip python3-pip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip config <span class="built_in">set</span> install.trusted-host mirrors.aliyun.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:/kaniko</span><br><span class="line"><span class="keyword">ENV</span> DOCKER_CONFIG /kaniko/.docker</span><br><span class="line"><span class="keyword">ENV</span> SSL_CERT_DIR /kaniko/ssl/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 kaniko 可执行文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /kaniko/executor version</span></span><br></pre></td></tr></table></figure><h5 id="2-1-3-蓝盾流水线"><a href="#2-1-3-蓝盾流水线" class="headerlink" title="2.1.3 蓝盾流水线"></a>2.1.3 蓝盾流水线</h5><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_pipeline.png" alt="landun_pipeline"></p><ol><li>第一步使用蓝盾 Checkout 插件拉取代码</li><li>第二步使用蓝盾 Shell Script 插件执行 kaniko 构建命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kaniko/executor --context=/data/devops/workspace --dockerfile=Dockerfile --destination=blazehu1122/example:latest --ignore-path=/ <span class="string">"</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-Dind-Unix-Socket"><a href="#2-2-Dind-Unix-Socket" class="headerlink" title="2.2 Dind Unix Socket"></a>2.2 Dind Unix Socket</h4><p>使用 DaemonSet 来启动 Dind Pod，将 Docker socket 文件 /var/run/docker.sock 挂载到 Pod 中。在要使用Docker服务的 Pod 中都需要挂载 socket文件。</p><h5 id="2-2-1-简单例子"><a href="#2-2-1-简单例子" class="headerlink" title="2.2.1 简单例子"></a>2.2.1 简单例子</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dinp-daemonset</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dinp-daemonset</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">dinp-daemonset</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dind</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker:dind</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockersock</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockersock</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/run/docker.sock</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">Socket</span></span><br></pre></td></tr></table></figure><p>在这个配置中，/var/run/docker.sock 被挂载到 Pod 中，允许 Pod 直接与宿主机上的 Docker 守护进程通信。这种方式不需要设置 DOCKER_HOST 环境变量，因为 Docker 客户端和守护进程直接通过 socket 文件通信。</p><h4 id="2-3-Dind-TCP"><a href="#2-3-Dind-TCP" class="headerlink" title="2.3 Dind TCP"></a>2.3 Dind TCP</h4><p>定义一个 Deployment 和一个 Service，用于启动一个包含 Dind 的 Pod，并通过 Service 对外提供 Docker 服务。在要使用Docker服务的 Pod 中设置 DOCKER_HOST 环境变量，使得 Docker 客户端知道如何连接到 Docker 守护进程（比如在bkci的基础镜像中注入该环境变量）。</p><h5 id="2-3-1-简单例子"><a href="#2-3-1-简单例子" class="headerlink" title="2.3.1 简单例子"></a>2.3.1 简单例子</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dind</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker:dind</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">"4Gi"</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">"2"</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">"8Gi"</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">"4"</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_TLS_CERTDIR</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">""</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DOCKER_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">tcp://localhost:2375</span></span><br><span class="line">        <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-storage</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-run</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/run</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> <span class="string">["docker",</span> <span class="string">"info"</span><span class="string">]</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">6</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> <span class="string">["docker",</span> <span class="string">"info"</span><span class="string">]</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment">## 污点配置</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"svc"</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">"bk"</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">              <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"app.kubernetes.io/name"</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">"In"</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">dockerhost</span></span><br><span class="line">            <span class="attr">topologyKey:</span> <span class="string">"kubernetes.io/hostname"</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-storage</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker_in_pod</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-run</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/blueking/run</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bk-ci-docker-dinp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">blueking</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dinp-deployment</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">2375</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">2375</span></span><br></pre></td></tr></table></figure><p>在需要使用 Docker 的 Pod 中设置 DOCKER_HOST 环境变量为 bk-ci-docker-dinp.blueking.svc.cluster.local，通过 Kubernetes Service 的域名解析和端口转发机制，使 Pod 内的 Docker 客户端能够连接到后端的 Docker 守护进程。</p><h5 id="2-3-2-蓝盾流水线"><a href="#2-3-2-蓝盾流水线" class="headerlink" title="2.3.2 蓝盾流水线"></a>2.3.2 蓝盾流水线</h5><ol><li>第一步使用蓝盾 Checkout 插件拉取代码</li><li>第二步使用蓝盾 Shell Script 插件执行 docker 构建命令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker context create dind --docker <span class="string">"host=tcp://bk-ci-docker-dinp.blueking.svc.cluster.local:2375,ca=/root/.docker/certs/ca.pem,cert=/root/.docker/certs/cert.pem,key=/root/.docker/certs/key.pem"</span> </span><br><span class="line">docker context use dind</span><br><span class="line"></span><br><span class="line">docker build --platform=linux/amd64 -t <span class="variable">$&#123;IMAGE_REPO&#125;</span>:<span class="variable">$&#123;IMAGE_TAG&#125;</span> -f Dockerfile . --push</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-技术选型对比"><a href="#3-技术选型对比" class="headerlink" title="3. 技术选型对比"></a>3. 技术选型对比</h3><table><thead><tr><th>特性/方案</th><th>Kaniko</th><th>Dind Unix Socket</th><th>Dind TCP</th></tr></thead><tbody><tr><td><strong>依赖环境</strong></td><td>不依赖 Docker 守护进程</td><td>依赖宿主机 Docker Socket</td><td>依赖宿主机 Docker 守护进程（TCP）</td></tr><tr><td><strong>部署复杂度</strong></td><td>简单，只需部署 Pod</td><td>中等，需要配置 DaemonSet</td><td>较复杂，需要配置 Deployment 和 Service</td></tr><tr><td><strong>资源消耗</strong></td><td>低</td><td>中等</td><td>较高</td></tr><tr><td><strong>安全性</strong></td><td>高</td><td>中等</td><td>中等</td></tr><tr><td><strong>适用场景</strong></td><td>Kubernetes 环境</td><td>单机或多节点集群</td><td>跨节点或 Kubernetes 集群</td></tr><tr><td><strong>蓝盾集成难度</strong></td><td>中等</td><td>低</td><td>中等</td></tr></tbody></table><p>虽然我们最终选择了 Kaniko 方案，但在实际应用中发现，基于 m.daocloud.io/gcr.io/kaniko-project/executor:latest 制作的蓝盾 CI 镜像存在一些兼容性问题。根据 Kaniko 的<a href="https://github.com/GoogleContainerTools/kaniko?tab=readme-ov-file#known-issues" target="_blank" rel="noopener">官方文档</a>，这种做法并不被推荐，可能会导致一些不可预见的问题。后续将根据蓝盾的官方文档和 Kaniko 的最佳实践，建议重新制作 CI 镜像。</p><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><ul><li><a href="https://github.com/GoogleContainerTools/kaniko" target="_blank" rel="noopener">https://github.com/GoogleContainerTools/kaniko</a></li><li><a href="https://juejin.cn/post/7217665415710081081" target="_blank" rel="noopener">https://juejin.cn/post/7217665415710081081</a></li><li><a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/ci-images/docker-build.md" target="_blank" rel="noopener">https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Store/ci-images/docker-build.md</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;传统的单机构建环境在项目变大、任务变多时，容易出问题，比如容易崩溃、资源不够用、任务排队，以及成本和资源利用的矛盾。本文会介绍用容器化技术Docker-in-Docker（DinD）来解决这些问题，打造一个灵活、高效的CI/CD系统。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="DinD" scheme="https://blazehu.github.io/tags/DinD/"/>
    
  </entry>
  
  <entry>
    <title>ArgoCD 扩展：实现 Pod 离群</title>
    <link href="https://blazehu.github.io/2025/04/21/cloudnative/argocd_outofcluster/"/>
    <id>https://blazehu.github.io/2025/04/21/cloudnative/argocd_outofcluster/</id>
    <published>2025-04-20T16:00:00.000Z</published>
    <updated>2025-08-15T04:03:58.027Z</updated>
    
    <content type="html"><![CDATA[<p>线上异常 Pod 既要留现场，又得立刻摘流量，还要在 ArgoCD 资源拓扑图里一眼被看到。本文会介绍如何让 Pod 秒“离群”，既摘流量与同步循环，又在拓扑图高亮标注。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>排查线上问题时，我们既想保留现场，又要快速恢复服务，不想让异常的 Pod 被 ArgoCD 自动回收。只需贴上两行标签和注解，就能让异常 Pod 立刻从 Service Endpoints 下线并被 ArgoCD 标为“离群”，现场保留、流量无损，排障后删除即可秒级复原。</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h3><p>把 Pod 的 Service selector 标签（如 app=xxx）摘掉，再给它打上 ArgoCD 「忽略差异」和「禁止回收」的注解，ArgoCD 就会把它标成“离群 Pod”而不参与同步。</p><p><strong>步骤如下：</strong></p><table><thead><tr><th>步骤</th><th>目的</th><th>命令</th></tr></thead><tbody><tr><td>1</td><td>下线流量</td><td><code>kubectl label pod app-xxx-abcde app-</code></td></tr><tr><td>2</td><td>脱离控制器</td><td><code>kubectl label pod app-xxx-abcde pod-template-hash-</code></td></tr><tr><td>3</td><td>忽略差异</td><td><code>kubectl annotate pod app-xxx-abcde argocd.argoproj.io/compare-options=IgnoreExtraneous</code></td></tr><tr><td>4</td><td>禁止回收</td><td><code>kubectl annotate pod app-xxx-abcde argocd.argoproj.io/sync-options=Prune=false</code></td></tr><tr><td>5</td><td>不影响拓扑图展示</td><td><code>kubectl label pod app-xxx-abcde argocd.argoproj.io/instance=your-app-name</code></td></tr></tbody></table><h3 id="3-实现效果"><a href="#3-实现效果" class="headerlink" title="3. 实现效果"></a>3. 实现效果</h3><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_outofcluster1.png" alt="argocd_outofcluster1"></p><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_outofcluster2.png" alt="argocd_outofcluster2"></p><blockquote><p>前端实现参考：<a href="https://blazehu.com/2023/01/30/frontend/g6_tree_demo/" target="_blank" rel="noopener">AntV G6 实现 k8s 资源拓扑图展示</a></p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>零配置修改</td><td>无需改 Git 仓库，不触发同步</td></tr><tr><td>秒级生效</td><td>纯标签/注解操作，1 秒完</td></tr><tr><td>风险可控</td><td>离群 Pod 不参与流量，随时删</td></tr><tr><td>可视化</td><td>ArgoCD UI 高亮提示，一眼识别</td></tr></tbody></table><p>下次线上再出 Bug，不妨先“离群”再排查！</p><h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h3><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/user-guide/compare-options/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/user-guide/compare-options/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;线上异常 Pod 既要留现场，又得立刻摘流量，还要在 ArgoCD 资源拓扑图里一眼被看到。本文会介绍如何让 Pod 秒“离群”，既摘流量与同步循环，又在拓扑图高亮标注。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="argocd" scheme="https://blazehu.github.io/tags/argocd/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
  </entry>
  
  <entry>
    <title>基于 Istio 实现服务的泳道发布</title>
    <link href="https://blazehu.github.io/2024/08/31/cloudnative/lanes/"/>
    <id>https://blazehu.github.io/2024/08/31/cloudnative/lanes/</id>
    <published>2024-08-30T16:00:00.000Z</published>
    <updated>2025-08-21T04:16:05.204Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Istio 的泳道发布，让多条需求在同一套共享测试环境里并行测试互不干扰，既省资源又提效。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>随着公司业务规模迅速扩张，同一微服务往往需要并行承载多个功能需求的同时开发与测试。当前一套测试环境出现了分支抢占、配置串扰、缓存冲突等问题，导致整体交付效率下滑。</p><h3 id="2-什么是泳道"><a href="#2-什么是泳道" class="headerlink" title="2. 什么是泳道"></a>2. 什么是泳道</h3><p>泳道可以理解为多个并行隔离的调用链，调用互不干扰，类似泳池中的泳道。其中一条基线泳道作为主干道常备所有服务的默认实例，其他泳道的缺失服务会自动回退到这条基线泳道。</p><p>使用流量泳道实现应用版本隔离，将链路透传请求头指定为引流请求头，使用链路透传请求头的内容向不同泳道引流。泳道中服务相互调用时，若目标服务不存在当前泳道则转发至基线泳道，保障链路完整性，简化流量管理。如下图：<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/istio_lane.png" alt="istio_lane"></p><p>图中基于 svcA、svcB、svcC 构建 v1、v2、v3 三条泳道，分别对应服务调用链的三个版本。其中 v1 为基线泳道，包含完整的三个服务，v2 仅包含 svcA、svcC 两个服务，v3 仅包含 svcB 一个服务。同时，链路透传请求头与引流请求头都指定为 X-Lane。</p><h3 id="3-方案探索"><a href="#3-方案探索" class="headerlink" title="3. 方案探索"></a>3. 方案探索</h3><p>以下资源的 YAML 按流量进入集群→路由→后端实例的顺序编排，依次对应泳道发布的 5 个关键环节。</p><h4 id="3-1-Gateway"><a href="#3-1-Gateway" class="headerlink" title="3.1 Gateway"></a>3.1 Gateway</h4><p>作用：定义统一入口，声明域名、端口及 TLS 终止方式，让外部流量能够打到集群内部。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">common-inbound-gateway</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span>  </span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'*'</span></span><br><span class="line">      <span class="attr">port:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'*'</span></span><br><span class="line">      <span class="attr">port:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">        <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">      <span class="attr">tls:</span></span><br><span class="line">        <span class="attr">credentialName:</span> <span class="string">blazehu.com</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br></pre></td></tr></table></figure><h4 id="3-2-VirtualService"><a href="#3-2-VirtualService" class="headerlink" title="3.2 VirtualService"></a>3.2 VirtualService</h4><p>作用：定义基于 HTTP 头部信息的路由规则，包括基线泳道。按 HTTP 头 X-Lane 的值把请求精准地导到 v1/v2/v3 三个泳道；若无该头，则默认落到基线泳道 v1。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-demo-vs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">common-inbound-gateway</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">argocd-demo.blazehu.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span>                       <span class="comment"># 定义基于 header 的路由规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">            <span class="attr">X-Lane:</span></span><br><span class="line">              <span class="attr">exact:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">route:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">argocd-demo-lanes</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">7777</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">            <span class="attr">X-Lane:</span></span><br><span class="line">              <span class="attr">exact:</span> <span class="string">v3</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">v3</span></span><br><span class="line">      <span class="attr">route:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">argocd-demo-lanes</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">7777</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span>                     <span class="comment"># 基线泳道 v1，没有 match 条件，作为默认路由</span></span><br><span class="line">      <span class="attr">route:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">            <span class="attr">host:</span> <span class="string">argocd-demo-lanes</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">7777</span></span><br><span class="line">            <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><h4 id="3-3-DestinationRule"><a href="#3-3-DestinationRule" class="headerlink" title="3.3 DestinationRule"></a>3.3 DestinationRule</h4><p>作用：定义服务的子集和选择器，即给每个泳道打“版本标签”，让 VirtualService 在路由时能准确找到后端实例；同时定义负载均衡策略。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-demo-dr</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">argocd-demo-lanes</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v3</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><h4 id="3-4-Service"><a href="#3-4-Service" class="headerlink" title="3.4 Service"></a>3.4 Service</h4><p>作用：把标有 app: argocd-demo 的 Pod 暴露为 argocd-demo-lanes:7777，供 VS/DR 路由。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-demo-lanes</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">7777</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br></pre></td></tr></table></figure><h4 id="3-5-Deployment"><a href="#3-5-Deployment" class="headerlink" title="3.5. Deployment"></a>3.5. Deployment</h4><p>作用：定义工作负载，每个工作负载具有不同的标签。通过 version 标签把镜像 v1/v2/v3 部署成三套独立实例，对应三条泳道；缺失组件会自动回退到基线 v1，实现“按需部署”。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># v1（基线）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-demo-v1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/inject:</span> <span class="string">'true'</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">'xxx/blazehu-demo:v1'</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">argocd-demo</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># v2（仅改 version 与镜像）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-demo-v2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/inject:</span> <span class="string">'true'</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">'xxx/blazehu-demo:v2'</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">argocd-demo</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># v3（仅改 version 与镜像）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-demo-v3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br><span class="line">        <span class="attr">sidecar.istio.io/inject:</span> <span class="string">'true'</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v3</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">'xxx/blazehu-demo:v3'</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">argocd-demo</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>通过 Gateway 入口、VirtualService 路由规则、DestinationRule 后端分组的组合，再辅以按版本标签区分的 Deployment。</p><h4 id="3-6-测试验证"><a href="#3-6-测试验证" class="headerlink" title="3.6. 测试验证"></a>3.6. 测试验证</h4><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/istio_lane_argocd.png" alt="istio_lane_argocd"><br>本地配置 hosts即可访问测试（修改 etc/hosts）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blazehu@MACBOOK ~ % curl http://argocd-demo.blazehu.com/api/check</span><br><span class="line">&#123;<span class="string">"message"</span>:<span class="string">"v1"</span>&#125; </span><br><span class="line"></span><br><span class="line">blazehu@MACBOOK ~ % curl http://argocd-demo.blazehu.com/api/check -H <span class="string">"X-Lane: v1"</span></span><br><span class="line">&#123;<span class="string">"message"</span>:<span class="string">"v1"</span>&#125;                                                                                                    </span><br><span class="line"></span><br><span class="line">blazehu@MACBOOK ~ % curl http://argocd-demo.blazehu.com/api/check -H <span class="string">"X-Lane: v2"</span></span><br><span class="line">&#123;<span class="string">"message"</span>:<span class="string">"v2"</span>&#125;                                                                                                    </span><br><span class="line"></span><br><span class="line">blazehu@MACBOOK ~ % curl http://argocd-demo.blazehu.com/api/check -H <span class="string">"X-Lane: v3"</span></span><br><span class="line">&#123;<span class="string">"message"</span>:<span class="string">"v3"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-响应头添加泳道信息"><a href="#3-7-响应头添加泳道信息" class="headerlink" title="3.7 响应头添加泳道信息"></a>3.7 响应头添加泳道信息</h4><p>为了确保前后端泳道信息的一致性和可追踪性，并使前端能够识别请求所属的泳道，我们可以在响应中添加泳道的header头。仅当泳道有效时，才将其添加至响应头，以避免向前端传递无效或错误的泳道信息。这样，前端可以通过浏览器插件自动设置请求头，实现泳道信息的准确传递和验证。<br><strong>方案一：VirtualService</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">          <span class="attr">X-Lane:</span></span><br><span class="line">            <span class="attr">exact:</span> <span class="string">'v2'</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">argocd-demo-lanes</span></span><br><span class="line">          <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">          <span class="attr">port:</span></span><br><span class="line">            <span class="attr">number:</span> <span class="number">7777</span></span><br><span class="line">        <span class="attr">headers:</span></span><br><span class="line">          <span class="attr">response:</span></span><br><span class="line">            <span class="attr">add:</span></span><br><span class="line">              <span class="attr">X-Lane:</span> <span class="string">"v2"</span>  <span class="comment"># 将请求头 x-lane 传递到响应头</span></span><br></pre></td></tr></table></figure><p><strong>方案二：EnvoyFilter</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">EnvoyFilter</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lane-response-header</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">devops</span>                   </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">configPatches:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">applyTo:</span> <span class="string">HTTP_FILTER</span></span><br><span class="line">    <span class="attr">match:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">SIDECAR_INBOUND</span></span><br><span class="line">    <span class="attr">patch:</span></span><br><span class="line">      <span class="attr">operation:</span> <span class="string">INSERT_BEFORE</span></span><br><span class="line">      <span class="attr">value:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">envoy.filters.http.lua</span></span><br><span class="line">        <span class="attr">typed_config:</span></span><br><span class="line">          <span class="string">'@type'</span><span class="string">:</span> <span class="string">type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua</span></span><br><span class="line">          <span class="attr">inlineCode:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">function</span> <span class="string">envoy_on_request(request_handle)</span></span><br><span class="line">                <span class="string">local</span> <span class="string">headers</span> <span class="string">=</span> <span class="string">request_handle:headers()</span></span><br><span class="line">                <span class="string">local</span> <span class="string">lane</span> <span class="string">=</span> <span class="string">headers:get("x-lane")</span> <span class="string">or</span> <span class="string">"nil"</span></span><br><span class="line">                <span class="string">request_handle:logWarn("==</span> <span class="attr">envoy_on_request X-Lane:</span> <span class="string">" .. lane)</span></span><br><span class="line"><span class="string">                request_handle:streamInfo():dynamicMetadata():set("</span><span class="string">envoy.filters.http.lua",</span> <span class="string">"lane"</span><span class="string">,</span> <span class="string">lane)</span></span><br><span class="line">            <span class="string">end</span></span><br><span class="line"></span><br><span class="line">            <span class="string">function</span> <span class="string">envoy_on_response(response_handle)</span></span><br><span class="line">                <span class="string">local</span> <span class="string">headers</span> <span class="string">=</span> <span class="string">response_handle:headers()</span></span><br><span class="line">                <span class="string">response_handle:logWarn("start</span> <span class="string">add</span> <span class="string">headers")</span></span><br><span class="line">                <span class="string">local</span> <span class="string">metadata</span> <span class="string">=</span> <span class="string">response_handle:streamInfo():dynamicMetadata():get("envoy.filters.http.lua")</span></span><br><span class="line">                <span class="string">local</span> <span class="string">lane</span> <span class="string">=</span> <span class="string">metadata</span> <span class="string">and</span> <span class="string">metadata["lane"]</span> <span class="string">or</span> <span class="string">"nil"</span></span><br><span class="line">                <span class="string">if</span> <span class="string">lane</span> <span class="string">==</span> <span class="string">"nil"</span> <span class="string">then</span></span><br><span class="line">                    <span class="string">response_handle:logWarn("X-Lane</span> <span class="string">header</span> <span class="string">not</span> <span class="string">found</span> <span class="string">in</span> <span class="string">request")</span></span><br><span class="line">                <span class="string">else</span></span><br><span class="line">                    <span class="string">headers:add("x-lane",</span> <span class="string">lane)</span></span><br><span class="line">                    <span class="string">response_handle:logWarn("set</span> <span class="string">x-lane,</span> <span class="string">lane:"..</span> <span class="string">lane)</span></span><br><span class="line">                <span class="string">end</span></span><br><span class="line">            <span class="string">end</span></span><br><span class="line">  <span class="attr">workloadSelector:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">argocd-demo</span></span><br></pre></td></tr></table></figure><p>两种方案均可，方案一通过 VirtualService 直接在路由层面处理请求和响应头，简单易用；方案二利用 EnvoyFilter 的 Lua 脚本在代理层面灵活操作请求和响应头，提供更高的灵活性和控制能力。</p><h3 id="4-落地实践"><a href="#4-落地实践" class="headerlink" title="4. 落地实践"></a>4. 落地实践</h3><h4 id="4-1-模板渲染"><a href="#4-1-模板渲染" class="headerlink" title="4.1. 模板渲染"></a>4.1. 模板渲染</h4><ul><li>基础资源：在 base/ 目录下管理，包括 Gateway 和 Service 等基础资源。</li><li>差异补丁：在 patch/ 目录下管理，包括 Deployment 和 VirtualService 的差异补丁。</li><li>渲染管线：前端表单 → 后端生成全局唯一泳道名 → 模版渲染 → 推送到 Git → Argo CD 同步</li></ul><h4 id="4-2-元数据原理"><a href="#4-2-元数据原理" class="headerlink" title="4.2. 元数据原理"></a>4.2. 元数据原理</h4><p>使用一个泳道 Lane CR（Custom Resource）或数据库作为唯一的数据来源。</p><blockquote><p>补充说明：我们可以通过 CR + Controller 的方式实现上述的模版渲染以及元数据管理。即将泳道定义为 XLane 类型的 CRD，并实现对应的 Controller 来管理要实现泳道功能的 Istio VirtualService 和 DestinationRule (实现路由功能) 和 K8S deployment (实现部署功能)。</p></blockquote><h4 id="4-3-功能清单"><a href="#4-3-功能清单" class="headerlink" title="4.3. 功能清单"></a>4.3. 功能清单</h4><ul><li>创建：选应用 → 选分支（版本） → 填写 TTL → 一键生成</li><li>查看：列表展示泳道、剩余 TTL、Pod 数等</li><li>更新：仅允许改镜像或副本数，提交后滚动升级</li><li>删除：二次确认后软删除并级联回收资源</li><li>清理：TTL 到期自动删除；可一键续期，最多续 3 次</li></ul><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><ul><li><a href="https://help.aliyun.com/zh/asm/sidecar/flow-lane-overview" target="_blank" rel="noopener">https://help.aliyun.com/zh/asm/sidecar/flow-lane-overview</a></li><li><a href="https://istio.io/latest/zh/docs/concepts/traffic-management" target="_blank" rel="noopener">https://istio.io/latest/zh/docs/concepts/traffic-management</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于 Istio 的泳道发布，让多条需求在同一套共享测试环境里并行测试互不干扰，既省资源又提效。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="k8s" scheme="https://blazehu.github.io/tags/k8s/"/>
    
    <category term="istio" scheme="https://blazehu.github.io/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾「Docker公共构建机」超时问题排查</title>
    <link href="https://blazehu.github.io/2024/08/20/devops/landun_clb/"/>
    <id>https://blazehu.github.io/2024/08/20/devops/landun_clb/</id>
    <published>2024-08-19T16:00:00.000Z</published>
    <updated>2025-07-30T02:25:19.025Z</updated>
    
    <content type="html"><![CDATA[<p>在使用蓝盾「Docker公共构建机」时，我们发现构建机偶尔无法就绪。排查后发现问题出在拉起的 Pod 在安装蓝盾 Agent 时卡住。经进一步分析，这是由于该 Pod 与 Nginx Ingress Pod 被调度到了同一节点，而同节点访问异常。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在阿里云ACK集群中，出现同节点访问异常的网络现象：</p><table><thead><tr><th>场景</th><th>流量路径</th><th>结果</th></tr></thead><tbody><tr><td>同节点</td><td>Pod → CLB VIP → 同节点 NodePort → 被 CLB 丢弃（回环限制）</td><td>❌ 超时</td></tr><tr><td>跨节点</td><td>Pod → CLB VIP → 其他节点 NodePort → Ingress Pod</td><td>✅ 正常</td></tr></tbody></table><ul><li><strong>跨节点访问正常</strong>：业务 Pod 与 Nginx Ingress Controller 部署在不同节点时，通过 CLB 访问服务完全正常。</li><li><strong>同节点访问超时</strong>：当业务 Pod 与 Ingress Controller 调度到同一节点时，TCP 连接超时：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Pod内测试</span></span><br><span class="line">curl http://devops.bk.xxx.xxx/static/<span class="built_in">local</span>/files/docker_init.sh</span><br><span class="line"><span class="comment"># 返回错误</span></span><br><span class="line">curl: (28) Failed to connect to devops.bk.xxx.xxx port 80: Connection timed out</span><br></pre></td></tr></table></figure></li></ul><h3 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h3><ul><li>Kubernetes 1.20.11 + Terway网络插件（非ENITrunking模式）</li><li>Nginx Ingress 0.44.0（externalTrafficPolicy: Local）</li><li>CLB 类型：四层TCP监听（端口80）</li><li>服务转发模式：IPVS</li></ul><h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><h4 id="基础检查"><a href="#基础检查" class="headerlink" title="基础检查"></a>基础检查</h4><p><strong>网络连通性测试：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DNS解析正常</span></span><br><span class="line">ping devops.bk.xxx.xxx  <span class="comment"># 返回CLB VIP 10.200.x.x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP连接失败（同节点）</span></span><br><span class="line">telnet 10.200.x.x 80    <span class="comment"># Connection timed out</span></span><br></pre></td></tr></table></figure><p><strong>安全组验证：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">已确认放行VPC内网段（10.200.0.0/16, 100.100.0.0/16），排除ACL拦截。</span><br></pre></td></tr></table></figure><h4 id="流量路径分析"><a href="#流量路径分析" class="headerlink" title="流量路径分析"></a>流量路径分析</h4><p><strong>CLB后端健康状态：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get endpoints -n kube-system nginx-ingress-controller</span><br><span class="line">ENDPOINTS: 10.212.x.x:80,10.212.x.x:443  <span class="comment"># 正常</span></span><br></pre></td></tr></table></figure><p><strong>Ingress Controller配置：</strong><br><code>externalTrafficPolicy: Local</code>导致 CLB 只会将流量转发到有 Ingress Pod 的节点。</p><p><strong>节点网络抓包：</strong><br>在Ingress节点执行抓包后，发现 CLB 的请求包能到达节点，但未转发到 Ingress Pod。</p><h4 id="根因定位"><a href="#根因定位" class="headerlink" title="根因定位"></a>根因定位</h4><p>阿里云 CLB 对四层TCP监听器默认禁止回环流量（即后端服务器通过 CLB VIP访问自身服务），相关<a href="https://help.aliyun.com/zh/slb/why-am-i-unable-to-access-an-slb-instance" target="_blank" rel="noopener">阿里云文档</a>。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>当前使用修改CoreDNS配置的临时方案，其他方案待评估后实施。</p><h4 id="修改CoreDNS配置（临时）"><a href="#修改CoreDNS配置（临时）" class="headerlink" title="修改CoreDNS配置（临时）"></a>修改CoreDNS配置（临时）</h4><p>将相关域名解析到 Ingress Service 的内网IP（如ClusterIP），绕过 CLB。</p><h4 id="更新集群组件"><a href="#更新集群组件" class="headerlink" title="更新集群组件"></a>更新集群组件</h4><ul><li>升级 Nginx Ingress ：使用新版本，已修复兼容性问题。</li><li>升级 Terway 插件：使用最新版本，优化节点内流量路由。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://help.aliyun.com/zh/slb/why-am-i-unable-to-access-an-slb-instance" target="_blank" rel="noopener">为什么无法访问负载均衡</a></li><li><a href="https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/work-with-terway?spm=a2c4g.11186623.0.i13" target="_blank" rel="noopener">使用Terway网络插件</a></li><li><a href="https://www.tencentcloud.com/zh/document/product/457/42976" target="_blank" rel="noopener">CLB 回环问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用蓝盾「Docker公共构建机」时，我们发现构建机偶尔无法就绪。排查后发现问题出在拉起的 Pod 在安装蓝盾 Agent 时卡住。经进一步分析，这是由于该 Pod 与 Nginx Ingress Pod 被调度到了同一节点，而同节点访问异常。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="clb" scheme="https://blazehu.github.io/tags/clb/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾存储服务梳理和数据迁移(v7.1)</title>
    <link href="https://blazehu.github.io/2024/06/04/devops/landun_storage/"/>
    <id>https://blazehu.github.io/2024/06/04/devops/landun_storage/</id>
    <published>2024-06-03T16:00:00.000Z</published>
    <updated>2025-03-24T13:25:43.042Z</updated>
    
    <content type="html"><![CDATA[<p>蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的存储服务梳理及数据迁移方案。</p><a id="more"></a><h3 id="1-存储服务梳理"><a href="#1-存储服务梳理" class="headerlink" title="1. 存储服务梳理"></a>1. 存储服务梳理</h3><table><thead><tr><th>存储服务</th><th>CPU/内存/磁盘</th><th>部署方式</th><th>实际资源配置</th><th>所需版本</th><th>连接串配置</th></tr></thead><tbody><tr><td>mysql</td><td>1C/2G/50Gi</td><td>云服务</td><td>2core4G 100G</td><td>5.7.26 (utf8字符集)</td><td>values文件中配置</td></tr><tr><td>redis</td><td>1C/1G/20Gi</td><td>云服务</td><td>2分片4G</td><td>6.2.5-debian-10-r63</td><td></td></tr><tr><td>redis-cluster</td><td>-/-/20Gi</td><td>云服务</td><td>-</td><td>6.2.6-debian-10-r178</td><td></td></tr><tr><td>mongodb</td><td>-/-/20Gi</td><td>云服务</td><td>4C8G</td><td>4.4.x</td><td></td></tr><tr><td>elastic</td><td>2C/4G</td><td>云服务</td><td>2c4g 20GiB</td><td>7.16.2-debian-10-r0</td><td></td></tr><tr><td>rabbitmq</td><td>-/-/20Gi</td><td>自建</td><td></td><td>3.8.21-debian-10-r0</td><td></td></tr><tr><td>zookeeper</td><td>-/-/20Gi</td><td>自建</td><td></td><td>bitnami/zookeeper:3.8.0-debian-10-r20</td><td></td></tr><tr><td>etcd</td><td>-/-/20Gi</td><td>自建</td><td></td><td>bitnami/etcd:3.5.4-debian-11-r31</td><td></td></tr><tr><td>influxdb</td><td>-/-/20Gi</td><td>自建</td><td></td><td>influxdb:1.8.6-alpine</td><td></td></tr></tbody></table><p>基础存储服务包含：mysql、redis、mongodb、rabbitmq、elastic、zookeeper、etcd。<br>蓝盾存储服务包含：mysql、redis、mongodb、rabbitmq、elastic、influxdb。<br>其中 mysql、redis、mongodb、rabbitmq、elastic 可以复用。</p><h3 id="2-基础存储服务"><a href="#2-基础存储服务" class="headerlink" title="2. 基础存储服务"></a>2. 基础存储服务</h3><p>包含：mysql、redis、mongodb、rabbitmq、elastic、zookeeper、etcd。</p><h4 id="2-1-mysql"><a href="#2-1-mysql" class="headerlink" title="2.1 mysql"></a>2.1 mysql</h4><p>镜像： hub.bktencent.com/bitnami/mysql:5.7.26</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">"1"</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">512Mi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="comment"># 处于同一集群可以使用k8s service 名</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">"bk-mysql-mysql"</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">rootPassword:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="comment"># 默认平台和saas都复用该mysql示例时，请分配大一点的磁盘空间给数据盘。</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">50Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-2-rabbitmq"><a href="#2-2-rabbitmq" class="headerlink" title="2.2 rabbitmq"></a>2.2 rabbitmq</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">"bk-rabbitmq"</span></span><br><span class="line">  <span class="comment"># AMQP协议端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">erlangCookie:</span> <span class="string">bluekingcookie</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-3-redis"><a href="#2-3-redis" class="headerlink" title="2.3 redis"></a>2.3 redis</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">64Mi</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-redis-master</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">"blueking"</span></span><br></pre></td></tr></table></figure><h4 id="2-4-redis-cluster"><a href="#2-4-redis-cluster" class="headerlink" title="2.4 redis-cluster"></a>2.4 redis-cluster</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">redisCluster:</span></span><br><span class="line">  <span class="attr">persistence:</span> </span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-redis-cluster</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">"blueking"</span></span><br></pre></td></tr></table></figure><h4 id="2-5-mongodb"><a href="#2-5-mongodb" class="headerlink" title="2.5 mongodb"></a>2.5 mongodb</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mongodb:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-mongodb-headless</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">host_port:</span> <span class="string">bk-mongodb-headless:27017</span></span><br><span class="line">  <span class="attr">rootUsername:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">rootPassword:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">rsName:</span> <span class="string">rs0</span></span><br><span class="line">  <span class="comment"># 以下变量对部署bitnamiMongodb生效，外部mongodb服务不需要</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">replicaSetKey:</span> <span class="string">xEfhjshh3APP0arf</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-6-elastic"><a href="#2-6-elastic" class="headerlink" title="2.6 elastic"></a>2.6 elastic</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">master:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">heapSize:</span> <span class="string">512m</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">10Gi</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">4096Mi</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">40Gi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">coordinating:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">2048Mi</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">256Mi</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line"></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="comment"># 集群内访问的k8s service</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">bk-elastic-elasticsearch-master.blueking.svc.cluster.local</span></span><br><span class="line">  <span class="comment"># http协议的REST端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">elastic</span> </span><br><span class="line">  <span class="comment"># 以下变量对部署bitnamiElasticsearch生效，外部elasticsearch服务不需要</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">blueking</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">40Gi</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="2-7-zookeeper"><a href="#2-7-zookeeper" class="headerlink" title="2.7 zookeeper"></a>2.7 zookeeper</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">256Mi</span></span><br></pre></td></tr></table></figure><h4 id="2-8-etcd"><a href="#2-8-etcd" class="headerlink" title="2.8 etcd"></a>2.8 etcd</h4><h3 id="3-蓝盾存储服务"><a href="#3-蓝盾存储服务" class="headerlink" title="3. 蓝盾存储服务"></a>3. 蓝盾存储服务</h3><p>包含：mysql、redis、mongodb、rabbitmq、elastic、influxdb。</p><h4 id="3-1-自建存储服务"><a href="#3-1-自建存储服务" class="headerlink" title="3.1 自建存储服务"></a>3.1 自建存储服务</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">primary:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">replica:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">influxdb:</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br><span class="line"><span class="attr">mongodb:</span></span><br><span class="line">  <span class="attr">persistence:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">20Gi</span></span><br></pre></td></tr></table></figure><h4 id="3-2-外部数据库"><a href="#3-2-外部数据库" class="headerlink" title="3.2 外部数据库"></a>3.2 外部数据库</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">externalMysql:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalRedis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalElasticsearch:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalRabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">vhost:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalInfluxdb:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">bkci</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">bkci</span></span><br><span class="line"><span class="attr">externalMongodb:</span></span><br><span class="line">  <span class="attr">turbo:</span></span><br><span class="line">    <span class="attr">turboUrl:</span> <span class="string">mongodb://bkci:bkci@localhost:27017/db_turbo</span></span><br><span class="line">    <span class="attr">quartzUrl:</span> <span class="string">mongodb://bkci:bkci@localhost:27017/db_quart</span></span><br></pre></td></tr></table></figure><h3 id="4-数据迁移-Mysql"><a href="#4-数据迁移-Mysql" class="headerlink" title="4. 数据迁移(Mysql)"></a>4. 数据迁移(Mysql)</h3><h4 id="4-1-数据备份"><a href="#4-1-数据备份" class="headerlink" title="4.1 数据备份"></a>4.1 数据备份</h4><p><strong>1.备份脚本准备</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">MYSQL_USER=root</span><br><span class="line">MYSQL_HOST=127.0.0.1</span><br><span class="line">MYSQL_PASSWD=</span><br><span class="line">ignoredblist=<span class="string">'information_schema|mysql|test|db_infobase|performance_schema|sys'</span></span><br><span class="line">dblist=<span class="string">"<span class="variable">$(mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWD -Nse"show databases;"|grep -Ewv "$ignoredblist" | xargs echo)</span>"</span></span><br><span class="line"></span><br><span class="line">mysqldump -h<span class="variable">$MYSQL_HOST</span> -u<span class="variable">$MYSQL_USER</span> -p<span class="variable">$MYSQL_PASSWD</span> --skip-opt --create-options --default-character-set=utf8mb4 -R  -E -q -e --single-transaction --no-autocommit --max-allowed-packet=1G  --hex-blob -B <span class="variable">$dblist</span> &gt; /tmp/bk_mysql_alldata.sql</span><br></pre></td></tr></table></figure><p>将其中的MYSQL_USER、MYSQL_HOST、MYSQL_PASSWORD更换成需要备份的数据库及用户名密码。存为 <code>dbbackup_mysql.sh</code> 文件。</p><p><strong>2.将脚本拷贝到容器内执行</strong><br>以自建的蓝盾mysql为例</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将上面的数据备份脚本拷贝至自建的蓝盾mysql的pod中</span></span><br><span class="line">kubectl cp -n blueking /data/dbbackup_mysql.sh bk-ci-mysql-0:/tmp/dbbackup_mysql.sh</span><br><span class="line"><span class="comment"># 开始执行数据备份</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it -n blueking bk-mysql-mysql-master-0 -- bash /tmp/dbbackup_mysql.sh</span><br><span class="line"><span class="comment"># 将备份好的sql从pod拷贝到本机暂存</span></span><br><span class="line">kubectl cp -n blueking bk-ci-mysql-0:/tmp/bk_mysql_alldata.sql /data/bkmysql_bak/bk_mysql_alldata.sql</span><br></pre></td></tr></table></figure><p>最后一步数据拷贝可以不做，直接在这个pod里进行后续的数据导入操作。</p><h4 id="4-2-数据导入"><a href="#4-2-数据导入" class="headerlink" title="4.2 数据导入"></a>4.2 数据导入</h4><p>上一步的数据备份是用<code>root</code>用户进行操作，备份中涉及存储过程函数和赋权。</p><blockquote><p>注意：如果导入到阿里云mysql服务中需要处理导出的sql文件，因为阿里云提供的mysql服务，<code>root</code>作为保留字段，不能由用户自由创建，但允许创建拥有<code>root</code>权限的账户，所以需要修改备份数据中相关的内容，更换成实际使用的数据库用户，以替换成 <code>superuser</code> 为例执行如下命令：<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计"`root`@"字符串一共有多少个</span></span><br><span class="line">grep -o <span class="string">'`root`@'</span> bk_mysql_alldata.sql | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将"`root`@" 修改为 "`superuser`@"</span></span><br><span class="line">sed -i <span class="string">'s/`root`@/`superuser`@/g'</span> bk_mysql_alldata.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二次确认</span></span><br><span class="line">grep -o <span class="string">'`superuser`@'</span> bk_mysql_alldata.sql | wc -l</span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>导入</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">mysql -h <span class="variable">$NEW_MYSQL_HOST</span> -usuperuser -p<span class="variable">$YOUR_PASSWORD</span> --force &lt; bk_mysql_alldata.sql</span><br></pre></td></tr></table></figure><p><strong>检查</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -h$MYSQL_HOST -usuperuser -p$MYSQL_PASSWD -Nse"<span class="keyword">show</span> <span class="keyword">databases</span> <span class="keyword">like</span> <span class="string">'devops_ci%'</span>;"</span><br></pre></td></tr></table></figure><h4 id="4-3-Helmfile更新"><a href="#4-3-Helmfile更新" class="headerlink" title="4.3 Helmfile更新"></a>4.3 Helmfile更新</h4><p>变更 bkci\environments\default\bkci\bkci-custom-values.yaml.gotmpl 文件后执行 helmfile 相关命令更新服务。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的存储服务梳理及数据迁移方案。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾快速部署文档(v7.1)</title>
    <link href="https://blazehu.github.io/2024/05/24/devops/landun_install/"/>
    <id>https://blazehu.github.io/2024/05/24/devops/landun_install/</id>
    <published>2024-05-23T16:00:00.000Z</published>
    <updated>2025-08-15T03:52:18.789Z</updated>
    
    <content type="html"><![CDATA[<p>蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的快速部署指南。通过详细的步骤说明和脚本示例，帮助用户在 Kubernetes 集群上快速搭建蓝鲸基础服务和蓝盾平台，并实现 HTTPS 安全访问。</p><a id="more"></a><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>需要先准备一台中控机，在中控机安装 kubectl、helm、helmfile 等工具，以及蓝鲸安装脚本。然后部署基础套餐，最后再部署持续集成套餐。简单来说就是三个步骤：1.准备环境 -&gt; 2.部署基础服务 -&gt; 3.部署蓝盾。</p><h3 id="2-准备中控机"><a href="#2-准备中控机" class="headerlink" title="2. 准备中控机"></a>2. 准备中控机</h3><p>按照<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/prepare-bkctrl.md" target="_blank" rel="noopener">官方文档</a>安装和配置即可。</p><h3 id="3-部署基础服务"><a href="#3-部署基础服务" class="headerlink" title="3. 部署基础服务"></a>3. 部署基础服务</h3><p>需要按照<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/custom-values.md" target="_blank" rel="noopener">官方文档</a>一步步部署。</p><h4 id="3-1-下载安装文件"><a href="#3-1-下载安装文件" class="headerlink" title="3.1 下载安装文件"></a>3.1 下载安装文件</h4><p>请在 <code>中控机</code> 使用下载脚本下载蓝鲸 helmfile 包及公共证书。（ helmfile相关value文件在git上维护）</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">bkdl-7.1-stable.sh -ur latest base demo</span><br></pre></td></tr></table></figure><p>这些文件默认放在了 <code>~/bkce7.1-install/</code> 目录。</p><h4 id="3-2-配置-Helm-Chart-仓库"><a href="#3-2-配置-Helm-Chart-仓库" class="headerlink" title="3.2 配置 Helm Chart 仓库"></a>3.2 配置 Helm Chart 仓库</h4><p>添加 <code>charts</code> 仓库</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helm repo add blueking https://hub.bktencent.com/chartrepo/blueking</span><br><span class="line">helm repo update</span><br><span class="line">helm repo list</span><br></pre></td></tr></table></figure><h4 id="3-3-配置全局-custom-values"><a href="#3-3-配置全局-custom-values" class="headerlink" title="3.3 配置全局 custom-values"></a>3.3 配置全局 custom-values</h4><p>相关文件已经修改，在git上维护，配置访问域名。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">BK_DOMAIN=bk.blazehu.com</span>  <span class="comment"># 请修改为你分配给蓝鲸平台的主域名 cd ~/bkce7.1-install/blueking/  # 进入工作目录# 可使用如下命令添加域名。如果文件已存在，请手动编辑。custom=environments/default/custom.yaml</span></span><br><span class="line"><span class="string">cat</span> <span class="string">&gt;&gt;</span> <span class="string">"$custom"</span> <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="attr">imageRegistry:</span> <span class="string">$&#123;REGISTRY:-hub.bktencent.com&#125;</span></span><br><span class="line"><span class="attr">domain:</span></span><br><span class="line">  <span class="attr">bkDomain:</span> <span class="string">$BK_DOMAIN</span></span><br><span class="line">  <span class="attr">bkMainSiteDomain:</span> <span class="string">$BK_DOMAIN</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h4 id="3-4-生成-values-文件"><a href="#3-4-生成-values-文件" class="headerlink" title="3.4 生成 values 文件"></a>3.4 生成 values 文件</h4><p>还有一些 values 文件随着部署环境的不同而变化，所以我们提供了脚本快速生成。</p><p><strong>生成蓝鲸 app code 对应的 secret</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">./scripts/generate_app_secret.sh ./environments/default/app_secret.yaml</span><br></pre></td></tr></table></figure><p><strong>生成 apigw 所需的 keypair</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">./scripts/generate_rsa_keypair.sh ./environments/default/bkapigateway_builtin_keypair.yaml</span><br></pre></td></tr></table></figure><p><strong>生成 paas 所需的 clusterAdmin</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">./scripts/create_k8s_cluster_admin_for_paas3.sh</span><br></pre></td></tr></table></figure><h4 id="3-5-安装入口网关"><a href="#3-5-安装入口网关" class="headerlink" title="3.5 安装入口网关"></a>3.5 安装入口网关</h4><p><strong>3.5.1 安装 ingress controller</strong><br>先检查你的环境是否已经部署了 ingress controller:</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A -l app.kubernetes.io/name=ingress-nginx</span><br></pre></td></tr></table></figure><p>如果没有，则使用如下命令创建：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f 00-ingress-nginx.yaml.gotmpl sync</span><br><span class="line">kubectl get pods -A -l app.kubernetes.io/name=ingress-nginx  查看创建的pod</span><br></pre></td></tr></table></figure><p>pops集群相关标签如下：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A -l app=ingress-nginx  <span class="comment"># 查看创建的pod</span></span><br><span class="line">IP1=$(kubectl get svc -A -l app=nginx-ingress-lb -o jsonpath=<span class="string">'&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line"><span class="comment"># IP1=$(kubectl get svc -A -l app.kubernetes.io/name=ingress-nginx -o jsonpath='&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;')</span></span><br></pre></td></tr></table></figure><p><strong>3.5.2 配置 coredns</strong><br>在部署过程中，会在容器内访问这些域名，所以需要提前配置 coredns，将蓝鲸域名解析到 service IP。</p><blockquote><p>注意：当 service 被删除，重建后 clusterIP 会变动，此时需刷新 hosts 文件。</p></blockquote><p>因此需要注入 hosts 配置项到 kube-system namespace 下的 coredns 系列 pod，步骤如下：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  <span class="comment"># 进入工作目录</span></span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> environments/default/custom.yaml)  <span class="comment"># 从自定义配置中提取, 也可自行赋值</span></span><br><span class="line"><span class="comment">#IP1=$(kubectl get svc -A -l app.kubernetes.io/instance=ingress-nginx -o jsonpath='&#123;.items[0].spec.clusterIP&#125;')</span></span><br><span class="line">IP1=$(kubectl get svc -A -l app=nginx-ingress-lb -o jsonpath=<span class="string">'&#123;.items[0].status.loadBalancer.ingress[0].ip&#125;'</span>)</span><br><span class="line">./scripts/control_coredns.sh update <span class="string">"<span class="variable">$IP1</span>"</span> <span class="variable">$BK_DOMAIN</span> bkrepo.<span class="variable">$BK_DOMAIN</span> docker.<span class="variable">$BK_DOMAIN</span> bkapi.<span class="variable">$BK_DOMAIN</span> bkpaas.<span class="variable">$BK_DOMAIN</span> bkiam-api.<span class="variable">$BK_DOMAIN</span> bkiam.<span class="variable">$BK_DOMAIN</span> apps.<span class="variable">$BK_DOMAIN</span> bknodeman.<span class="variable">$BK_DOMAIN</span> job.<span class="variable">$BK_DOMAIN</span> jobapi.<span class="variable">$BK_DOMAIN</span></span><br><span class="line">./scripts/control_coredns.sh update <span class="string">"<span class="variable">$IP1</span>"</span> devops.<span class="variable">$BK_DOMAIN</span></span><br><span class="line">./scripts/control_coredns.sh list  <span class="comment"># 检查添加的记录。</span></span><br></pre></td></tr></table></figure><p>确认注入结果，执行如下命令：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  进入工作目录</span><br><span class="line">./scripts/control_coredns.sh list</span><br></pre></td></tr></table></figure><p>参考输出如下：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">10.241.0.9 bk.blazehu.com</span><br><span class="line">10.241.0.9 apps.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkrepo.bk.blazehu.com</span><br><span class="line">10.241.0.9 docker.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkapi.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkpaas.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkiam-api.bk.blazehu.com</span><br><span class="line">10.241.0.9 bkiam.bk.blazehu.com</span><br><span class="line">10.241.0.9 bcs.bk.blazehu.com</span><br><span class="line">10.241.0.9 bknodeman.bk.blazehu.com</span><br><span class="line">10.241.0.9 job.bk.blazehu.com</span><br><span class="line">10.241.0.9 jobapi.bk.blazehu.com</span><br></pre></td></tr></table></figure><h4 id="3-6-部署或对接存储服务"><a href="#3-6-部署或对接存储服务" class="headerlink" title="3.6 部署或对接存储服务"></a>3.6 部署或对接存储服务</h4><p><strong>3.6.1 部署蓝鲸预置的存储服务</strong><br>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/storage-services.md" target="_blank" rel="noopener">官方文档</a>安装，相关helm配置已经放在git上维护，可以直接简单执行以下命令：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-storage.yaml.gotmpl sync</span><br></pre></td></tr></table></figure><blockquote><p>注意：我当前使用阿里云盘，使用该存储类创建的存储盘最小容量为20Gi，目前git上已经都修改为20Gi.</p></blockquote><p><strong>3.6.2 对接已有的存储服务</strong><br>禁用蓝鲸内置服务，配置使用已有服务。请参考helmfile定义及values文件自行研究。参考官方文档的<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/storage-services.md" target="_blank" rel="noopener">例子</a>。</p><h4 id="3-7-部署基础套餐"><a href="#3-7-部署基础套餐" class="headerlink" title="3.7 部署基础套餐"></a>3.7 部署基础套餐</h4><p>通过helmfile安装 base-blueking.yaml.gotmpl ，按照顺序依次安装。具体每层安装的内容可以查看文件内容。</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=first sync</span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=second sync</span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br><span class="line"><span class="comment">#helmfile -f base-blueking.yaml.gotmpl -l seq=fourth sync</span></span><br></pre></td></tr></table></figure><h4 id="3-8-访问蓝鲸桌面"><a href="#3-8-访问蓝鲸桌面" class="headerlink" title="3.8 访问蓝鲸桌面"></a>3.8 访问蓝鲸桌面</h4><p>在负载均衡器配置后端为 ingress-nginx pod 所在机器的内网 IP，端口为 80。详细信息参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/manual-install-bkce.md" target="_blank" rel="noopener">文档</a>。</p><h4 id="3-9-对接Ldap服务"><a href="#3-9-对接Ldap服务" class="headerlink" title="3.9 对接Ldap服务"></a>3.9 对接Ldap服务</h4><p>在用户中心里配置Ldap相关配置，然后更新 bk-user-api-web 服务的镜像。<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_install_ldap0.png" alt="landun_install_ldap0"><br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_install_ldap1.png" alt="landun_install_ldap1"></p><h3 id="4-部署蓝盾"><a href="#4-部署蓝盾" class="headerlink" title="4. 部署蓝盾"></a>4. 部署蓝盾</h3><p>参考<a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/install-ci-suite.md" target="_blank" rel="noopener">官方文档</a>部署，配置 custom values 的内容提前修改完成，执行类似部署基础服务的以下命令：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  <span class="comment"># 进入工作目录</span></span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl sync  <span class="comment"># 部署</span></span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl apply <span class="comment"># 更新</span></span><br></pre></td></tr></table></figure><p>剩下的步骤参考官方文档执行即可，主要步骤有以下三个，其他的步骤可以不做。</p><h4 id="4-1-注册默认构建镜像"><a href="#4-1-注册默认构建镜像" class="headerlink" title="4.1 注册默认构建镜像"></a>4.1 注册默认构建镜像</h4><p>我们提供了 bkci/ci 镜像用于提供构建环境。为了加速镜像下载过程，可以修改镜像地址为 hub.bktencent.com/bkci/ci，或者为你自己托管的内网 registry。<br>先检查数据库有没有历史数据：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it -n blueking bk-ci-mysql-0 -- /bin/bash -c <span class="string">'MYSQL_PWD="$MYSQL_ROOT_PASSWORD" mysql -u root -e "USE devops_ci_store; SELECT IMAGE_NAME,IMAGE_CODE,IMAGE_REPO_NAME FROM T_IMAGE WHERE IMAGE_CODE = \"bkci\" ;"'</span></span><br></pre></td></tr></table></figure><p>请根据结果进行操作：</p><ul><li>如果有显示镜像数据，可以修改镜像地址为蓝鲸国内仓库，也可改为你已经缓存在内网的镜像：<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">kubectl exec -it -n blueking bk-ci-mysql<span class="number">-0</span> -- /bin/bash -c 'MYSQL_PWD=<span class="string">"$MYSQL_ROOT_PASSWORD"</span> mysql -u root -e <span class="string">"USE devops_ci_store; UPDATE  T_IMAGE SET IMAGE_REPO_NAME=<span class="subst">\"</span>hub.bktencent.com/bkci/ci<span class="subst">\"</span> WHERE IMAGE_CODE = <span class="subst">\"</span>bkci<span class="subst">\"</span> ;"</span>'</span><br></pre></td></tr></table></figure></li><li>然后重新查询数据库，可以看到 <code>IMAGE_REPO_NAME</code> 列已经更新。</li><li>如果没有镜像，可以新增：<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -n blueking deploy/bk-ci-bk-ci-store -- \curl -vs http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/market/image/init -X POST \-H <span class="string">'X-DEVOPS-UID: admin'</span> -H <span class="string">'Content-type: application/json'</span> -d <span class="string">'&#123;"imageCode":"bkci","imageName":"bkci","imageRepo":"hub.bktencent.com/bkci/ci","projectCode":"demo","userId":"admin"&#125;'</span> | jq .</span><br></pre></td></tr></table></figure><blockquote><p>注意：当你单独卸载蓝盾重装后，可能出现查询镜像为空，但是新增镜像时报错 { status: 400, message: “权限中心创建项目失败” } 的情况。这是因为权限中心存在蓝盾 demo 项目的数据所致，我们后续会优化蓝盾单独卸载的文档。请先手动新建项目，并修改上述代码中 projectCode 字段的值。</p></blockquote></li></ul><h4 id="4-2-对接制品库"><a href="#4-2-对接制品库" class="headerlink" title="4.2 对接制品库"></a>4.2 对接制品库</h4><p>蓝盾依靠蓝鲸制品库来提供流水线仓库和自定义仓库，需要调整制品库的认证模式。当 bk-ci release 成功启动后，我们开始配置蓝鲸制品库，并注册到蓝盾中。</p><p><strong>4.2.1 修改 bk-repo custom values</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/</span><br><span class="line"><span class="keyword">case</span> $(yq e <span class="string">'.auth.config.realm'</span> environments/default/bkrepo-custom-values.yaml.gotmpl 2&gt;/dev/null) <span class="keyword">in</span></span><br><span class="line">  null|<span class="string">""</span>)</span><br><span class="line">    tee -a environments/default/bkrepo-custom-values.yaml.gotmpl &lt;&lt;&lt; $<span class="string">'auth:\n  config:\n    realm: devops'</span></span><br><span class="line">  ;;</span><br><span class="line">  devops)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"environments/default/bkrepo-custom-values.yaml.gotmpl 中配置了 .auth.config.realm=devops, 无需修改."</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"environments/default/bkrepo-custom-values.yaml.gotmpl 中配置了 .auth.config.realm 为其他值, 请手动修改值为 devops."</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>修改成功后，继续在工作目录执行如下命令使修改生效：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l name=bk-repo apply</span><br></pre></td></tr></table></figure><p><strong>4.2.2 检查配置是否生效</strong><br>检查 release 生效的 values 和 configmap 是否重新渲染。<br>请在 中控机 执行：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helm get values -n blueking bk-repo | yq e <span class="string">'.auth.config.realm'</span></span><br><span class="line">kubectl get cm -n blueking bk-repo-bkrepo-auth -o json | jq -r <span class="string">'.data."application.yml"'</span> | yq e <span class="string">'.auth.realm'</span> -</span><br></pre></td></tr></table></figure><p>预期 2 条命令均显示 devops。如果任意配置没有生效，请检查上述 helmfile 命令的输出是否正常。</p><p><strong>4.2.3 重启 bk-repo auth 微服务</strong><br>因为 deployment 没有变动，所以不会自动重启，此处需要单独重启：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">kubectl rollout restart deployment -n blueking bk-repo-bkrepo-auth</span><br></pre></td></tr></table></figure><p><strong>4.2.4 在蓝盾中注册制品库</strong><br>请在 <code>中控机</code> 执行：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/ </span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> environments/default/custom.yaml)  </span><br><span class="line">kubectl <span class="built_in">exec</span> -i -n blueking deploy/bk-ci-bk-ci-project -- curl -sS -X PUT -H <span class="string">'Content-Type: application/json'</span> -H <span class="string">'Accept: application/json'</span> -H <span class="string">'X-DEVOPS-UID: admin'</span> -d <span class="string">"&#123;\"showProjectList\":true,\"showNav\":true,\"status\":\"ok\",\"deleted\":false,\"iframeUrl\":\"//bkrepo.<span class="variable">$BK_DOMAIN</span>/ui/\"&#125;"</span> <span class="string">"http://bk-ci-bk-ci-project.blueking.svc.cluster.local/api/op/services/update/Repo"</span></span><br></pre></td></tr></table></figure><h4 id="4-3-下载和上传插件"><a href="#4-3-下载和上传插件" class="headerlink" title="4.3 下载和上传插件"></a>4.3 下载和上传插件</h4><p><strong>4.3.1 下载插件</strong><br>请在 <code>中控机</code> 执行：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">bkdl-7.1-stable.sh -ur latest ci-plugins</span><br></pre></td></tr></table></figure><p><strong>4.3.2 上传插件</strong><br>此操作只能新建插件，每个插件只能上传一次。</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bkce7.1-install/blueking/  <span class="comment"># 进入工作目录</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> ../ci-plugins/*.zip; <span class="keyword">do</span></span><br><span class="line">    atom=<span class="string">"<span class="variable">$&#123;f##*/&#125;</span>"</span></span><br><span class="line">    atom=<span class="variable">$&#123;atom%.zip&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> &gt;&amp;2 <span class="string">"upload <span class="variable">$atom</span> from <span class="variable">$f</span>"</span></span><br><span class="line">    kubectl <span class="built_in">exec</span> -i -n blueking deploy/bk-ci-bk-ci-store -- \</span><br><span class="line">      curl -s \</span><br><span class="line">      http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/pipeline/atom/deploy/<span class="string">"?publisher=admin"</span> \</span><br><span class="line">      -H <span class="string">'X-DEVOPS-UID: admin'</span> -F atomCode=<span class="variable">$atom</span> -F file=@- &lt; <span class="string">"<span class="variable">$f</span>"</span> | jq .</span><br><span class="line">      <span class="comment"># 设置为默认插件，全部项目可见。</span></span><br><span class="line">    kubectl <span class="built_in">exec</span> -n blueking deploy/bk-ci-bk-ci-store -- \</span><br><span class="line">    curl -s http://bk-ci-bk-ci-store.blueking.svc.cluster.local/api/op/pipeline/atom/default/atomCodes/<span class="variable">$atom</span> \-H <span class="string">'X-DEVOPS-UID: admin'</span> -X POST | jq .</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong>：</p><ul><li><strong>插件重复上传</strong>：如果重复执行会报错：{“status”: 2100001, “message”: “系统内部繁忙，请稍后再试”}。后续更新插件，请访问蓝盾研发商店的工作台界面，在列表中找到对应插件进行“升级”操作。</li><li><strong>插件包体过大</strong>：上传或者更新插件报错：”413 Request Entity Too Large”。原因是nginx-ingress的默认配置中proxy-body-size的数值太小，具体解决方式详见：<a href="https://developer.aliyun.com/article/1001630" target="_blank" rel="noopener">Ingress 域名方式导致413 Request Entity Too Large-阿里云开发者社区</a>。</li></ul></blockquote><h3 id="5-TLS配置"><a href="#5-TLS配置" class="headerlink" title="5. TLS配置"></a>5. TLS配置</h3><p>如果开始就准备好了相关证书，那么可以将该步骤提前，在部署基础服务和蓝盾之前就先修改好相关的yaml，将需要创建的Secret和要更新的Ingress配置都提前修改好，然后直接部署即可。</p><h4 id="5-1-购买相关证书"><a href="#5-1-购买相关证书" class="headerlink" title="5.1 购买相关证书"></a>5.1 购买相关证书</h4><p>涉及的域名：bk.blazehu.com、*.bk.blazehu.com（如devops.bk.blazehu.com）。需购买泛域名证书。</p><h4 id="5-2-创建相关Secret（用于存储TLS证书和私钥）"><a href="#5-2-创建相关Secret（用于存储TLS证书和私钥）" class="headerlink" title="5.2 创建相关Secret（用于存储TLS证书和私钥）"></a>5.2 创建相关Secret（用于存储TLS证书和私钥）</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Secret</span></span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> environments/default/custom.yaml)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/<span class="variable">$BK_DOMAIN</span></span><br><span class="line">kubectl create secret tls <span class="variable">$BK_DOMAIN</span> -n blueking --cert=<span class="variable">$HOME</span>/<span class="variable">$BK_DOMAIN</span>/<span class="variable">$BK_DOMAIN</span>.pem --key=<span class="variable">$HOME</span>/<span class="variable">$BK_DOMAIN</span>/<span class="variable">$BK_DOMAIN</span>.key</span><br></pre></td></tr></table></figure><h4 id="5-3-更新-Ingress-TLS"><a href="#5-3-更新-Ingress-TLS" class="headerlink" title="5.3 更新 Ingress TLS"></a>5.3 更新 Ingress TLS</h4><p>在证书及证书secret准备好之后，需要变更蓝鲸系列ingress开启tls的支持，执行对应的脚本</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置变量</span></span><br><span class="line">NAMESPACE=<span class="string">"blueking"</span></span><br><span class="line">DOMAIN_FILE=<span class="string">"environments/default/custom.yaml"</span></span><br><span class="line">BK_DOMAIN=$(yq e <span class="string">'.domain.bkDomain'</span> <span class="string">"<span class="variable">$DOMAIN_FILE</span>"</span>)  <span class="comment"># 从配置文件中读取域名</span></span><br><span class="line">TLS_HOST=<span class="string">"*.<span class="variable">$BK_DOMAIN</span>"</span>  <span class="comment"># 泛域名</span></span><br><span class="line">TLS_SECRET=<span class="string">"<span class="variable">$BK_DOMAIN</span>"</span>  <span class="comment"># Secret 名称与域名一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查域名和 Secret 是否正确</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">"<span class="variable">$BK_DOMAIN</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: BK_DOMAIN is not set in <span class="variable">$DOMAIN_FILE</span>."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命名空间中的所有 Ingress 资源</span></span><br><span class="line">ingresses=$(kubectl get ingress -n <span class="string">"<span class="variable">$NAMESPACE</span>"</span> -o jsonpath=<span class="string">'&#123;.items[*].metadata.name&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有 Ingress 资源并更新 TLS 配置</span></span><br><span class="line"><span class="keyword">for</span> ingress <span class="keyword">in</span> <span class="variable">$ingresses</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Updating Ingress: <span class="variable">$ingress</span> in namespace: <span class="variable">$NAMESPACE</span>"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 检查 Ingress 是否已存在 TLS 配置</span></span><br><span class="line">  <span class="keyword">if</span> kubectl get ingress <span class="string">"<span class="variable">$ingress</span>"</span> -n <span class="string">"<span class="variable">$NAMESPACE</span>"</span> -o jsonpath=<span class="string">'&#123;.spec.tls&#125;'</span> | grep -q <span class="string">"<span class="variable">$TLS_HOST</span>"</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"TLS configuration for <span class="variable">$TLS_HOST</span> already exists in Ingress <span class="variable">$ingress</span>. Skipping."</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 更新 Ingress 的 TLS 配置</span></span><br><span class="line">  kubectl patch ingress <span class="string">"<span class="variable">$ingress</span>"</span> -n <span class="string">"<span class="variable">$NAMESPACE</span>"</span> --<span class="built_in">type</span>=json -p=<span class="string">'[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      "op": "add",</span></span><br><span class="line"><span class="string">      "path": "/spec/tls",</span></span><br><span class="line"><span class="string">      "value": [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          "hosts": ["'</span><span class="string">"<span class="variable">$TLS_HOST</span>"</span><span class="string">'"],</span></span><br><span class="line"><span class="string">          "secretName": "'</span><span class="string">"<span class="variable">$TLS_SECRET</span>"</span><span class="string">'"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]'</span> || &#123; <span class="built_in">echo</span> <span class="string">"Failed to update Ingress <span class="variable">$ingress</span>"</span>; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Updated Ingress <span class="variable">$ingress</span> with TLS configuration for <span class="variable">$TLS_HOST</span>."</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"All Ingress resources in namespace <span class="variable">$NAMESPACE</span> have been updated with TLS configuration for <span class="variable">$TLS_HOST</span>."</span></span><br></pre></td></tr></table></figure><h4 id="5-4-配置蓝鲸启用HTTPS"><a href="#5-4-配置蓝鲸启用HTTPS" class="headerlink" title="5.4 配置蓝鲸启用HTTPS"></a>5.4 配置蓝鲸启用HTTPS</h4><p>在git仓库维护，主要有两个变更：</p><ul><li>environments/default/custom.yaml: .bkDomainScheme 值设置为 https</li><li>environments/default/bkci/bkci-custom-values.yaml.gotmpl: .config.bkHttpSchema 值设置为 https</li></ul><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">yq -i <span class="string">'.bkDomainScheme = "https"'</span> environments/default/custom.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将bkHttpSchema: https替换为bkHttpSchema: http</span></span><br><span class="line">sed -i <span class="string">'s|bkHttpSchema: http|bkHttpSchema: https|'</span> environments/default/bkci/bkci-custom-values.yaml.gotmpl</span><br></pre></td></tr></table></figure><p><strong>重启服务使https配置生效</strong></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启第一批服务</span></span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=first sync</span><br><span class="line"></span><br><span class="line"><span class="comment"># bk-apigateway 部分 pod 不会重启，主动删除等重建</span></span><br><span class="line">kubectl delete pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-apigateway,app.kubernetes.io/component in (api-support-fe, dashboard-fe)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待 bk-apigateway 全部 pod 重启成功后进行下一步</span></span><br><span class="line">kubectl get pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-apigateway,app.kubernetes.io/component in (api-support-fe, dashboard-fe)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bkrepo 部分 pod 不会重启，主动删除等重建</span></span><br><span class="line">kubectl delete pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-repo,bk.repo.scope=backend'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待 bkrepo 全部 pod 重启成功后进行下一步</span></span><br><span class="line"><span class="comment"># 这里一定要等所有pod重启成功后，才开始下一步，否则会导致服务异常</span></span><br><span class="line"><span class="comment"># repo系列服务会因为阿里云EKS csi插件问题，导致服务卡住，需要手动删除卡在ContainerCreating的pod，让pod重启</span></span><br><span class="line">watch -n 1 kubectl get pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-repo,bk.repo.scope=backend'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启第二批服务</span></span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=second sync</span><br><span class="line"><span class="comment"># 持续观察等 bk-repo-repository pod 全部Ready</span></span><br><span class="line">watch -n 1 kubectl get pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-repo,app.kubernetes.io/component=repository'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启第三批服务</span></span><br><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br><span class="line"> <span class="comment"># bk-paas-webfe-web pod 不会重启，主动删除等重建</span></span><br><span class="line">kubectl delete pod -n blueking -l <span class="string">'app.kubernetes.io/instance=bk-paas,app.kubernetes.io/name=webfe'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启蓝盾服务</span></span><br><span class="line">helmfile -f 03-bkci.yaml.gotmpl sync</span><br><span class="line"><span class="comment"># 这里蓝盾系列服务可能不会重启，需要手动删除老pod</span></span><br><span class="line">kubectl get pods -n blueking --field-selector=status.phase=Running| grep <span class="string">'bk-ci-bk-ci'</span> |awk <span class="string">'&#123;print $1&#125;'</span> | xargs kubectl delete pod -n blueking</span><br></pre></td></tr></table></figure><h4 id="5-5-构建机Agent配置变更及重启"><a href="#5-5-构建机Agent配置变更及重启" class="headerlink" title="5.5 构建机Agent配置变更及重启"></a>5.5 构建机Agent配置变更及重启</h4><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止agent服务</span></span><br><span class="line">./stop.sh</span><br><span class="line"></span><br><span class="line">BK_DOMAIN=<span class="string">"deveops.bk.blazehu.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改.agent.properties文件，开启https</span></span><br><span class="line">sed -i <span class="string">''</span> <span class="string">'s|http://$BK_DOMAIN|https://$BK_DOMAIN|g'</span> .agent.properties</span><br><span class="line"><span class="comment"># 修改telegraf.conf文件，开启https</span></span><br><span class="line">sed -i <span class="string">''</span> <span class="string">'s|http://$BK_DOMAIN|https://$BK_DOMAIN|g'</span> telegraf.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动agent</span></span><br><span class="line">./start.sh</span><br><span class="line"><span class="comment"># 这里需要注意，仔细查看.agent.properties里devops.agent.user， 这里是哪个用户就用哪个用户启动agent</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://bk.tencent.com/docs/markdown/ZH/DeploymentGuides/7.1/prepare-bkctrl.md" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://bk.tencent.com/s-mart/community/search?searchText=ldap&curTypeTab=all&curBestTab=latest" target="_blank" rel="noopener">官方论坛</a></li><li><a href="https://bk.tencent.com/s-mart/community/question/9114?type=article" target="_blank" rel="noopener">对接Ldap登陆</a></li><li><a href="https://github.com/TencentBlueKing/bk-ci/blob/v2.0.0/src/backend/ci/core/auth/biz-auth-rbac/src/main/kotlin/com/tencent/devops/auth/service/RbacPermissionProjectService.kt" target="_blank" rel="noopener">蓝盾源码</a></li><li><a href="https://developer.aliyun.com/article/1001630" target="_blank" rel="noopener">Ingress 域名方式导致413 Request Entity Too Large-阿里云开发者社区</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;蓝鲸持续集成平台（蓝盾）是一个免费并开源的 CI 服务。本文档旨在提供蓝鲸智云 7.1 版本蓝盾的快速部署指南。通过详细的步骤说明和脚本示例，帮助用户在 Kubernetes 集群上快速搭建蓝鲸基础服务和蓝盾平台，并实现 HTTPS 安全访问。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾接入LDAP登录(v7.1)</title>
    <link href="https://blazehu.github.io/2024/05/22/devops/landun_login_ldap/"/>
    <id>https://blazehu.github.io/2024/05/22/devops/landun_login_ldap/</id>
    <published>2024-05-21T16:00:00.000Z</published>
    <updated>2025-06-30T03:50:01.716Z</updated>
    
    <content type="html"><![CDATA[<p>通过蓝鲸用户中心配置 LDAP 后，存在登录失败以及用户名需要加域（与当前用户的使用习惯不符）等问题。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>按照<a href="https://blazehu.com/2024/05/24/devops/landun_install/#3-9-%E5%AF%B9%E6%8E%A5Ldap%E6%9C%8D%E5%8A%A1" target="_blank" rel="noopener">官方文档</a>对接 LDAP 服务后用户正常同步，但是登录时报用户密码错误。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>后台查看 bk-user-api-web 日志，报错如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"levelname"</span>: <span class="string">"ERROR"</span>,</span><br><span class="line"><span class="attr">"asctime"</span>: <span class="string">"2024-05-22 15:15:30,947"</span>,</span><br><span class="line"><span class="attr">"pathname"</span>: <span class="string">"/app/bkuser_core/api/login/views.py"</span>,</span><br><span class="line"><span class="attr">"lineno"</span>: <span class="number">205</span>,</span><br><span class="line"><span class="attr">"funcName"</span>: <span class="string">"login"</span>,</span><br><span class="line"><span class="attr">"process"</span>: <span class="number">530</span>,</span><br><span class="line"><span class="attr">"thread"</span>: <span class="number">140333237386568</span>,</span><br><span class="line"><span class="attr">"request_id"</span>: <span class="string">"ebf27affe3f74e77b961a11df38583e9"</span>,</span><br><span class="line"><span class="attr">"exc_info"</span>: <span class="string">"Traceback (most recent call last):</span></span><br><span class="line"><span class="string">File \"/app/bkuser_core/api/login/views.py\", line 197, in login</span></span><br><span class="line"><span class="string">    login_class().check(profile, password)</span></span><br><span class="line"><span class="string">File \"/app/bkuser_core/categories/plugins/ldap/login.py\", line 62, in check</span></span><br><span class="line"><span class="string">    target_dn = self.fetch_dn(user)</span></span><br><span class="line"><span class="string">File \"/app/bkuser_core/categories/plugins/ldap/login.py\", line 30, in fetch_dn</span></span><br><span class="line"><span class="string">    return force_str(user_info[\"raw_attributes\"][\"entryDN\"][0])</span></span><br><span class="line"><span class="string">File \"/usr/local/lib/python3.6/site-packages/ldap3/utils/ciDict.py\", line 68, in __getitem__</span></span><br><span class="line"><span class="string">    return self._store[self._case_insensitive_keymap[self._ci_key(key)]]</span></span><br><span class="line"><span class="string">KeyError: 'entrydn'"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错信息很明显，在 <code>user_info.raw_attributes</code> 里找不到 <code>entryDN</code> 这个 key。即获取用户用于登陆的 login dn 失败，需要修改相关逻辑。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><p>本地通过 vscode 插件连上 ldap 后，发现用户用于登陆的 login dn 的 key 应该是 <code>dn</code>，修改用于用户登陆的 login dn 逻辑。详细步骤如下：</p><ol><li><p>通过部署的配置文件 <code>environments/default/version.yaml</code> 找到部署的 bk-user 的版本为：<code>bk-user: &quot;1.4.14-beta.10&quot;</code></p></li><li><p>下载该包到本地 <code>helm pull blueking/bk-user --version 1.4.14-beta.10</code>，解压找到镜像版本：<code>tag: &quot;v2.5.4-beta.10&quot;</code></p></li><li><p>找到 bk-user 该 tag 源码地址：<a href="https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10</a></p></li><li><p>根据日志找到对应文件 <code>src/api/bkuser_core/categories/plugins/ldap/login.py</code></p></li><li><p>修改 fetch_dn 函数的实现，将 <code>entryDN</code> 修改为 <code>dn</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_dn</span><span class="params">(user_info: dict)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> force_str(user_info[<span class="string">"raw_attributes"</span>][<span class="string">"dn"</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li></ol><h4 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h4><p><strong>制作镜像</strong><br>我们只需要更新 bk-user-api-web 服务所以只需要制作该服务镜像，执行命令 <code>make build-api</code>。</p><p><strong>变更模版</strong><br>在 environments/default 目录下新建 bkuser-custom-values.yaml.gotmpl 文件使用新的镜像，若以存在则跳过。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bk-user-api:v1.0.1</span></span><br><span class="line"><span class="attr">api:</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">registry:</span> <span class="string">your</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">bk-user-api</span></span><br><span class="line">    <span class="attr">pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="string">"v1.0.1"</span></span><br></pre></td></tr></table></figure><p><strong>更新服务</strong><br>执行下面的命令进行更新：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">helmfile -f base-blueking.yaml.gotmpl -l seq=third sync</span><br></pre></td></tr></table></figure><p>检查以下容器镜像的变更是否符合预期：</p><ul><li>bk-user-api-beat</li><li>bk-user-api-web</li><li>bk-user-api-worker</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>登陆失败的问题可以通过修改源码进行修复。</li><li>登陆无需加域的临时方案：将用户和组织结构信息同步至默认域，然后查找默认域。需要修改同步逻辑。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://bk.tencent.com/s-mart/community/question/9114?type=article" target="_blank" rel="noopener">https://bk.tencent.com/s-mart/community/question/9114?type=article</a></li><li><a href="https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10" target="_blank" rel="noopener">https://github.com/TencentBlueKing/bk-user/tree/v2.5.4-beta.10</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过蓝鲸用户中心配置 LDAP 后，存在登录失败以及用户名需要加域（与当前用户的使用习惯不符）等问题。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Golang archive/zip 问题排查小记</title>
    <link href="https://blazehu.github.io/2024/02/18/backend/golang/golang_archive_zip/"/>
    <id>https://blazehu.github.io/2024/02/18/backend/golang/golang_archive_zip/</id>
    <published>2024-02-17T16:00:00.000Z</published>
    <updated>2025-08-15T03:57:28.440Z</updated>
    
    <content type="html"><![CDATA[<p>2021年给开发商做了一个<a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>，近期开发商反馈当上传的ipa文件比较大超过4G的时候上传失败。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">移动端版本体验</a>的技术架构如下图，，蓝盾插件请求版本体验后端，后端临时缓存文件并解析ipa和apk文件，获取包的相关信息（包名，版本号，图标等），然后上传至cos存储。服务端使用的golang的版本是<a href="https://go.dev/doc/go1.16" target="_blank" rel="noopener">go1.16</a>。<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/golang_archive_zip_ipapk.png" alt="golang_archive_zip_ipapk"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="插件侧报错"><a href="#插件侧报错" class="headerlink" title="插件侧报错"></a>插件侧报错</h4><p>用户反馈插件执行报错 <strong>“zip: not a valid zip file”</strong>（插件将ipa或者apk包上传至版本体验后端）<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/golang_archive_zip_plugin_error.png" alt="golang_archive_zip_plugin_error"></p><h4 id="服务端解析包报错"><a href="#服务端解析包报错" class="headerlink" title="服务端解析包报错"></a>服务端解析包报错</h4><p>通过排查后端服务日志，问题比较清晰，就是后端解析包的时候报错。解析<code>ipa</code>包的相关代码如下所示，整体逻辑比较简单，通过 <code>archive/zip</code> 读取<code>ipa</code>文件，通过正则找到 <code>plist</code> 和 <code>AppIcon</code> 文件，然后分别通过 <a href="howett.net/plist">plist</a> 和 <a href="github.com/andrianbdn/iospng">iospng</a> 解析<br>得到相关信息。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseIpa</span><span class="params">(readerAt io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="params">(*App, error)</span></span> &#123;</span><br><span class="line">log.Info(<span class="string">"[upload] file size : "</span>, size)</span><br><span class="line"><span class="keyword">var</span> reInfoPlist = regexp.MustCompile(<span class="string">`Payload/[^/]+/Info\.plist`</span>)</span><br><span class="line"></span><br><span class="line">reader, err := zip.NewReader(readerAt, size)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"[upload] zip new reader failed, err: "</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plistFile, iosIconFile *zip.File</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> reader.File &#123;</span><br><span class="line">log.Info(<span class="string">"[upload] reader file: "</span>, f.Name)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reInfoPlist.MatchString(f.Name):</span><br><span class="line">plistFile = f</span><br><span class="line"><span class="keyword">case</span> strings.Contains(f.Name, <span class="string">"AppIcon60x60"</span>):</span><br><span class="line">iosIconFile = f</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"[upload] reader plist file: "</span>, plistFile.Name)</span><br><span class="line">log.Info(<span class="string">"[upload] reader icon file: "</span>, iosIconFile.Name)</span><br><span class="line">app, err := parseIpaFile(plistFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> ignore error</span></span><br><span class="line">log.Error(<span class="string">"[upload] parse ipa failed, err: "</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"[upload] parse ipa success, err: "</span>, app)</span><br><span class="line">icon, err := parseIpaIcon(iosIconFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> ignore error</span></span><br><span class="line">log.Error(<span class="string">"[upload] parse ipa icon failed, err: "</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">app.Size = size</span><br><span class="line">app.Icon = icon</span><br><span class="line"><span class="keyword">return</span> app, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的报错：<strong>“zip: not a valid zip file”</strong> 定位是 <code>archive/zip</code> 库抛出的。</p><h4 id="源码阅读-archive-zip"><a href="#源码阅读-archive-zip" class="headerlink" title="源码阅读(archive/zip)"></a>源码阅读(<code>archive/zip</code>)</h4><p>通过查阅源码，发现该错误就是常量 <code>ErrFormat</code>，<code>NewReader</code> 方法调用了 <code>init</code> 方法，而 <code>init</code> 方法在循环读取文件头部 <code>readDirectoryHeader</code> 时会判断错误类型，如果是 <code>ErrFormat</code> 会将错误抛出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ErrFormat       = errors.New(<span class="string">"zip: not a valid zip file"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="params">(*Reader, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"zip: size cannot be negative"</span>)</span><br><span class="line">&#125;</span><br><span class="line">zr := <span class="built_in">new</span>(Reader)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> err = zr.init(r, size); err != <span class="literal">nil</span> &amp;&amp; err != ErrInsecurePath &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> zr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">init</span><span class="params">(rdr io.ReaderAt, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">end, baseOffset, err := readDirectoryEnd(rdr, size)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">r.r = rdr</span><br><span class="line">r.baseOffset = baseOffset</span><br><span class="line"><span class="comment">// Since the number of directory records is not validated, it is not</span></span><br><span class="line"><span class="comment">// safe to preallocate r.File without first checking that the specified</span></span><br><span class="line"><span class="comment">// number of files is reasonable, since a malformed archive may</span></span><br><span class="line"><span class="comment">// indicate it contains up to 1 &lt;&lt; 128 - 1 files. Since each file has a</span></span><br><span class="line"><span class="comment">// header which will be _at least_ 30 bytes we can safely preallocate</span></span><br><span class="line"><span class="comment">// if (data size / 30) &gt;= end.directoryRecords.</span></span><br><span class="line"><span class="keyword">if</span> end.directorySize &lt; <span class="keyword">uint64</span>(size) &amp;&amp; (<span class="keyword">uint64</span>(size)-end.directorySize)/<span class="number">30</span> &gt;= end.directoryRecords &#123;</span><br><span class="line">r.File = <span class="built_in">make</span>([]*File, <span class="number">0</span>, end.directoryRecords)</span><br><span class="line">&#125;</span><br><span class="line">r.Comment = end.comment</span><br><span class="line">rs := io.NewSectionReader(rdr, <span class="number">0</span>, size)</span><br><span class="line"><span class="keyword">if</span> _, err = rs.Seek(r.baseOffset+<span class="keyword">int64</span>(end.directoryOffset), io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">buf := bufio.NewReader(rs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The count of files inside a zip is truncated to fit in a uint16.</span></span><br><span class="line"><span class="comment">// Gloss over this by reading headers until we encounter</span></span><br><span class="line"><span class="comment">// a bad one, and then only report an ErrFormat or UnexpectedEOF if</span></span><br><span class="line"><span class="comment">// the file count modulo 65536 is incorrect.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">f := &amp;File&#123;zip: r, zipr: rdr&#125;</span><br><span class="line">err = readDirectoryHeader(f, buf)</span><br><span class="line"><span class="keyword">if</span> err == ErrFormat || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.headerOffset += r.baseOffset</span><br><span class="line">r.File = <span class="built_in">append</span>(r.File, f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uint16</span>(<span class="built_in">len</span>(r.File)) != <span class="keyword">uint16</span>(end.directoryRecords) &#123; <span class="comment">// only compare 16 bits here</span></span><br><span class="line"><span class="comment">// Return the readDirectoryHeader error if we read</span></span><br><span class="line"><span class="comment">// the wrong number of directory entries.</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> zipinsecurepath.Value() == <span class="string">"0"</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line"><span class="keyword">if</span> f.Name == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Zip permits an empty file name field.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The zip specification states that names must use forward slashes,</span></span><br><span class="line"><span class="comment">// so consider any backslashes in the name insecure.</span></span><br><span class="line"><span class="keyword">if</span> !filepath.IsLocal(f.Name) || strings.Contains(f.Name, <span class="string">`\`</span>) &#123;</span><br><span class="line">zipinsecurepath.IncNonDefault()</span><br><span class="line"><span class="keyword">return</span> ErrInsecurePath</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-本地复现"><a href="#4-本地复现" class="headerlink" title="4. 本地复现"></a>4. 本地复现</h4><p>本地复现该问题的时候发现解析正常，但是打成镜像容器部署会报错，通过对比我发现本地使用的go的版本是 <a href="https://go.dev/doc/go1.21" target="_blank" rel="noopener">go1.21</a> ，而镜像使用的构建镜像是 <a href="https://go.dev/doc/go1.16" target="_blank" rel="noopener">go1.16</a> 。挨个查阅 golang 的 <a href="https://go.dev/doc/devel/release" target="_blank" rel="noopener">release</a> 最终定位到是 <a href="https://go.dev/doc/go1.19" target="_blank" rel="noopener">go1.19</a> 的新特性导致的差异。<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/golang_archive_zip.png" alt="golang_archive_zip"><br><a href="https://github.com/golang/go/blob/go1.19/src/archive/zip/reader.go" target="_blank" rel="noopener">相关改动代码</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The count of files inside a zip is truncated to fit in a uint16.</span></span><br><span class="line"><span class="comment">// Gloss over this by reading headers until we encounter</span></span><br><span class="line"><span class="comment">// a bad one, and then only report an ErrFormat or UnexpectedEOF if</span></span><br><span class="line"><span class="comment">// the file count modulo 65536 is incorrect.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    f := &amp;File&#123;zip: z, zipr: r&#125;</span><br><span class="line">    err = readDirectoryHeader(f, buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For compatibility with other zip programs,</span></span><br><span class="line">    <span class="comment">// if we have a non-zero base offset and can't read</span></span><br><span class="line">    <span class="comment">// the first directory header, try again with a zero</span></span><br><span class="line">    <span class="comment">// base offset.</span></span><br><span class="line">    <span class="keyword">if</span> err == ErrFormat &amp;&amp; z.baseOffset != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(z.File) == <span class="number">0</span> &#123;</span><br><span class="line">        z.baseOffset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> _, err = rs.Seek(<span class="keyword">int64</span>(end.directoryOffset), io.SeekStart); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        buf.Reset(rs)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == ErrFormat || err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    f.headerOffset += z.baseOffset</span><br><span class="line">    z.File = <span class="built_in">append</span>(z.File, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增逻辑解读：如果在读取第一个目录头时遇到 <code>ErrFormat</code> 错误，并且基偏移量不为零，则尝试使用零基偏移量重新读取目录头。如果重新读取目录头仍然失败，则返回错误。</p><blockquote><p>NOTE: 不同操作系统或 ZIP 工具创建的 ZIP 文件时，可能会遇到不同的实现和约定。这可能导致基偏移量的计算方式不同，从而导致错误的值。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>升级golang构建的基础镜像，从<code>1.16</code> -&gt; <code>1.22</code>，重新构建新的服务镜像更新服务，这样基本满足了用户的需求。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># builder</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.22</span> AS builder</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /src/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /src &amp;&amp; go mod tidy</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /src &amp;&amp; go build -ldflags <span class="string">'-linkmode "external" --extldflags "-static"'</span> main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.14</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"blazehu"</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /ipapk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /src/main /ipapk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh /docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> /docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://go.dev/doc/go1.19" target="_blank" rel="noopener">https://go.dev/doc/go1.19</a></li><li><a href="https://docs.bkci.net/services/client-experience" target="_blank" rel="noopener">https://docs.bkci.net/services/client-experience</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年给开发商做了一个&lt;a href=&quot;https://docs.bkci.net/services/client-experience&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端版本体验&lt;/a&gt;，近期开发商反馈当上传的ipa文件比较大超过4G的时候上传失败。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://blazehu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="https://blazehu.github.io/tags/golang/"/>
    
    <category term="archive/zip" scheme="https://blazehu.github.io/tags/archive-zip/"/>
    
  </entry>
  
  <entry>
    <title>ArgoCD 源码解析：SSE 实时推送机制</title>
    <link href="https://blazehu.github.io/2023/11/30/cloudnative/argocd_sse/"/>
    <id>https://blazehu.github.io/2023/11/30/cloudnative/argocd_sse/</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2025-08-15T04:08:57.227Z</updated>
    
    <content type="html"><![CDATA[<p>服务器发送事件 (Server-Sent Events) 是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新，并描述了在建立初始客户端连接后服务器如何向客户端发起数据传输。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>在使用Argo CD的时候可以发现页面可以实时刷新应用的状态，比如同步中，那Argo CD是如何实现消息的实时推送的呢？本文将简要介绍Argo CD使用到的消息推送技术：SSE。</p><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd-sse-app.png" alt="argocd-sse-app"></p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><p>通过浏览器开发者工具可以发现前端请求的地址是 <code>stream/applications</code>，响应头表示这是一个服务器发送事件（Server-Sent Events，SSE）。</p><blockquote><p>本文的源码基于2.6.0版本</p></blockquote><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd-sse-eventstream1.png" alt="argocd-sse-eventstream1"><br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd-sse-eventstream2.png" alt="argocd-sse-eventstream2"></p><blockquote><p>Content-Type: text/event-stream：这个响应头告诉客户端，服务器将发送的数据是以文本格式的事件流（Event Stream）。</p></blockquote><h4 id="2-1-客户端实现"><a href="#2-1-客户端实现" class="headerlink" title="2.1 客户端实现"></a>2.1 客户端实现</h4><p>Argo CD的前端使用的是 React，相关代码 <a href="https://github.com/argoproj/argo-cd/blob/v2.6.0/ui/src/app/applications/components/application-details/application-details.tsx" target="_blank" rel="noopener">application-details.tsx</a> 实现如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">private loadAppInfo(name: string, <span class="attr">appNamespace</span>: string): Observable&lt;&#123;<span class="attr">application</span>: appModels.Application; tree: appModels.ApplicationTree&#125;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">from</span>(services.applications.get(name, appNamespace))</span><br><span class="line">        .pipe(</span><br><span class="line">            mergeMap(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> fallbackTree = &#123;</span><br><span class="line">                    nodes: app.status.resources.map(<span class="function"><span class="params">res</span> =&gt;</span> (&#123;...res, <span class="attr">parentRefs</span>: [], <span class="attr">info</span>: [], <span class="attr">resourceVersion</span>: <span class="string">''</span>, <span class="attr">uid</span>: <span class="string">''</span>&#125;)),</span><br><span class="line">                    orphanedNodes: [],</span><br><span class="line">                    hosts: []</span><br><span class="line">                &#125; <span class="keyword">as</span> appModels.ApplicationTree;</span><br><span class="line">                <span class="keyword">return</span> combineLatest(</span><br><span class="line">                    merge(</span><br><span class="line">                        <span class="keyword">from</span>([app]),</span><br><span class="line">                        <span class="keyword">this</span>.appChanged.pipe(filter(<span class="function"><span class="params">item</span> =&gt;</span> !!item)),</span><br><span class="line">                        AppUtils.handlePageVisibility(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">                            services.applications</span><br><span class="line">                                .watch(&#123;name, appNamespace&#125;)</span><br><span class="line">                                .pipe(</span><br><span class="line">                                    map(<span class="function"><span class="params">watchEvent</span> =&gt;</span> &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (watchEvent.type === <span class="string">'DELETED'</span>) &#123;</span><br><span class="line">                                            <span class="keyword">this</span>.onAppDeleted();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">return</span> watchEvent.application;</span><br><span class="line">                                    &#125;)</span><br><span class="line">                                )</span><br><span class="line">                                .pipe(repeat())</span><br><span class="line">                                .pipe(retryWhen(<span class="function"><span class="params">errors</span> =&gt;</span> errors.pipe(delay(<span class="number">500</span>))))</span><br><span class="line">                        )</span><br><span class="line">                    ),</span><br><span class="line">                    merge(</span><br><span class="line">                        <span class="keyword">from</span>([fallbackTree]),</span><br><span class="line">                        services.applications.resourceTree(name, appNamespace).catch(<span class="function"><span class="params">()</span> =&gt;</span> fallbackTree),</span><br><span class="line">                        AppUtils.handlePageVisibility(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">                            services.applications</span><br><span class="line">                                .watchResourceTree(name, appNamespace)</span><br><span class="line">                                .pipe(repeat())</span><br><span class="line">                                .pipe(retryWhen(<span class="function"><span class="params">errors</span> =&gt;</span> errors.pipe(delay(<span class="number">500</span>))))</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        .pipe(filter(<span class="function">(<span class="params">[application, tree]</span>) =&gt;</span> !!application &amp;&amp; !!tree))</span><br><span class="line">        .pipe(map(<span class="function">(<span class="params">[application, tree]</span>) =&gt;</span> (&#123;application, tree&#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadAppInfo</code> 方法的主要目的是从服务器加载应用信息，并在页面可见时实时更新。它返回一个 Observable，包含应用信息 <code>services.applications.watch</code> 和应用资源树 <code>services.applications.watchResourceTree</code>。我们继续查看应用信息的 <code>watch</code> 函数实现。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">public watch(query?: &#123;name?: string; resourceVersion?: string; projects?: string[]; appNamespace?: string&#125;, options?: QueryOptions): Observable&lt;models.ApplicationWatchEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> search = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">    <span class="keyword">if</span> (query) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query.name) &#123;</span><br><span class="line">            search.set(<span class="string">'name'</span>, query.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (query.resourceVersion) &#123;</span><br><span class="line">            search.set(<span class="string">'resourceVersion'</span>, query.resourceVersion);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (query.appNamespace) &#123;</span><br><span class="line">            search.set(<span class="string">'appNamespace'</span>, query.appNamespace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">        <span class="keyword">const</span> searchOptions = optionsToSearch(options);</span><br><span class="line">        search.set(<span class="string">'fields'</span>, searchOptions.fields);</span><br><span class="line">        search.set(<span class="string">'selector'</span>, searchOptions.selector);</span><br><span class="line">        search.set(<span class="string">'appNamespace'</span>, searchOptions.appNamespace);</span><br><span class="line">        query?.projects?.forEach(<span class="function"><span class="params">project</span> =&gt;</span> search.append(<span class="string">'projects'</span>, project));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> searchStr = search.toString();</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`/stream/applications<span class="subst">$&#123;(searchStr &amp;&amp; <span class="string">'?'</span> + searchStr) || <span class="string">''</span>&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> requests</span><br><span class="line">        .loadEventSource(url)</span><br><span class="line">        .pipe(repeat())</span><br><span class="line">        .pipe(retry())</span><br><span class="line">        .pipe(map(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.parse(data).result <span class="keyword">as</span> models.ApplicationWatchEvent))</span><br><span class="line">        .pipe(</span><br><span class="line">            map(<span class="function"><span class="params">watchEvent</span> =&gt;</span> &#123;</span><br><span class="line">                watchEvent.application = <span class="keyword">this</span>.parseAppFields(watchEvent.application);</span><br><span class="line">                <span class="keyword">return</span> watchEvent;</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该函数使用 <code>requests.loadEventSource(url)</code> 加载服务器发送的事件流（Event Stream），请求地址为 <code>/stream/applications</code>。<code>loadEventSource</code> 的实现是基于 <code>EventSource</code> 对象的, <code>EventSource</code> 实例设置 <code>onmessage</code> 事件处理程序，当接收到新消息时，调用 <code>observer.next(msg.data)</code> 将消息数据推送到 <code>Observable</code> 实现页面的实时刷新。在文档 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">Using server-sent events</a> 中有介绍, 这里就不详细介绍了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    loadEventSource(url: string): Observable&lt;string&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="function">(<span class="params">observer: Observer&lt;any&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">`<span class="subst">$&#123;apiRoot()&#125;</span><span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">            eventSource.onmessage = <span class="function"><span class="params">msg</span> =&gt;</span> observer.next(msg.data);</span><br><span class="line">            eventSource.onerror = <span class="function"><span class="params">e</span> =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                observer.error(e);</span><br><span class="line">                onError.next(e);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EventSource does not provide easy way to get notification when connection closed.</span></span><br><span class="line">            <span class="comment">// check readyState periodically instead.</span></span><br><span class="line">            <span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventSource &amp;&amp; eventSource.readyState === ReadyState.CLOSED) &#123;</span><br><span class="line">                    observer.error(<span class="string">'connection got closed unexpectedly'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                clearInterval(interval);</span><br><span class="line">                eventSource.close();</span><br><span class="line">                eventSource = <span class="literal">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2-服务端实现"><a href="#2-2-服务端实现" class="headerlink" title="2.2 服务端实现"></a>2.2 服务端实现</h4><p>Argo CD的后端使用的是 Go，相关代码 <a href="https://github.com/argoproj/argo-cd/blob/v2.6.0/server/application/application.go" target="_blank" rel="noopener">application.go</a> 实现如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ApplicationService_WatchServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Send(*v1alpha1.ApplicationWatchEvent) error</span><br><span class="line">    grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Watch</span><span class="params">(q *application.ApplicationQuery, ws application.ApplicationService_WatchServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">appName := q.GetName()</span><br><span class="line">appNs := s.appNamespaceOrDefault(q.GetAppNamespace())</span><br><span class="line">logCtx := log.NewEntry(log.New())</span><br><span class="line"><span class="keyword">if</span> q.Name != <span class="literal">nil</span> &#123;</span><br><span class="line">logCtx = logCtx.WithField(<span class="string">"application"</span>, *q.Name)</span><br><span class="line">&#125;</span><br><span class="line">projects := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> q.Projects &#123;</span><br><span class="line">projects[q.Projects[i]] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">claims := ws.Context().Value(<span class="string">"claims"</span>)</span><br><span class="line">selector, err := labels.Parse(q.GetSelector())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error parsing labels with selectors: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">minVersion := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> q.GetResourceVersion() != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> minVersion, err = strconv.Atoi(q.GetResourceVersion()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">minVersion = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sendIfPermitted is a helper to send the application to the client's streaming channel if the</span></span><br><span class="line"><span class="comment">// caller has RBAC privileges permissions to view it</span></span><br><span class="line">sendIfPermitted := <span class="function"><span class="keyword">func</span><span class="params">(a appv1.Application, eventType watch.EventType)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(projects) &gt; <span class="number">0</span> &amp;&amp; !projects[a.Spec.GetProject()] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> appVersion, err := strconv.Atoi(a.ResourceVersion); err == <span class="literal">nil</span> &amp;&amp; appVersion &lt; minVersion &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">matchedEvent := (appName == <span class="string">""</span> || (a.Name == appName &amp;&amp; a.Namespace == appNs)) &amp;&amp; selector.Matches(labels.Set(a.Labels))</span><br><span class="line"><span class="keyword">if</span> !matchedEvent &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !s.enf.Enforce(claims, rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, a.RBACName(s.ns)) &#123;</span><br><span class="line"><span class="comment">// do not emit apps user does not have accessing</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s.inferResourcesStatusHealth(&amp;a)</span><br><span class="line">err := ws.Send(&amp;appv1.ApplicationWatchEvent&#123;</span><br><span class="line">Type:        eventType,</span><br><span class="line">Application: a,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logCtx.Warnf(<span class="string">"Unable to send stream message: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">events := <span class="built_in">make</span>(<span class="keyword">chan</span> *appv1.ApplicationWatchEvent, watchAPIBufferSize)</span><br><span class="line"><span class="comment">// Mimic watch API behavior: send ADDED events if no resource version provided</span></span><br><span class="line"><span class="comment">// If watch API is executed for one application when emit event even if resource version is provided</span></span><br><span class="line"><span class="comment">// This is required since single app watch API is used for during operations like app syncing and it is</span></span><br><span class="line"><span class="comment">// critical to never miss events.</span></span><br><span class="line"><span class="keyword">if</span> q.GetResourceVersion() == <span class="string">""</span> || q.GetName() != <span class="string">""</span> &#123;</span><br><span class="line">apps, err := s.appLister.List(selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"error listing apps with selector: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(apps, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> apps[i].QualifiedName() &lt; apps[j].QualifiedName()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> apps &#123;</span><br><span class="line">sendIfPermitted(*apps[i], watch.Added)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">unsubscribe := s.appBroadcaster.Subscribe(events)</span><br><span class="line"><span class="keyword">defer</span> unsubscribe()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> event := &lt;-events:</span><br><span class="line">sendIfPermitted(event.Application, event.Type)</span><br><span class="line"><span class="keyword">case</span> &lt;-ws.Context().Done():</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>ws</code> 用于发送实时更新的应用程序事件。当有新的事件发生时，<code>sendIfPermitted</code> 函数会将事件发送到客户端。</p><blockquote><p>NOTE: <code>ws</code> 是一个实现了 <code>ApplicationService_WatchServer</code> 接口的对象。<code>ApplicationService_WatchServer</code> 接口继承了 <code>grpc.ServerStream</code> 接口，并定义了一个名为 <code>Send</code> 的方法。这意味着 <code>ws</code> 可以用作服务器端的流，并具有发送 <code>ApplicationWatchEvent</code> 类型消息的能力。</p></blockquote><h3 id="3-实现一个简单的SSE接口服务样例"><a href="#3-实现一个简单的SSE接口服务样例" class="headerlink" title="3 实现一个简单的SSE接口服务样例"></a>3 实现一个简单的SSE接口服务样例</h3><p><a href="https://github.com/blazehu/sse-demo" target="_blank" rel="noopener">相关代码地址</a>，实现如下效果，页面上通过 sse 获取数据（当前时间和推送人），后端服务由 grpc｜grpc-gateway stream 推送。</p><blockquote><p>NOTE: 后续补充更新中</p></blockquote><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd-sse-demo.gif" alt="argocd-sse-demo"></p><h4 id="3-1-使用-protobuf-定义-gRPC-服务"><a href="#3-1-使用-protobuf-定义-gRPC-服务" class="headerlink" title="3.1 使用 protobuf 定义 gRPC 服务"></a>3.1 使用 protobuf 定义 gRPC 服务</h4><p>新建一个项目<a href="https://github.com/blazehu/sse-demo" target="_blank" rel="noopener">sse-demo</a>，在项目目录下执行<code>go mod init</code>命令完成<code>go module</code>初始化。 在项目目录下创建一个 <a href="https://github.com/blazehu/sse-demo/blob/main/proto/chat.proto" target="_blank" rel="noopener">proto/chat.proto</a> 文件，其内容如下:</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"github.com/blazehu/sse-demo/server/apiclient/chat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/api/annotations.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/empty.proto"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">ChatService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Chat(google.protobuf.Empty) <span class="keyword">returns</span> (stream Message) &#123;</span></span><br><span class="line"><span class="function">    option (google.api.http) = &#123;</span></span><br><span class="line"><span class="function">      get: "/api/v1/stream/chat"</span></span><br><span class="line"><span class="function">    &#125;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> user = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> content = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-生成代码"><a href="#3-2-生成代码" class="headerlink" title="3.2 生成代码"></a>3.2 生成代码</h4><p>这用 <a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/generating_stubs/using_buf/" target="_blank" rel="noopener">buf</a> 生成代码，首先在项目目录下执行 <code>buf mod init</code> 生成 <code>buf.yaml</code> 文件，我们需要修改该文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">buf.build/blazehu/sse-demo</span></span><br><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/googleapis/googleapis</span></span><br><span class="line"><span class="attr">breaking:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FILE</span></span><br><span class="line"><span class="attr">lint:</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">DEFAULT</span></span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 这里主要是添加依赖项 googleapis，<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/adding_annotations/" target="_blank" rel="noopener">相关详细文档</a>。</p></blockquote><p>修改完成后执行 <code>buf mod update</code> 来选择要使用的依赖项的版本。 然后我们创建一个 <code>buf.gen.yaml</code> 文件用于生成存根。<code>buf.gen.yaml</code>文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">plugin:</span> <span class="string">go</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span> <span class="string">paths=source_relative</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">plugin:</span> <span class="string">go-grpc</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span> <span class="string">paths=source_relative,require_unimplemented_servers=false</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">plugin:</span> <span class="string">grpc-gateway</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">gen</span></span><br><span class="line">    <span class="attr">opt:</span> <span class="string">paths=source_relative</span></span><br></pre></td></tr></table></figure><p>这时候我们可以通过 <code>buf generate</code> 生成存根，也可以使用 <code>protoc</code> 来生成存根，这里就不展开说明。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> buf generate</span></span><br></pre></td></tr></table></figure><p>这时候将会由如下的目录结构：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">├── <span class="selector-tag">buf</span><span class="selector-class">.gen</span><span class="selector-class">.yaml</span></span><br><span class="line">├── <span class="selector-tag">buf</span><span class="selector-class">.lock</span></span><br><span class="line">├── <span class="selector-tag">buf</span><span class="selector-class">.yaml</span></span><br><span class="line">├── <span class="selector-tag">gen</span></span><br><span class="line">│   └── <span class="selector-tag">proto</span></span><br><span class="line">│       ├── <span class="selector-tag">chat</span><span class="selector-class">.pb</span><span class="selector-class">.go</span></span><br><span class="line">│       ├── <span class="selector-tag">chat</span><span class="selector-class">.pb</span><span class="selector-class">.gw</span><span class="selector-class">.go</span></span><br><span class="line">│       └── <span class="selector-tag">chat_grpc</span><span class="selector-class">.pb</span><span class="selector-class">.go</span></span><br><span class="line">├── <span class="selector-tag">go</span><span class="selector-class">.mod</span></span><br><span class="line">└── <span class="selector-tag">proto</span></span><br><span class="line">    └── <span class="selector-tag">chat</span><span class="selector-class">.proto</span></span><br></pre></td></tr></table></figure><h4 id="3-3-实现-GRPC-服务"><a href="#3-3-实现-GRPC-服务" class="headerlink" title="3.3 实现 GRPC 服务"></a>3.3 实现 GRPC 服务</h4><p>上述生成 <code>pb</code> 和 <code>grpc</code> 相关代码后，实现一个 <code>gRPC Server</code> 服务，<a href="https://github.com/blazehu/sse-demo/blob/main/server/server.go" target="_blank" rel="noopener">相关代码</a>如下：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/blazehu/sse-demo/gen/proto"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/protobuf/types/known/emptypb"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server provides chat service</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">chat.UnimplementedChatServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chat returns chat content</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Chat</span><span class="params">(_ *emptypb.Empty, stream chat.ChatService_ChatServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg := chat.Message&#123;</span><br><span class="line">User:    <span class="string">"blazehu"</span>,</span><br><span class="line">Content: time.Now().Format(time.RFC3339),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := stream.Send(&amp;msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lis, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":50051"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> opts []grpc.ServerOption</span><br><span class="line">grpcServer := grpc.NewServer(opts...)</span><br><span class="line">chat.RegisterChatServiceServer(grpcServer, &amp;Server&#123;&#125;)</span><br><span class="line">grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑非常简单，定义 <code>Server</code> 对象然后实现了相关的 <code>Chat</code> 方法，然后 main 函数注册并启动了一个 <code>gRPC Server</code> 服务。</p><blockquote><p>NOTE: <code>Chat</code> 方法是每隔一秒钟就发送一条消息，该消息内容就是当前的时间。</p></blockquote><h4 id="3-4-实现-HTTP-服务"><a href="#3-4-实现-HTTP-服务" class="headerlink" title="3.4 实现 HTTP 服务"></a>3.4 实现 HTTP 服务</h4><p>新增 <code>main.go</code> 文件，在 <code>main.go</code> 文件中添加和启动 <code>gRPC-Gateway mux</code>。<a href="https://github.com/blazehu/sse-demo/blob/main/main.go" target="_blank" rel="noopener">相关代码</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/blazehu/sse-demo/gen/proto"</span></span><br><span class="line"><span class="string">"github.com/blazehu/sse-demo/util"</span></span><br><span class="line"><span class="string">"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc/credentials/insecure"</span></span><br><span class="line">googleproto <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">grpcEndpoint = <span class="string">"localhost:50051"</span></span><br><span class="line">httpPort     = <span class="string">":8080"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFilter</span><span class="params">(ctx context.Context, w http.ResponseWriter, resp googleproto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line">w.Header().Set(<span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 gRPC 连接</span></span><br><span class="line"><span class="keyword">var</span> opts []grpc.DialOption</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">grpcConn, err := grpc.DialContext(ctx, grpcEndpoint, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Failed to dial server: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> grpcConn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 gRPC-Gateway 服务器</span></span><br><span class="line">gwmux := runtime.NewServeMux(</span><br><span class="line">runtime.WithMarshalerOption(runtime.MIMEWildcard, util.NewCustomTranscoder(&amp;runtime.JSONPb&#123;&#125;)),</span><br><span class="line">runtime.WithForwardResponseOption(myFilter),</span><br><span class="line">)</span><br><span class="line">err = chat.RegisterChatServiceHandler(ctx, gwmux, grpcConn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Failed to register gateway: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 CORS 策略</span></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">handler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>)</span><br><span class="line">w.Header().Set(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET, POST, PUT, DELETE, OPTIONS"</span>)</span><br><span class="line">w.Header().Set(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type, Authorization"</span>)</span><br><span class="line"><span class="keyword">if</span> r.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">gwmux.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">mux.Handle(<span class="string">"/"</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 gRPC-Gateway 服务器</span></span><br><span class="line">log.Printf(<span class="string">"Starting gRPC-Gateway on %s"</span>, httpPort)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(httpPort, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"Failed to serve: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为前端 sse 访问需要跨域所以需要设置 <code>CORS</code> 策略，并且返回的消息类型为 <code>text/event-stream</code>，所以我们这里自定义一个 <code>CustomTranscoder</code>，它将 <code>JSON</code> 转换为 <code>text/event-stream</code> 格式。<a href="https://github.com/blazehu/sse-demo/blob/main/util/tool.go" target="_blank" rel="noopener">相关实现</a>如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"</span></span><br><span class="line"><span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomTranscoder <span class="keyword">struct</span> &#123;</span><br><span class="line">marshaler runtime.Marshaler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCustomTranscoder</span><span class="params">(marshaler runtime.Marshaler)</span> *<span class="title">CustomTranscoder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CustomTranscoder&#123;marshaler: marshaler&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">ContentType</span><span class="params">(_ <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"text/event-stream"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> jsonBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pb, ok := v.(proto.Message); ok &#123;</span><br><span class="line"><span class="comment">// Marshal message to JSON</span></span><br><span class="line">jsonBytes, err = c.marshaler.Marshal(pb)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// If not a proto.Message, try to marshal it as a regular JSON object</span></span><br><span class="line">jsonBytes, err = json.Marshal(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.WriteString(<span class="string">"data: "</span>)</span><br><span class="line">buf.Write(jsonBytes)</span><br><span class="line">buf.WriteString(<span class="string">"\n\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> buf.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.marshaler.Unmarshal(data, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> <span class="title">runtime</span>.<span class="title">Decoder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.marshaler.NewDecoder(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CustomTranscoder)</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> <span class="title">runtime</span>.<span class="title">Encoder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.marshaler.NewEncoder(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: 这里需要注意输入值转化为 <code>proto.Message</code> 类型可能会失败，所以我们在 Marshal 方法中添加一个检查，以确保输入值是一个 <code>proto.Message</code> 类型。如果不是，我们可以尝试将其序列化为 <code>JSON</code>。</p></blockquote><h4 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h4><p>同时启动 <code>gRPC Server</code> 和 <code>HTTP Server</code>，然后浏览器访问地址: <a href="http://127.0.0.1:8080/api/v1/stream/chat" target="_blank" rel="noopener">http://127.0.0.1:8080/api/v1/stream/chat</a> ，可以发现浏览器将会每秒刷新一条数据。</p><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd-sse-curl.png" alt="argocd-sse-curl"></p><h4 id="3-6-前端实现"><a href="#3-6-前端实现" class="headerlink" title="3.6 前端实现"></a>3.6 前端实现</h4><p>前端使用 <code>vue2</code>，这里就不详细说明了，页面通过 <code>EventSource</code> 与服务端建立通信，然后一直在接收服务端推送的消息，并将消息更新至页面上。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadData();</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="keyword">async</span> loadData() &#123;</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">"http://127.0.0.1:8080/api/v1/stream/chat"</span>);</span><br><span class="line">        eventSource.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'connect eventSource success.'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        eventSource.onmessage =  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">            vm.msg = <span class="string">`<span class="subst">$&#123;data.result.content&#125;</span> - <span class="subst">$&#123;data.result.user&#125;</span> send`</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        eventSource.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'connect eventSource failed.'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.$forceUpdate();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h3><ul><li><a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Server-sent_events</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events</a></li><li><a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/generating_stubs/using_buf/" target="_blank" rel="noopener">https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/generating_stubs/using_buf/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;服务器发送事件 (Server-Sent Events) 是一种服务器推送技术，使客户端能够通过 HTTP 连接从服务器接收自动更新，并描述了在建立初始客户端连接后服务器如何向客户端发起数据传输。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="argocd" scheme="https://blazehu.github.io/tags/argocd/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
    <category term="sse" scheme="https://blazehu.github.io/tags/sse/"/>
    
  </entry>
  
  <entry>
    <title>ArgoCD 源码解析：自动同步机制</title>
    <link href="https://blazehu.github.io/2023/10/25/cloudnative/argocd_webhook/"/>
    <id>https://blazehu.github.io/2023/10/25/cloudnative/argocd_webhook/</id>
    <published>2023-10-24T16:00:00.000Z</published>
    <updated>2025-08-15T04:10:23.370Z</updated>
    
    <content type="html"><![CDATA[<p>Argo CD 的自动同步功能通过监控 Git 仓库中的更改来自动部署和更新应用程序。这确保了 Kubernetes 集群中的应用程序始终与 Git 仓库中的配置保持一致。开发团队只需将应用程序的描述和配置存储在 Git 仓库中，Argo CD 会根据这些信息自动部署和更新应用程序。</p><a id="more"></a><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>Argo CD 是一个开源的持续部署工具，专为 Kubernetes 应用程序设计。它遵循 GitOps 原则，将 Git 仓库作为应用程序部署和基础设施管理的“单一真实来源”。架构上 Argo CD 采用基于组件的架构设计，将不同可部署单元的职责分开，以提高系统的灵活性、可维护性和可扩展性。</p><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_webhook_dependencies.png" alt="argocd_webhook_dependencies"></p><blockquote><p>有关架构的详细介绍可以阅读<a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/" target="_blank" rel="noopener">这篇文档</a>。</p></blockquote><p>通过阅读 Argo CD 官方文档我们可以知道 Argo CD 每三分钟轮询一次 Git 存储库，以检测清单的更改。为了消除轮询延迟，Argo CD API server 支持 <a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/#1-create-the-webhook-in-the-git-provider" target="_blank" rel="noopener">配置 Git Webhook</a>。</p><h3 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h3><blockquote><p>本文的源码基于2.6.0版本</p></blockquote><h4 id="2-1-main-go-入口函数"><a href="#2-1-main-go-入口函数" class="headerlink" title="2.1 main.go 入口函数"></a>2.1 main.go 入口函数</h4><p>Argo CD 使用 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a> 来构建应用程序。通过 <code>cmd</code> 目录下的 <code>main.go</code> 入口函数，我们可以很轻易的找到每个组件。根据架构可知 API Server 是控制平面中的唯一入口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">command = apiserver.NewCommand()</span><br></pre></td></tr></table></figure><h4 id="2-2-argocd-server"><a href="#2-2-argocd-server" class="headerlink" title="2.2 argocd-server"></a>2.2 argocd-server</h4><p>阅读 <code>ArgoCDServer</code> 实例的 <code>Run</code> 方法，可以发现 <code>ArgoCDServer</code> 使用 <a href="https://github.com/soheilhy/cmux" target="_blank" rel="noopener"><code>cmux</code></a> 库在多路复用，在同一端口上处理标准 HTTP 和 gRPC 请求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">grpcS, appResourceTreeFn := a.newGRPCServer() </span><br><span class="line">grpcWebS := grpcweb.WrapServer(grpcS)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">httpS = a.newHTTPServer(ctx, a.ListenPort, grpcWebS, appResourceTreeFn, listeners.GatewayConn) </span><br><span class="line"></span><br><span class="line">tcpm := cmux.New(listeners.Main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !a.useTLS() &#123;</span><br><span class="line">    httpL = tcpm.Match(cmux.HTTP1Fast())</span><br><span class="line">    grpcL = tcpm.MatchWithWriters(cmux.HTTP2MatchHeaderFieldSendSettings(<span class="string">"content-type"</span>, <span class="string">"application/grpc"</span>))</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a.checkServeErr(<span class="string">"grpcS"</span>, grpcS.Serve(grpcL)) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a.checkServeErr(<span class="string">"httpS"</span>, httpS.Serve(httpL)) &#125;()</span><br></pre></td></tr></table></figure><p>我在官方文档上找到 Argo CD 中如何实现身份验证（authn）和授权（authz）的一张图，可以发现当我们通过 Web 页面或者 CLI 调用 apiserver 的时候首先经过 <code>cmux</code> 检查匹配，如果请求是 http1.x 将由 <code>http mux</code> 处理，如果是 http2 并且 <code>content-type: application/grpc</code> 则由 <code>grpc Server</code> 处理。</p><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_webhook_apiserver.png" alt="argocd_webhook_apiserver"></p><blockquote><p>由于 Argo CD apiserver 绝大多数的 API 服务是通过 gRPC 实现的，所以这里引入了 gRPC Gateway 来将 gRPC 服务转换为 RESTful API。</p></blockquote><h5 id="2-2-1-ArgoCDWebhookHandler"><a href="#2-2-1-ArgoCDWebhookHandler" class="headerlink" title="2.2.1 ArgoCDWebhookHandler"></a>2.2.1 ArgoCDWebhookHandler</h5><p>从<a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/#1-create-the-webhook-in-the-git-provider" target="_blank" rel="noopener">配置 Git Webhook</a> 中找到 webhook events 的 endpoint 是 /api/webhook 。是走的 http1.x，我们查看 <code>ArgoCDServer</code> 实例的 <code>newHTTPServer</code> 方法，路径为 “/api/webhook” 的 HTTP 请求映射的是 <code>acdWebhookHandler.Handler</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webhook handler for git events (Note: cache timeouts are hardcoded because API server does not write to cache and not really using them)</span></span><br><span class="line">argoDB := db.NewDB(a.Namespace, a.settingsMgr, a.KubeClientset)</span><br><span class="line">acdWebhookHandler := webhook.NewHandler(a.Namespace, a.ArgoCDServerOpts.ApplicationNamespaces, a.AppClientset, a.settings, a.settingsMgr, repocache.NewCache(a.Cache.GetCache(), <span class="number">24</span>*time.Hour, <span class="number">3</span>*time.Minute), a.Cache, argoDB)</span><br><span class="line"></span><br><span class="line">mux.HandleFunc(<span class="string">"/api/webhook"</span>, acdWebhookHandler.Handler)</span><br></pre></td></tr></table></figure><p>继续往下看 <code>ArgoCDWebhookHandler</code> 的 <code>Handle</code> 方法的具体实现，根据请求的 Header 解析得到不同 Git 服务提供商的 Git 事件的数据，然后交给 <code>HandleEvent</code> 方法来处理，<code>HandleEvent</code> 经过一系列的校验检查后执行 <code>RefreshApp</code> 刷新应用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleEvent handles webhook events for repo push events</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *ArgoCDWebhookHandler)</span> <span class="title">HandleEvent</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-RefreshApp"><a href="#2-2-2-RefreshApp" class="headerlink" title="2.2.2 RefreshApp"></a>2.2.2 RefreshApp</h5><p>注释写的很清楚，<code>RefreshApp</code> 通过更新应用的注解，强制控制器处理它。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RefreshApp updates the refresh annotation of an application to coerce the controller to process it</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RefreshApp</span><span class="params">(appIf v1alpha1.ApplicationInterface, name <span class="keyword">string</span>, refreshType argoappv1.RefreshType)</span> <span class="params">(*argoappv1.Application, error)</span></span> &#123;</span><br><span class="line">metadata := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"metadata"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"annotations"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">argoappv1.AnnotationKeyRefresh: <span class="keyword">string</span>(refreshType),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">patch, err := json.Marshal(metadata)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error marshaling metadata: %w"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> attempt := <span class="number">0</span>; attempt &lt; <span class="number">5</span>; attempt++ &#123;</span><br><span class="line">app, err := appIf.Patch(context.Background(), name, types.MergePatchType, patch, metav1.PatchOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !apierr.IsConflict(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"error patching annotations in application %q: %w"</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Infof(<span class="string">"Requested app '%s' refresh"</span>, name)</span><br><span class="line"><span class="keyword">return</span> app, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-application-controller"><a href="#2-3-application-controller" class="headerlink" title="2.3 application-controller"></a>2.3 application-controller</h4><p>沿着之前的路径，从入口函数找到应用控制器的实现，appcontroller 中定义了默认的同步周期为180s。控制器通过 <code>newApplicationInformerAndLister</code> 创建 <code>ApplicationInformer</code> 监听应用的事件并加入到队列中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Default time in seconds for application resync period</span></span><br><span class="line">defaultAppResyncPeriod = <span class="number">180</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">resyncDuration = time.Duration(appResyncPeriod) * time.Second</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">appController, err = controller.NewApplicationController(</span><br><span class="line">    namespace,</span><br><span class="line">    settingsMgr,</span><br><span class="line">    kubeClient,</span><br><span class="line">    appClient,</span><br><span class="line">    repoClientset,</span><br><span class="line">    cache,</span><br><span class="line">    kubectl,</span><br><span class="line">    resyncDuration,</span><br><span class="line">    hardResyncDuration,</span><br><span class="line">    time.Duration(selfHealTimeoutSeconds)*time.Second,</span><br><span class="line">    metricsPort,</span><br><span class="line">    metricsCacheExpiration,</span><br><span class="line">    metricsAplicationLabels,</span><br><span class="line">    kubectlParallelismLimit,</span><br><span class="line">    persistResourceHealth,</span><br><span class="line">    clusterFilter,</span><br><span class="line">    applicationNamespaces)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="keyword">go</span> appController.Run(ctx, statusProcessors, operationProcessors)</span><br></pre></td></tr></table></figure><h5 id="2-3-1-newApplicationInformerAndLister"><a href="#2-3-1-newApplicationInformerAndLister" class="headerlink" title="2.3.1 newApplicationInformerAndLister"></a>2.3.1 newApplicationInformerAndLister</h5><p>上文中 <code>RefreshApp</code> 更新应用的注解将会产生一个 Update Event，将会走到 <code>requestAppRefresh</code> 。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">informer.AddEventHandler(</span><br><span class="line">    cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                ctrl.appRefreshQueue.Add(key)</span><br><span class="line">                ctrl.appOperationQueue.Add(key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(<span class="built_in">new</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key, err := cache.MetaNamespaceKeyFunc(<span class="built_in">new</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> compareWith *CompareWith</span><br><span class="line">            oldApp, oldOK := old.(*appv1.Application)</span><br><span class="line">            newApp, newOK := <span class="built_in">new</span>.(*appv1.Application)</span><br><span class="line">            <span class="keyword">if</span> oldOK &amp;&amp; newOK &amp;&amp; automatedSyncEnabled(oldApp, newApp) &#123;</span><br><span class="line">                log.WithField(<span class="string">"application"</span>, newApp.QualifiedName()).Info(<span class="string">"Enabled automated sync"</span>)</span><br><span class="line">                compareWith = CompareWithLatest.Pointer()</span><br><span class="line">            &#125;</span><br><span class="line">            ctrl.requestAppRefresh(newApp.QualifiedName(), compareWith, <span class="literal">nil</span>)</span><br><span class="line">            ctrl.appOperationQueue.Add(key)</span><br><span class="line">        &#125;,</span><br><span class="line">        DeleteFunc: <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !ctrl.canProcessApp(obj) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// IndexerInformer uses a delta queue, therefore for deletes we have to use this</span></span><br><span class="line">            <span class="comment">// key function.</span></span><br><span class="line">            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                ctrl.appRefreshQueue.Add(key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="2-3-2-requestAppRefresh"><a href="#2-3-2-requestAppRefresh" class="headerlink" title="2.3.2 requestAppRefresh"></a>2.3.2 requestAppRefresh</h5><p><code>compareWith</code> 是 <code>CompareWithLatest</code>， <code>after</code> 是 <code>nil</code>。requestAppRefresh 方法将会在 <code>appRefreshQueue</code> 和 <code>appOperationQueue</code> 队列中添加该更新事件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestAppRefresh adds a request for given app to the refresh queue. appName</span></span><br><span class="line"><span class="comment">// needs to be the qualified name of the application, i.e. &lt;namespace&gt;/&lt;name&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">requestAppRefresh</span><span class="params">(appName <span class="keyword">string</span>, compareWith *CompareWith, after *time.Duration)</span></span> &#123;</span><br><span class="line">key := ctrl.toAppKey(appName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> compareWith != <span class="literal">nil</span> &amp;&amp; after != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.appComparisonTypeRefreshQueue.AddAfter(fmt.Sprintf(<span class="string">"%s/%d"</span>, key, compareWith), *after)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> compareWith != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.refreshRequestedAppsMutex.Lock()</span><br><span class="line">ctrl.refreshRequestedApps[key] = compareWith.Max(ctrl.refreshRequestedApps[key])</span><br><span class="line">ctrl.refreshRequestedAppsMutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> after != <span class="literal">nil</span> &#123;</span><br><span class="line">ctrl.appRefreshQueue.AddAfter(key, *after)</span><br><span class="line">ctrl.appOperationQueue.AddAfter(key, *after)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctrl.appRefreshQueue.Add(key)</span><br><span class="line">ctrl.appOperationQueue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-run"><a href="#2-3-3-run" class="headerlink" title="2.3.3 run"></a>2.3.3 run</h5><p>控制器使用两个单独的队列来处理应用的协调（<code>appRefreshQueue</code>）和同步（<code>appOperationQueue</code>），这两个队列分别通过 <code>processAppRefreshQueueItem</code> 和 <code>processAppOperationQueueItem</code> 来处理。</p><blockquote><p><code>statusProcessors</code> 和 <code>operationProcessors</code> 来控制启动协程的数量。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run starts the Application CRD controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">Run</span><span class="params">(ctx context.Context, statusProcessors <span class="keyword">int</span>, operationProcessors <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appRefreshQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appComparisonTypeRefreshQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.appOperationQueue.ShutDown()</span><br><span class="line"><span class="keyword">defer</span> ctrl.projectRefreshQueue.ShutDown()</span><br><span class="line"></span><br><span class="line">ctrl.metricsServer.RegisterClustersInfoSource(ctx, ctrl.stateCache)</span><br><span class="line">ctrl.RegisterClusterSecretUpdater(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> ctrl.appInformer.Run(ctx.Done())</span><br><span class="line"><span class="keyword">go</span> ctrl.projInformer.Run(ctx.Done())</span><br><span class="line"></span><br><span class="line">errors.CheckError(ctrl.stateCache.Init())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForCacheSync(ctx.Done(), ctrl.appInformer.HasSynced, ctrl.projInformer.HasSynced) &#123;</span><br><span class="line">log.Error(<span class="string">"Timed out waiting for caches to sync"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errors.CheckError(ctrl.stateCache.Run(ctx)) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; errors.CheckError(ctrl.metricsServer.ListenAndServe()) &#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; statusProcessors; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppRefreshQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; operationProcessors; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppOperationQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processAppComparisonTypeQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ctrl.processProjectQueueItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time.Second, ctx.Done())</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-processAppRefreshQueueItem"><a href="#2-3-4-processAppRefreshQueueItem" class="headerlink" title="2.3.4 processAppRefreshQueueItem"></a>2.3.4 processAppRefreshQueueItem</h5><p>从 <code>appRefreshQueue</code> 获取到上文中更新注解的事件后调用 <code>needRefreshAppStatus</code>，<code>needRefresh, refreshType, comparisonLevel = true, RefreshTypeNormal, CompareWithLatestForceResolve</code>。然后通过 <code>CompareAppState</code> 使用指定的版本和提供的源来比较应用程序 git 状态与实时应用程序状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">appKey, shutdown := ctrl.appRefreshQueue.Get()</span><br><span class="line"></span><br><span class="line">obj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line">origApp, ok := obj.(*appv1.Application)</span><br><span class="line"></span><br><span class="line">needRefresh, refreshType, comparisonLevel := ctrl.needRefreshAppStatus(origApp, ctrl.statusRefreshTimeout, ctrl.statusHardRefreshTimeout)</span><br><span class="line"></span><br><span class="line">compareResult := ctrl.appStateManager.CompareAppState(app, project, revisions, sources,</span><br><span class="line">    refreshType == appv1.RefreshTypeHard,</span><br><span class="line">    comparisonLevel == CompareWithLatestForceResolve, localManifests, hasMultipleSources)</span><br></pre></td></tr></table></figure><blockquote><p>上文提到的三分钟定时轮训也是在 needRefreshAppStatus 中实现。</p></blockquote><p><code>CompareAppState</code> 方法中会调用 <code>appStateManager</code> 实例的 <code>getRepoObjs</code> 来获取 Git 仓库中渲染出的清单文件。<code>getRepoObjs</code> 通过 gRPC 调用 reposerver 的 <code>GenerateManifest</code> 方法获取渲染出的清单文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppStateManager defines methods which allow to compare application spec and actual application state.</span></span><br><span class="line"><span class="keyword">type</span> AppStateManager <span class="keyword">interface</span> &#123;</span><br><span class="line">CompareAppState(app *v1alpha1.Application, project *appv1.AppProject, revisions []<span class="keyword">string</span>, sources []v1alpha1.ApplicationSource, noCache <span class="keyword">bool</span>, noRevisionCache <span class="keyword">bool</span>, localObjects []<span class="keyword">string</span>, hasMultipleSources <span class="keyword">bool</span>) *comparisonResult</span><br><span class="line">SyncAppState(app *v1alpha1.Application, state *v1alpha1.OperationState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// repoClientset 初始化后层层传递至 `AppStateManager` 实例中</span></span><br><span class="line">repoClientset := apiclient.NewRepoServerClientset(repoServerAddress, repoServerTimeoutSeconds, tlsConfig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getRepoObjs 通过 gRPC 调用 reposerver 的 GenerateManifest 方法</span></span><br><span class="line">manifestInfo, err := repoClient.GenerateManifest(context.Background(), &amp;apiclient.ManifestRequest&#123;</span><br><span class="line">    Repo:               repo,</span><br><span class="line">    Repos:              permittedHelmRepos,</span><br><span class="line">    Revision:           revisions[i],</span><br><span class="line">    NoCache:            noCache,</span><br><span class="line">    NoRevisionCache:    noRevisionCache,</span><br><span class="line">    AppLabelKey:        appLabelKey,</span><br><span class="line">    AppName:            app.InstanceName(m.namespace),</span><br><span class="line">    Namespace:          app.Spec.Destination.Namespace,</span><br><span class="line">    ApplicationSource:  &amp;source,</span><br><span class="line">    Plugins:            tools,</span><br><span class="line">    KustomizeOptions:   kustomizeOptions,</span><br><span class="line">    KubeVersion:        serverVersion,</span><br><span class="line">    ApiVersions:        argo.APIResourcesToStrings(apiResources, <span class="literal">true</span>),</span><br><span class="line">    VerifySignature:    verifySignature,</span><br><span class="line">    HelmRepoCreds:      permittedHelmCredentials,</span><br><span class="line">    TrackingMethod:     <span class="keyword">string</span>(argo.GetTrackingMethod(m.settingsMgr)),</span><br><span class="line">    EnabledSourceTypes: enabledSourceTypes,</span><br><span class="line">    HelmOptions:        helmOptions,</span><br><span class="line">    HasMultipleSources: app.Spec.HasMultipleSources(),</span><br><span class="line">    RefSources:         refSources,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>得到 <code>compareResult</code> 后会调用 <code>autoSync</code> 方法，如果应用开启了自动同步，将会更新 <code>Application</code> 的 <code>Operation</code> ，来启动同步操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autoSync will initiate a sync operation for an application configured with automated sync</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">autoSync</span><span class="params">(app *appv1.Application, syncStatus *appv1.SyncStatus, resources []appv1.ResourceStatus)</span> *<span class="title">appv1</span>.<span class="title">ApplicationCondition</span></span></span><br></pre></td></tr></table></figure><p><code>processAppRefreshQueueItem</code> 最后将会调用 <code>persistAppStatus</code> 方法用于持久化，通过调用 k8s api 更新 applicaition 的 status。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// persistAppStatus persists updates to application status. If no changes were made, it is a no-op</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">persistAppStatus</span><span class="params">(orig *appv1.Application, newStatus *appv1.ApplicationStatus)</span></span> </span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 2.3.5 processAppOperationQueueItem</span></span><br><span class="line"><span class="string">跟 `</span>processAppRefreshQueueItem<span class="string">` 类似，从 `</span>appOperationQueue<span class="string">` 队列中拿到待执行同步操作的应用实例，判断该应用的 `</span>Operation<span class="string">` 字段是否为空，如果不为空则执行 `</span>processRequestedAppOperation<span class="string">`。`</span>processRequestedAppOperation<span class="string">` 也会进行一些状态校验，比如是否正在同步中等，最终应用下资源的同步将由 `</span>appStateManager<span class="string">` 实例的 `</span>SyncAppState<span class="string">` 实现。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctrl *ApplicationController)</span> <span class="title">processRequestedAppOperation</span><span class="params">(app *appv1.Application)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> err := argo.ValidateDestination(context.Background(), &amp;app.Spec.Destination, ctrl.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">state.Phase = synccommon.OperationFailed</span><br><span class="line">state.Message = err.Error()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctrl.appStateManager.SyncAppState(app, state)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *appStateManager)</span> <span class="title">SyncAppState</span><span class="params">(app *v1alpha1.Application, state *v1alpha1.OperationState)</span></span> &#123;</span><br><span class="line"><span class="comment">// Sync requests might be requested with ambiguous revisions (e.g. master, HEAD, v1.2.3).</span></span><br><span class="line"><span class="comment">// This can change meaning when resuming operations (e.g a hook sync). After calculating a</span></span><br><span class="line"><span class="comment">// concrete git commit SHA, the SHA is remembered in the status.operationState.syncResult field.</span></span><br><span class="line"><span class="comment">// This ensures that when resuming an operation, we sync to the same revision that we initially</span></span><br><span class="line"><span class="comment">// started with.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    syncCtx, cleanup, err := sync.NewSyncContext(</span><br><span class="line">compareResult.syncStatus.Revision,</span><br><span class="line">reconciliationResult,</span><br><span class="line">restConfig,</span><br><span class="line">rawConfig,</span><br><span class="line">m.kubectl,</span><br><span class="line">app.Spec.Destination.Namespace,</span><br><span class="line">openAPISchema,</span><br><span class="line">opts...,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">state.Phase = common.OperationError</span><br><span class="line">state.Message = fmt.Sprintf(<span class="string">"failed to initialize sync context: %v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> cleanup()</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> state.Phase == common.OperationTerminating &#123;</span><br><span class="line">syncCtx.Terminate()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">syncCtx.Sync()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/argoproj/argo-cd/blob/6e2f2c9d1e2339b3361f3a057747fcfe30e36f44/controller/sync.go#L296" target="_blank" rel="noopener"><code>syncCtx</code></a> 我们这里看接口定义大致了解即可，具体实现这里就不再展开了。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SyncContext defines an interface that allows to execute sync operation step or terminate it.</span></span><br><span class="line"><span class="keyword">type</span> SyncContext <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Terminate terminates sync operation. The method is asynchronous: it starts deletion is related K8S resources</span></span><br><span class="line"><span class="comment">// such as in-flight resource hooks, updates operation status, and exists without waiting for resource completion.</span></span><br><span class="line">Terminate()</span><br><span class="line"><span class="comment">// Executes next synchronization step and updates operation status.</span></span><br><span class="line">Sync()</span><br><span class="line"><span class="comment">// Returns current sync operation state and information about resources synchronized so far.</span></span><br><span class="line">GetState() (common.OperationPhase, <span class="keyword">string</span>, []common.ResourceSyncResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <a href="https://github.com/argoproj/gitops-engine/blob/master/pkg/sync/sync_context.go" target="_blank" rel="noopener">SyncContext</a> 是由 <code>gitops-engine</code> 库实现。</p></blockquote><h3 id="3-源码流程图"><a href="#3-源码流程图" class="headerlink" title="3. 源码流程图"></a>3. 源码流程图</h3><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/argocd_webhook_request.png" alt="argocd_webhook_request"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>自动同步是 Argo CD 的核心功能，了解其底层实现原理和源码有助于拓展技术视野，深入理解 Argo CD 的工作原理，并在遇到问题时提供解决方案。</p><h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h3><ul><li><a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/components/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/authz-authn/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/developer-guide/architecture/authz-authn/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/webhook/</a></li><li><a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/" target="_blank" rel="noopener">https://argo-cd.readthedocs.io/en/stable/operator-manual/high_availability/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Argo CD 的自动同步功能通过监控 Git 仓库中的更改来自动部署和更新应用程序。这确保了 Kubernetes 集群中的应用程序始终与 Git 仓库中的配置保持一致。开发团队只需将应用程序的描述和配置存储在 Git 仓库中，Argo CD 会根据这些信息自动部署和更新应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="argocd" scheme="https://blazehu.github.io/tags/argocd/"/>
    
    <category term="gitops" scheme="https://blazehu.github.io/tags/gitops/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffers 学习笔记</title>
    <link href="https://blazehu.github.io/2023/03/22/backend/golang/golang_pb/"/>
    <id>https://blazehu.github.io/2023/03/22/backend/golang/golang_pb/</id>
    <published>2023-03-21T16:00:00.000Z</published>
    <updated>2025-07-08T03:48:45.528Z</updated>
    
    <content type="html"><![CDATA[<p>Protocol Buffers 是一种跨语言、跨平台的序列化方法，可实现结构化数据的高效编码和解码。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Protocol Buffers 是一种数据序列化格式，类似于 JSON，但体积更小、速度更快，并支持本地语言绑定。它允许用户定义数据结构，并自动生成源代码，以便在各种数据流和编程语言中轻松读写结构化数据。</p><h3 id="Protocol-Buffers-解决了什么问题？"><a href="#Protocol-Buffers-解决了什么问题？" class="headerlink" title="Protocol Buffers 解决了什么问题？"></a>Protocol Buffers 解决了什么问题？</h3><p>Protocol Buffers 为最大几兆字节的类型化、结构化数据包提供一种序列化格式。该格式适用于短暂的网络传输和长期数据存储。它支持在不影响现有数据或更新代码的情况下扩展新信息，广泛应用于谷歌的服务器间通信和数据存储。它还能保持向后兼容性，支持添加新字段和删除现有字段。</p><h3 id="使用-Protocol-Buffers-有什么好处？"><a href="#使用-Protocol-Buffers-有什么好处？" class="headerlink" title="使用 Protocol Buffers 有什么好处？"></a>使用 Protocol Buffers 有什么好处？</h3><p>Protocol Buffers 非常适合需要以语言无关、平台无关、可扩展的方式序列化结构化、类似记录的类型化数据的任何场景。它们通常用于定义通信协议（与 gRPC 一起使用）以及数据存储。</p><h4 id="使用-Protocol-Buffers-的一些优点"><a href="#使用-Protocol-Buffers-的一些优点" class="headerlink" title="使用 Protocol Buffers 的一些优点"></a>使用 Protocol Buffers 的一些优点</h4><ul><li>紧凑的数据存储</li><li>快速解析</li><li>多种编程语言的支持</li><li>通过自动生成的类优化功能</li></ul><h4 id="跨语言兼容性"><a href="#跨语言兼容性" class="headerlink" title="跨语言兼容性"></a>跨语言兼容性</h4><p>同样的消息可以由任何支持的编程语言编写的代码读取。可以在一个平台上使用 Java 程序从一个软件系统捕获数据，根据 <code>.proto</code> 定义序列化它，然后在另一个平台上运行的单独的 Python 应用程序中从序列化数据中提取特定值。</p><p><strong>Protocol buffers 编译器 protoc 直接支持以下语言：</strong></p><ul><li><a href="https://protobuf.dev/reference/cpp/cpp-generated/#invocation" target="_blank" rel="noopener">C++</a></li><li><a href="https://protobuf.dev/reference/csharp/csharp-generated/#invocation" target="_blank" rel="noopener">C#</a></li><li><a href="https://protobuf.dev/reference/java/java-generated/#invocation" target="_blank" rel="noopener">Java</a></li><li><a href="https://protobuf.dev/reference/kotlin/kotlin-generated/#invocation" target="_blank" rel="noopener">Kotlin</a></li><li><a href="https://protobuf.dev/reference/objective-c/objective-c-generated/#invocation" target="_blank" rel="noopener">Objective-C</a></li><li><a href="https://protobuf.dev/reference/php/php-generated/#invocation" target="_blank" rel="noopener">PHP</a></li><li><a href="https://protobuf.dev/reference/python/python-generated/#invocation" target="_blank" rel="noopener">Python</a></li><li><a href="https://protobuf.dev/reference/ruby/ruby-generated/#invocation" target="_blank" rel="noopener">Ruby</a></li></ul><p><strong>以下语言由 Google 支持，但项目源代码位于 GitHub 仓库。protoc 编译器为这些语言使用插件：</strong></p><ul><li><a href="https://github.com/google/protobuf.dart" target="_blank" rel="noopener">Dart</a></li><li><a href="https://github.com/protocolbuffers/protobuf-go" target="_blank" rel="noopener">Go</a></li></ul><p>其他语言不直接由 Google 支持，而是由其他 GitHub 项目支持。这些语言在协议缓冲区的<a href="https://github.com/protocolbuffers/protobuf/blob/main/docs/third_party.md" target="_blank" rel="noopener">第三方插件</a>中有介绍。</p><h4 id="跨项目支持"><a href="#跨项目支持" class="headerlink" title="跨项目支持"></a>跨项目支持</h4><p>可以通过在 <code>.proto</code> 文件中定义消息类型并将其放置在特定项目代码库之外来在项目之间使用 Protocol buffers。如果你正在定义消息类型或枚举，并预计你的团队之外的人员将广泛使用它们，那么可以将它们放在没有依赖关系的单独文件中。<br>谷歌内部广泛使用的一些 <code>proto</code> 定义示例包括 <a href="https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto" target="_blank" rel="noopener">timestamp.proto</a> 和 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener">status.proto</a>。</p><h3 id="Go-生成代码指南"><a href="#Go-生成代码指南" class="headerlink" title="Go 生成代码指南"></a>Go 生成代码指南</h3><h4 id="编译器调用"><a href="#编译器调用" class="headerlink" title="编译器调用"></a>编译器调用</h4><p>Protocol buffer 编译器需要一个插件来生成 Go 代码。使用 Go 1.16 或更高版本运行以下命令来安装它：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure><h4 id="定义-proto-文件"><a href="#定义-proto-文件" class="headerlink" title="定义 proto 文件"></a>定义 <code>proto</code> 文件</h4><p>创建如下目录结构和定义一个用于测试的 <code>proto</code> 文件:</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── <span class="keyword">proto</span></span><br><span class="line">    └── demo.<span class="keyword">proto</span></span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> results_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好测试用的消息后，为了生成 GO 代码，还必须为每个 <code>.proto</code> 文件提供 Go 包的导入路径。有两种方式指定Go导入路径：</p><blockquote><p>NOTE: 导入路径就是生成的 Go 代码的文件路径。</p></blockquote><ol><li>在 <code>.proto</code> 文件中声明它</li><li>在调用 protoc 时在命令行上声明它</li></ol><blockquote><p>NOTE: 通常建议在 <code>.proto</code> 文件中声明它，以便通过 <code>.proto</code> 文件本身来集中识别，并简化调用 <code>protoc</code> 时传递的标志集。</p></blockquote><h5 id="1-在-proto-文件中声明"><a href="#1-在-proto-文件中声明" class="headerlink" title="1. 在 .proto 文件中声明"></a>1. 在 <code>.proto</code> 文件中声明</h5><p>在文件中通过 <code>go_package</code> 选项声明：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"proto/demo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> results_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>protoc --proto_path=proto --go_out=. demo.proto</code> 可以看到成功生成了代码：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── proto</span><br><span class="line">    ├── <span class="built_in">demo</span></span><br><span class="line">    │   └── <span class="built_in">demo</span>.pb.<span class="built_in">go</span></span><br><span class="line">    └── <span class="built_in">demo</span>.proto</span><br></pre></td></tr></table></figure><h5 id="2-在调用-protoc-时在命令行上声明"><a href="#2-在调用-protoc-时在命令行上声明" class="headerlink" title="2. 在调用 protoc 时在命令行上声明"></a>2. 在调用 protoc 时在命令行上声明</h5><p>传递一个或多个 <code>M${PROTO_FILE}=${GO_IMPORT_PATH}</code> 标志在命令行上指定。这个例子中通过 <code>--go_opt=Mdemo.proto=proto/demo</code> 声明。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=. --go_opt=Mdemo.proto=proto/demo demo.proto</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: Go 导入路径和 <code>.proto</code> 文件中的包说明符 <code>package</code> 之间没有关联。后者仅与 protobuf 命名空间相关，而前者仅与 Go 命名空间相关。此外，Go 导入路径和 <code>.proto</code> 导入路径之间没有关联。</p></blockquote><h4 id="生成-GO-代码"><a href="#生成-GO-代码" class="headerlink" title="生成 GO 代码"></a>生成 GO 代码</h4><p>使用 <code>protoc</code> 命令生成，如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=proto --go_out=. --go_opt=paths=source_relative demo.proto</span><br></pre></td></tr></table></figure><ul><li>proto_path：指定在编译 <code>.proto</code> 文件时查找导入文件的路径</li><li>go_out：生成的 Go 代码的导入路径</li><li>go_opt：用来指定生成的 Go 代码的一些特性，比如是否生成 gRPC 代码、是否使用快速的路径解析器等</li></ul><h5 id="常用的-go-opt-选项"><a href="#常用的-go-opt-选项" class="headerlink" title="常用的 go_opt 选项"></a>常用的 <code>go_opt</code> 选项</h5><ol><li><code>paths=source_relative</code>: 表示生成的 Go 代码的导入路径应该相对于 <code>.proto</code> 文件的源文件路径（即 <code>.proto</code> 文件的相对路径），而不是相对于 <code>GOPATH</code>。</li><li><code>M&lt;proto_import_path&gt;=&lt;go_import_path&gt;</code>: 映射 <code>.proto</code> 文件中的导入路径到 Go 代码中的导入路径。这在处理第三方 <code>.proto</code> 文件时非常有用，特别是当这些文件的导入路径与 Go 代码的导入路径不匹配时。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://protobuf.dev/overview/" target="_blank" rel="noopener">https://protobuf.dev/overview/</a></li><li><a href="https://protobuf.dev/reference/go/go-generated/#invocation" target="_blank" rel="noopener">https://protobuf.dev/reference/go/go-generated/#invocation</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Protocol Buffers 是一种跨语言、跨平台的序列化方法，可实现结构化数据的高效编码和解码。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://blazehu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="https://blazehu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>AntV G6 实现 k8s 资源拓扑图展示</title>
    <link href="https://blazehu.github.io/2023/01/30/frontend/g6_tree_demo/"/>
    <id>https://blazehu.github.io/2023/01/30/frontend/g6_tree_demo/</id>
    <published>2023-01-29T16:00:00.000Z</published>
    <updated>2025-08-15T03:48:13.289Z</updated>
    
    <content type="html"><![CDATA[<p>使用 AntV G6 实现类似 <code>argocd</code> 资源拓扑图的树图。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文主要记录总结如何使用 AntV G6 来展示 k8s 的资源拓扑图，下文简单实现一个 helm 部署 zookeeper 的图例，<a href="https://github.com/blazehu/g6-tree-demo" target="_blank" rel="noopener">代码地址</a> 。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里使用 vue2 来快速搭建一个页面，对 vue 熟悉的可以略过。 相关版本如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BLAZEHU-MB:Projects $ node --version</span><br><span class="line">v14.16.0</span><br><span class="line">BLAZEHU-MB:Projects $ vue --version</span><br><span class="line">@vue/cli 5.0.8</span><br></pre></td></tr></table></figure><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create g6-tree-demo</span><br></pre></td></tr></table></figure><p>官方快速上手文档：<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application" target="_blank" rel="noopener">https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application</a></p><h4 id="安装-amp-引用-G6"><a href="#安装-amp-引用-G6" class="headerlink" title="安装 &amp; 引用 G6"></a>安装 &amp; 引用 G6</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install --save @antv/g6</span><br></pre></td></tr></table></figure><p>官方快速上手文档：<a href="https://g6.antv.antgroup.com/manual/getting-started" target="_blank" rel="noopener">https://g6.antv.antgroup.com/manual/getting-started</a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h4><p>文件地址：common/index.js，参考官方 <a href="https://github.com/antvis/G6/blob/142e9eaeb8812d2b4770243bd3999166e076cdb3/packages/element/src/nodes/modelRect.ts" target="_blank" rel="noopener">modelRect</a> 内置节点源码。</p><h4 id="拓扑图实现逻辑"><a href="#拓扑图实现逻辑" class="headerlink" title="拓扑图实现逻辑"></a>拓扑图实现逻辑</h4><p>文件地址：components/DemoTree.vue，下面简单介绍：</p><ol><li>页面挂载后注册自定义元素 <code>执行 register 函数，后面简写为函数名</code>，初始化拓扑图 <code>initTree</code>。</li><li>初始化拓扑图首先准备数据 <code>initData</code>，然后创建拓扑图 <code>createTree</code>。</li><li>配置数据源，渲染 <code>data、render</code>。</li><li>更新数据使用 changeData 函数。</li></ol><blockquote><p>NOTE: id 如果不更新 changeData 页面刷新不完全，不能识别到node节点的变化。</p></blockquote><p>最终实现效果如下：<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/g6_tree_demo.png" alt="g6_tree_demo"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上文简单介绍了如何使用G6来绘制拓扑图，要实现类似 <code>argocd</code> 前端页面的效果我们还需要做节点折叠、节点菜单、节点标签展示等等，后续作者也在陆续完善。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://g6.antv.antgroup.com/manual/faq/performance-opt" target="_blank" rel="noopener">http://g6.antv.antgroup.com/manual/faq/performance-opt</a></li><li><a href="http://g6.antv.antgroup.com/zh/examples/scatter/node/#node" target="_blank" rel="noopener">http://g6.antv.antgroup.com/zh/examples/scatter/node/#node</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 AntV G6 实现类似 &lt;code&gt;argocd&lt;/code&gt; 资源拓扑图的树图。&lt;/p&gt;</summary>
    
    
    
    <category term="前端开发" scheme="https://blazehu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="g6" scheme="https://blazehu.github.io/tags/g6/"/>
    
  </entry>
  
  <entry>
    <title>Golang 版本管理工具：g</title>
    <link href="https://blazehu.github.io/2023/01/15/backend/golang/golang_g/"/>
    <id>https://blazehu.github.io/2023/01/15/backend/golang/golang_g/</id>
    <published>2023-01-14T16:00:00.000Z</published>
    <updated>2025-07-08T03:48:48.529Z</updated>
    
    <content type="html"><![CDATA[<p>在开发 Go 项目时，不同项目可能需要不同版本的 Go 语言环境。g 是一个简单而强大的 Go 版本管理工具，它可以帮助我们在同一台主机上轻松切换 Go 版本，并为每个项目创建独立的开发环境，避免版本冲突。</p><a id="more"></a><h3 id="g-安装"><a href="#g-安装" class="headerlink" title="g 安装"></a>g 安装</h3><p>g 是一个跨平台的 Go 版本管理工具，支持 Windows、Linux 和 macOS。<a href="https://github.com/voidint/g?tab=readme-ov-file#installation" target="_blank" rel="noopener">安装文档</a></p><h3 id="g-常用命令"><a href="#g-常用命令" class="headerlink" title="g 常用命令"></a>g 常用命令</h3><ol><li><p>查看可用的 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g ls-remote</span><br></pre></td></tr></table></figure></li><li><p>安装指定版本的 Go</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g install 1.20.3</span><br></pre></td></tr></table></figure></li><li><p>设置全局 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g use 1.20.3</span><br></pre></td></tr></table></figure></li><li><p>查看已安装的 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g ls</span><br></pre></td></tr></table></figure></li><li><p>卸载 Go 版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g uninstall 1.20.3</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用 g，我们可以在同一台主机上轻松管理多个 Go 版本，并为每个项目选择合适的版本。这不仅解决了不同项目对 Go 版本的需求，还避免了版本冲突，提高了开发效率。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/voidint/g" target="_blank" rel="noopener">g 文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发 Go 项目时，不同项目可能需要不同版本的 Go 语言环境。g 是一个简单而强大的 Go 版本管理工具，它可以帮助我们在同一台主机上轻松切换 Go 版本，并为每个项目创建独立的开发环境，避免版本冲突。&lt;/p&gt;</summary>
    
    
    
    <category term="后端开发" scheme="https://blazehu.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="golang" scheme="https://blazehu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>服务上云后如何使用 perf 生成火焰图</title>
    <link href="https://blazehu.github.io/2022/09/14/cloudnative/perf_analyse/"/>
    <id>https://blazehu.github.io/2022/09/14/cloudnative/perf_analyse/</id>
    <published>2022-09-13T16:00:00.000Z</published>
    <updated>2025-08-15T06:47:10.919Z</updated>
    
    <content type="html"><![CDATA[<p>业务上云迁移至腾讯云 Serverless 集群后，使用<code>perf</code>生成服务器的火焰图。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>业务模块使用的基础镜像是<code>Ubuntu20.04</code>，上云前的做法是在机器上docker run的，命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --cap-add CAP_SYS_ADMIN --privileged=true --pid=container:$&#123;targetContainerId&#125; --network=container:$&#123;targetContainerId&#125; $&#123;image&#125;:$&#123;imageTag&#125; -ti ...</span><br></pre></td></tr></table></figure><p>上云后通过在 Pod 中的容器之间共享进程命名空间的方式实现，在业务Pod中注入一个用于<code>perf</code>分析的容器。</p><h3 id="安装-perf"><a href="#安装-perf" class="headerlink" title="安装 perf"></a>安装 perf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install linux-tools-generic</span><br><span class="line">ln -s /usr/lib/linux-tools/5.4.0-125-generic/perf /usr/bin/perf</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>安装 linux-tools-generic 完成后，需要建立软链接，不然查看 <code>perf</code>版本，会提示如下报错信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf</span><br><span class="line">WARNING: perf not found for kernel 5.4.119-1</span><br><span class="line"></span><br><span class="line">  You may need to install the following packages for this specific kernel:</span><br><span class="line">    linux-tools-5.4.119-1-tlinux4-0009-public-eks</span><br><span class="line">    linux-cloud-tools-5.4.119-1-tlinux4-0009-public-eks</span><br><span class="line"></span><br><span class="line">  You may also want to install one of the following packages to keep up to date:</span><br><span class="line">    linux-tools-tlinux4-0009-public-eks</span><br><span class="line">    linux-cloud-tools-tlinux4-0009-public-eks</span><br></pre></td></tr></table></figure><blockquote><p>这里报错其实是因为<code>perf</code>已经内置在<code>linux-tools-generic</code>里面，所以我们安装后创建<code>perf</code>软链接即可（5.4.0-125-generic 版本目录根据实际情况替换即可）。</p></blockquote><h3 id="使用-perf-生成火焰图"><a href="#使用-perf-生成火焰图" class="headerlink" title="使用 perf 生成火焰图"></a>使用 perf 生成火焰图</h3><h4 id="pod-共享进程命名空间"><a href="#pod-共享进程命名空间" class="headerlink" title="pod 共享进程命名空间"></a>pod 共享进程命名空间</h4><p>使用 Pod <code>.spec</code> 中的 <code>shareProcessNamespace</code> 字段可以启用进程命名空间共享，官方例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  shareProcessNamespace: true</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">  - name: shell</span><br><span class="line">    image: busybox:1.28</span><br><span class="line">    securityContext:</span><br><span class="line">      capabilities:</span><br><span class="line">        add:</span><br><span class="line">        - SYS_PTRACE</span><br><span class="line">      privileged: true</span><br><span class="line">    stdin: true</span><br><span class="line">    tty: true</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>我们需要在 <code>perf</code> 容器中分析业务容器 <code>gamesvr</code>，这个操作需要 SYS_PTRACE 权能。所以我们需要为 <code>perf</code> Container 设置权能。通过安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。</p><p>这里列举部分能力：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CAP_SYS_MODULE: 允许插入和删除内核模块</span><br><span class="line">CAP_SYS_RAWIO:  允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备</span><br><span class="line">CAP_SYS_CHROOT: 允许使用chroot()系统调用</span><br><span class="line">CAP_SYS_PTRACE: 允许跟踪任何进程</span><br><span class="line">CAP_SYS_PACCT:  允许执行进程的BSD式审计</span><br></pre></td></tr></table></figure><p>我们使用 <code>perf</code>来分析业务进程，所以需要 CAP_SYS_PTRACE 权能。</p><blockquote><p>Linux Capabilities 的定义的形式为 CAP_XXX。但是你在 Container 字段使用时，需要将名称中的 CAP_ 部分去掉。例如，要添加 CAP_SYS_PTRACE，可在 capabilities 列表中添加 SYS_PTRACE。</p></blockquote><h4 id="perf-容器注入"><a href="#perf-容器注入" class="headerlink" title="perf 容器注入"></a>perf 容器注入</h4><p>我这里工作负载是使用的 deployment，通过 openkruise sidecarset 注入，这里就不赘述。注入完成后我们 exec 进入 perf 容器，执行 <code>ps -ef</code> 可以看到业务容器的进程 <code>gamesvr</code> 的进程ID是13。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">root@</span>game-server<span class="number">-6</span><span class="number">-6f</span>446dcxxx<span class="number">-5</span>j45b:~# ps -ef </span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           <span class="number">1</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /pause</span><br><span class="line">root          <span class="number">13</span>       <span class="number">0</span>  <span class="number">6</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">02</span>:<span class="number">37</span> /root/example/bin/gamesvr</span><br><span class="line">root          <span class="number">26</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">19</span>:<span class="number">29</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> sleep <span class="number">9</span>d</span><br><span class="line">root         <span class="number">786</span>       <span class="number">0</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">02</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> /bin/bash</span><br><span class="line">root         <span class="number">855</span>     <span class="number">842</span>  <span class="number">0</span> <span class="number">20</span>:<span class="number">11</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps -ef</span><br></pre></td></tr></table></figure><h4 id="perf-分析"><a href="#perf-分析" class="headerlink" title="perf 分析"></a>perf 分析</h4><p>执行 <code>perf record -F 99 -g -m 1 -p ${targetContainerId} -- sleep 120</code>，targetContainerId 是业务进程ID。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf record -F 99 -g -m 1 -p 13 -- sleep 120</span><br><span class="line">[ perf record: Woken up 65 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.148 MB perf.data (524 samples) ]</span><br></pre></td></tr></table></figure><p>查看分析文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf report -i perf.data &gt; perf.txt</span><br></pre></td></tr></table></figure><p>生成火焰图，这里会用到<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">火焰图工具</a>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">root@game-server-6-6f446dcxxx-5j45b:~# perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl &gt; demo.svg</span><br></pre></td></tr></table></figure><p>这里生成的 demo.svg 就是我们需要的火焰图（下面是一个例图）。开发可以通过火焰图来查看看服务的性能热点。</p><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/perf_analyse_flame.png" alt="perf_analyse_flame"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里协助开发使用 <code>perf</code> 生成火焰图的过程中遇到了2个问题，一是安装 <code>perf</code> 装不上报错，二是由于 <code>perf</code> 容器没有 SYS_PTRACE 权能导致生成的分析数据没有函数名称（只有地址信息）。通过协助排查问题加深了对 k8s Security Context的理解。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/</a></li><li><a href="https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html" target="_blank" rel="noopener">https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html</a></li><li><a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="noopener">https://github.com/brendangregg/FlameGraph</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;业务上云迁移至腾讯云 Serverless 集群后，使用&lt;code&gt;perf&lt;/code&gt;生成服务器的火焰图。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="https://blazehu.github.io/categories/CloudNative/"/>
    
    
    <category term="perf" scheme="https://blazehu.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04 安装 perf 报错</title>
    <link href="https://blazehu.github.io/2022/09/13/ops/linux/ubuntu_install_perf/"/>
    <id>https://blazehu.github.io/2022/09/13/ops/linux/ubuntu_install_perf/</id>
    <published>2022-09-12T16:00:00.000Z</published>
    <updated>2025-08-15T07:14:00.282Z</updated>
    
    <content type="html"><![CDATA[<p>在Ubuntu20.04系统中安装perf工具时出现的报错问题及解决方法。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>尝试安装<code>perf</code>生成服务器的火焰图，安装<code>perf</code>后报错，安装命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install linux-tools-generic</span><br></pre></td></tr></table></figure><p>安装完成后查看<code>perf</code>版本，发现报错如下<br><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/ubuntu_install_perf_error_1.png" alt="ubuntu_install_perf_error_1"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实<code>perf</code>已经内置在<code>linux-tools-generic</code>里面，所以安装后创建<code>perf</code>软链接即可（5.4.0-125-generic 版本目录根据实际情况替换即可）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /usr/lib/linux-tools/5.4.0-125-generic/perf /usr/bin/perf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Ubuntu20.04系统中安装perf工具时出现的报错问题及解决方法。&lt;/p&gt;</summary>
    
    
    
    <category term="运维" scheme="https://blazehu.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="perf" scheme="https://blazehu.github.io/tags/perf/"/>
    
  </entry>
  
  <entry>
    <title>蓝盾插件问题排查小记</title>
    <link href="https://blazehu.github.io/2022/08/21/devops/landun_plugins_ipapk/"/>
    <id>https://blazehu.github.io/2022/08/21/devops/landun_plugins_ipapk/</id>
    <published>2022-08-20T16:00:00.000Z</published>
    <updated>2025-08-15T03:54:52.975Z</updated>
    
    <content type="html"><![CDATA[<p>2021年给开发商做了一个<a href="https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Client-experience/intro.md" target="_blank" rel="noopener">移动端版本体验</a>，最近开发商反馈当上传的文件比较大时经常失败。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>用户报障说蓝盾插件使用经常失败。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="插件执行报错"><a href="#插件执行报错" class="headerlink" title="插件执行报错"></a>插件执行报错</h4><p>报错日志内容如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">202</span> : OverflowError: <span class="built_in">string</span> longer than <span class="number">2147483647</span> bytes</span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">362</span> : ##[error] </span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">362</span> : Fail to run the plugin because of error(Process exited with an error: <span class="number">1</span>)</span><br><span class="line"><span class="number">2022</span><span class="number">-06</span><span class="number">-28</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">19</span>:<span class="number">364</span> : ##[warning]No output</span><br></pre></td></tr></table></figure><p>日志报错分析：该插件是用来上传文件的，使用 <code>requests</code> 库来上传文件，这里报错信息是说明插件上传的文件太大。之前没有考虑到文件太大的情况。</p><h4 id="修复后偶尔报错超时504"><a href="#修复后偶尔报错超时504" class="headerlink" title="修复后偶尔报错超时504"></a>修复后偶尔报错超时504</h4><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_plugins_ipapk_img.png" alt="landun_plugins_ipapk_img"></p><p>日志报错分析：插件日志504，重试了3次。查看后端服务日志发现业务逻辑正常处理完毕，但是请求返回时 <code>write: broken pipe</code>。这里的报错可以基本判断是由于请求处理时间过长，当后端服务返回时 CLB 已经断开了连接。</p><h5 id="请求调用链路"><a href="#请求调用链路" class="headerlink" title="请求调用链路"></a>请求调用链路</h5><p>蓝盾插件 -&gt; 腾讯云CLB -&gt; 后端服务（CVM上跑的docker）</p><h5 id="腾讯云CLB监控"><a href="#腾讯云CLB监控" class="headerlink" title="腾讯云CLB监控"></a>腾讯云CLB监控</h5><p><img src="https://image-1251762279.cos.ap-shanghai.myqcloud.com/blog/landun_plugins_ipapk_timeout.png" alt="landun_plugins_ipapk_timeout"></p><p>排查到这里可以确定问题根因：CLB 的超时导致的504。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="插件上传报错解决方案"><a href="#插件上传报错解决方案" class="headerlink" title="插件上传报错解决方案"></a>插件上传报错解决方案</h4><p>插件侧优化代码使用 <code>requests-toolbelt</code> 上传文件。同时修改 <a href="https://cloud.tencent.com/document/product/214/15171" target="_blank" rel="noopener">CLB个性化配置</a> 支持超过2G的大文件上传，不缓存客户端请求体。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">5120M</span>;</span><br><span class="line"><span class="attribute">proxy_request_buffering</span> <span class="literal">off</span>;</span><br><span class="line"><span class="attribute">keepalive_timeout</span> <span class="number">900s</span>;</span><br></pre></td></tr></table></figure><h4 id="超时问题解决方案"><a href="#超时问题解决方案" class="headerlink" title="超时问题解决方案"></a>超时问题解决方案</h4><p>修改 <a href="https://cloud.tencent.com/document/product/214/15171" target="_blank" rel="noopener">CLB个性化配置</a> ，修改超时设置。这里主要修改 <code>proxy_read_timeout</code>。</p><blockquote><p>NOTE: proxy_read_timeout 是控制 CLB 至后端服务之间的超时时间。</p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">proxy_read_timeout</span> <span class="number">900s</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年给开发商做了一个&lt;a href=&quot;https://bk.tencent.com/docs/markdown/ZH/Devops/3.0/UserGuide/Services/Client-experience/intro.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;移动端版本体验&lt;/a&gt;，最近开发商反馈当上传的文件比较大时经常失败。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://blazehu.github.io/categories/DevOps/"/>
    
    
    <category term="蓝盾" scheme="https://blazehu.github.io/tags/%E8%93%9D%E7%9B%BE/"/>
    
    <category term="腾讯云" scheme="https://blazehu.github.io/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
  </entry>
  
</feed>
